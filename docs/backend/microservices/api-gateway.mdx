---
sidebar_position: 1
title: APIç½‘å…³è¯¦è§£
description: æ·±å…¥ç†è§£å¾®æœåŠ¡APIç½‘å…³çš„æ ¸å¿ƒæ¦‚å¿µã€å®ç°æ–¹æ¡ˆä¸æœ€ä½³å®è·µ
authors: [Laby]
tags: [APIç½‘å…³, å¾®æœåŠ¡, è´Ÿè½½å‡è¡¡, æœåŠ¡æ²»ç†, Spring Cloud Gateway]
last_update:
  date: 2025-08-15
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ComparisonTable from '@site/src/components/ComparisonTable';

# APIç½‘å…³è¯¦è§£

APIç½‘å…³æ˜¯å¾®æœåŠ¡æ¶æ„ä¸­çš„é‡è¦ç»„ä»¶ï¼Œä½œä¸ºç³»ç»Ÿçš„ç»Ÿä¸€å…¥å£ï¼Œè´Ÿè´£è¯·æ±‚è·¯ç”±ã€è´Ÿè½½å‡è¡¡ã€è®¤è¯æˆæƒã€é™æµç†”æ–­ç­‰åŠŸèƒ½ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**APIç½‘å…³ = ç»Ÿä¸€å…¥å£ + æœåŠ¡æ²»ç† + å®‰å…¨æ§åˆ¶ + æ€§èƒ½ä¼˜åŒ–**
- ğŸŒ **ç»Ÿä¸€å…¥å£**ï¼šä¸ºæ‰€æœ‰å¾®æœåŠ¡æä¾›ç»Ÿä¸€çš„è®¿é—®å…¥å£
- ğŸ”’ **å®‰å…¨æ§åˆ¶**ï¼šé›†ä¸­å¤„ç†è®¤è¯ã€æˆæƒã€åŠ å¯†ç­‰å®‰å…¨åŠŸèƒ½
- âš¡ **æ€§èƒ½ä¼˜åŒ–**ï¼šè´Ÿè½½å‡è¡¡ã€ç¼“å­˜ã€å‹ç¼©ç­‰æ€§èƒ½ä¼˜åŒ–
- ğŸ›¡ï¸ **æœåŠ¡æ²»ç†**ï¼šé™æµã€ç†”æ–­ã€ç›‘æ§ã€æ—¥å¿—ç­‰æ²»ç†åŠŸèƒ½
:::

## 1. APIç½‘å…³æ ¸å¿ƒåŠŸèƒ½

### 1.1 è¯·æ±‚è·¯ç”±

APIç½‘å…³æ ¹æ®è¯·æ±‚çš„URLã€å¤´éƒ¨ä¿¡æ¯ç­‰å°†è¯·æ±‚è·¯ç”±åˆ°ç›¸åº”çš„åç«¯æœåŠ¡ã€‚

```java title="Spring Cloud Gatewayè·¯ç”±é…ç½®"
@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            // ç”¨æˆ·æœåŠ¡è·¯ç”±
            .route("user-service", r -> r
                .path("/api/users/**")
                .uri("lb://user-service"))
            
            // è®¢å•æœåŠ¡è·¯ç”±
            .route("order-service", r -> r
                .path("/api/orders/**")
                .uri("lb://order-service"))
            
            // æ”¯ä»˜æœåŠ¡è·¯ç”±
            .route("payment-service", r -> r
                .path("/api/payments/**")
                .uri("lb://payment-service"))
            
            .build();
    }
}
```

### 1.2 è´Ÿè½½å‡è¡¡

APIç½‘å…³å¯ä»¥åœ¨å¤šä¸ªæœåŠ¡å®ä¾‹ä¹‹é—´åˆ†å‘è¯·æ±‚ï¼Œæé«˜ç³»ç»Ÿçš„å¯ç”¨æ€§å’Œæ€§èƒ½ã€‚

```java title="è´Ÿè½½å‡è¡¡é…ç½®"
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    // è‡ªå®šä¹‰è´Ÿè½½å‡è¡¡ç­–ç•¥
    @Bean
    public ReactorLoadBalancer<ServiceInstance> userServiceLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new RoundRobinLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name);
    }
}
```

### 1.3 è®¤è¯æˆæƒ

APIç½‘å…³å¯ä»¥é›†ä¸­å¤„ç†è®¤è¯å’Œæˆæƒé€»è¾‘ï¼Œç¡®ä¿åªæœ‰åˆæ³•ç”¨æˆ·æ‰èƒ½è®¿é—®ç³»ç»Ÿã€‚

```java title="JWTè®¤è¯è¿‡æ»¤å™¨"
@Component
public class JwtAuthenticationFilter implements GlobalFilter, Ordered {
    
    private final JwtTokenProvider jwtTokenProvider;
    
    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // è·³è¿‡ä¸éœ€è¦è®¤è¯çš„è·¯å¾„
        if (isPublicPath(request.getPath().value())) {
            return chain.filter(exchange);
        }
        
        // è·å–Authorizationå¤´
        String authHeader = request.getHeaders().getFirst("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return handleUnauthorized(exchange);
        }
        
        String token = authHeader.substring(7);
        
        try {
            // éªŒè¯JWT token
            if (jwtTokenProvider.validateToken(token)) {
                // æå–ç”¨æˆ·ä¿¡æ¯å¹¶æ·»åŠ åˆ°è¯·æ±‚å¤´
                String userId = jwtTokenProvider.getUserIdFromToken(token);
                String userRole = jwtTokenProvider.getUserRoleFromToken(token);
                
                ServerHttpRequest modifiedRequest = request.mutate()
                    .header("X-User-Id", userId)
                    .header("X-User-Role", userRole)
                    .build();
                
                return chain.filter(exchange.mutate().request(modifiedRequest).build());
            } else {
                return handleUnauthorized(exchange);
            }
        } catch (Exception e) {
            return handleUnauthorized(exchange);
        }
    }
    
    private boolean isPublicPath(String path) {
        return path.startsWith("/api/auth/") || 
               path.startsWith("/api/public/") ||
               path.equals("/health");
    }
    
    private Mono<Void> handleUnauthorized(ServerWebExchange exchange) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.UNAUTHORIZED);
        response.getHeaders().add("Content-Type", "application/json");
        
        String body = "{\"error\":\"Unauthorized\",\"message\":\"Invalid or missing token\"}";
        DataBuffer buffer = response.bufferFactory().wrap(body.getBytes());
        return response.writeWith(Mono.just(buffer));
    }
    
    @Override
    public int getOrder() {
        return -100; // é«˜ä¼˜å…ˆçº§ï¼Œåœ¨å…¶ä»–è¿‡æ»¤å™¨ä¹‹å‰æ‰§è¡Œ
    }
}
```

## 2. é™æµä¸ç†”æ–­

### 2.1 é™æµå®ç°

```java title="Redisé™æµè¿‡æ»¤å™¨"
@Component
public class RateLimitFilter implements GlobalFilter, Ordered {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final RedisScript<Long> rateLimitScript;
    
    public RateLimitFilter(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
        this.rateLimitScript = createRateLimitScript();
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String clientId = getClientId(request);
        String path = request.getPath().value();
        
        // æ„å»ºé™æµkey
        String rateLimitKey = "rate_limit:" + clientId + ":" + path;
        
        // æ‰§è¡Œé™æµæ£€æŸ¥
        Long currentRequests = redisTemplate.execute(
            rateLimitScript,
            Collections.singletonList(rateLimitKey),
            "10", // é™åˆ¶ï¼š10æ¬¡/åˆ†é’Ÿ
            "60"  // æ—¶é—´çª—å£ï¼š60ç§’
        );
        
        if (currentRequests != null && currentRequests > 10) {
            return handleRateLimitExceeded(exchange);
        }
        
        return chain.filter(exchange);
    }
    
    private String getClientId(ServerHttpRequest request) {
        // ä¼˜å…ˆä½¿ç”¨API Key
        String apiKey = request.getHeaders().getFirst("X-API-Key");
        if (apiKey != null) {
            return "api_key:" + apiKey;
        }
        
        // ä½¿ç”¨IPåœ°å€ä½œä¸ºfallback
        String clientIp = getClientIp(request);
        return "ip:" + clientIp;
    }
    
    private String getClientIp(ServerHttpRequest request) {
        String xForwardedFor = request.getHeaders().getFirst("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeaders().getFirst("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        
        return request.getRemoteAddress() != null ? 
               request.getRemoteAddress().getAddress().getHostAddress() : "unknown";
    }
    
    private RedisScript<Long> createRateLimitScript() {
        String script = 
            "local key = KEYS[1] " +
            "local limit = tonumber(ARGV[1]) " +
            "local window = tonumber(ARGV[2]) " +
            "local current = redis.call('incr', key) " +
            "if current == 1 then " +
            "    redis.call('expire', key, window) " +
            "end " +
            "return current";
        
        return RedisScript.of(script, Long.class);
    }
    
    private Mono<Void> handleRateLimitExceeded(ServerWebExchange exchange) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        response.getHeaders().add("Content-Type", "application/json");
        
        String body = "{\"error\":\"Rate limit exceeded\",\"message\":\"Too many requests\"}";
        DataBuffer buffer = response.bufferFactory().wrap(body.getBytes());
        return response.writeWith(Mono.just(buffer));
    }
    
    @Override
    public int getOrder() {
        return -50;
    }
}
```

### 2.2 ç†”æ–­å™¨å®ç°

```java title="ç†”æ–­å™¨è¿‡æ»¤å™¨"
@Component
public class CircuitBreakerFilter implements GlobalFilter, Ordered {
    
    private final CircuitBreakerRegistry circuitBreakerRegistry;
    
    public CircuitBreakerFilter(CircuitBreakerRegistry circuitBreakerRegistry) {
        this.circuitBreakerRegistry = circuitBreakerRegistry;
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String serviceName = getServiceName(exchange.getRequest());
        CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(serviceName);
        
        return circuitBreaker.executeSupplier(() -> chain.filter(exchange))
            .onErrorResume(Exception.class, ex -> handleCircuitBreakerOpen(exchange, ex));
    }
    
    private String getServiceName(ServerHttpRequest request) {
        String path = request.getPath().value();
        if (path.startsWith("/api/users")) return "user-service";
        if (path.startsWith("/api/orders")) return "order-service";
        if (path.startsWith("/api/payments")) return "payment-service";
        return "default-service";
    }
    
    private Mono<Void> handleCircuitBreakerOpen(ServerWebExchange exchange, Exception ex) {
        ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(HttpStatus.SERVICE_UNAVAILABLE);
        response.getHeaders().add("Content-Type", "application/json");
        
        String body = "{\"error\":\"Service unavailable\",\"message\":\"Circuit breaker is open\"}";
        DataBuffer buffer = response.bufferFactory().wrap(body.getBytes());
        return response.writeWith(Mono.just(buffer));
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
}
```

## 3. ç›‘æ§ä¸æ—¥å¿—

### 3.1 è¯·æ±‚æ—¥å¿—è®°å½•

```java title="è¯·æ±‚æ—¥å¿—è¿‡æ»¤å™¨"
@Component
@Slf4j
public class RequestLoggingFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        long startTime = System.currentTimeMillis();
        
        // è®°å½•è¯·æ±‚ä¿¡æ¯
        String requestId = UUID.randomUUID().toString();
        exchange.getAttributes().put("requestId", requestId);
        exchange.getAttributes().put("startTime", startTime);
        
        log.info("Request started - ID: {}, Method: {}, Path: {}, Client: {}", 
                requestId, request.getMethod(), request.getPath(), 
                getClientIp(request));
        
        return chain.filter(exchange).then(
            Mono.fromRunnable(() -> {
                long endTime = System.currentTimeMillis();
                long duration = endTime - startTime;
                
                ServerHttpResponse response = exchange.getResponse();
                log.info("Request completed - ID: {}, Status: {}, Duration: {}ms", 
                        requestId, response.getStatusCode(), duration);
            })
        );
    }
    
    private String getClientIp(ServerHttpRequest request) {
        String xForwardedFor = request.getHeaders().getFirst("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddress() != null ? 
               request.getRemoteAddress().getAddress().getHostAddress() : "unknown";
    }
    
    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE;
    }
}
```

## 4. é…ç½®ç®¡ç†

### 4.1 åŠ¨æ€è·¯ç”±é…ç½®

```yaml title="application.yml"
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - StripPrefix=2
            - AddRequestHeader=X-Service-Name, user-service
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                key-resolver: "#{@userKeyResolver}"
        
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - StripPrefix=2
            - AddRequestHeader=X-Service-Name, order-service
            - name: CircuitBreaker
              args:
                name: order-service-cb
                fallbackUri: forward:/fallback/orders
        
        - id: payment-service
          uri: lb://payment-service
          predicates:
            - Path=/api/payments/**
          filters:
            - StripPrefix=2
            - AddRequestHeader=X-Service-Name, payment-service
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,GATEWAY_TIMEOUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2

  # Redisé…ç½®ï¼ˆç”¨äºé™æµï¼‰
  redis:
    host: localhost
    port: 6379
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0

# ç†”æ–­å™¨é…ç½®
resilience4j:
  circuitbreaker:
    instances:
      user-service-cb:
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
        permittedNumberOfCallsInHalfOpenState: 3
      order-service-cb:
        slidingWindowSize: 20
        minimumNumberOfCalls: 10
        failureRateThreshold: 60
        waitDurationInOpenState: 60s
      payment-service-cb:
        slidingWindowSize: 15
        minimumNumberOfCalls: 8
        failureRateThreshold: 40
        waitDurationInOpenState: 45s

# ç›‘æ§é…ç½®
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æ·±å…¥ç†è§£äº†APIç½‘å…³çš„æ ¸å¿ƒæ¦‚å¿µã€å®ç°æ–¹æ¡ˆå’Œæœ€ä½³å®è·µã€‚APIç½‘å…³æ˜¯å¾®æœåŠ¡æ¶æ„çš„é‡è¦åŸºç¡€è®¾æ–½ï¼Œåˆç†ä½¿ç”¨ç½‘å…³å¯ä»¥æ˜¾è‘—æé«˜ç³»ç»Ÿçš„å®‰å…¨æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¦æ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©åˆé€‚çš„ç½‘å…³æ–¹æ¡ˆï¼Œå¹¶æ³¨é‡æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§è¿ç»´ã€‚