---
sidebar_position: 2
title: Java Mapé›†åˆè¯¦è§£
description: å…¨é¢ä»‹ç»Java Mapæ¥å£åŠå…¶å®ç°ç±»ã€æ ¸å¿ƒç‰¹æ€§ã€æ€§èƒ½åˆ†æä¸æœ€ä½³å®è·µ
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Java Map é›†åˆè¯¦è§£

Mapæ˜¯Javaé›†åˆæ¡†æ¶ä¸­ç”¨äºå­˜å‚¨é”®å€¼å¯¹çš„æ•°æ®ç»“æ„ï¼Œå®ƒä¸ç»§æ‰¿è‡ªCollectionæ¥å£ï¼Œæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æ¥å£ã€‚Mapé›†åˆåœ¨Javaå¼€å‘ä¸­åº”ç”¨å¹¿æ³›ï¼Œä»ç®€å•çš„æ•°æ®ç¼“å­˜åˆ°å¤æ‚çš„ä¸šåŠ¡é€»è¾‘å¤„ç†ï¼Œéƒ½ç¦»ä¸å¼€Mapçš„æ”¯æŒã€‚

:::tip æ ¸å¿ƒç‰¹æ€§
**Mapæ¥å£ = é”®å€¼å¯¹å­˜å‚¨ + é”®å”¯ä¸€æ€§ + é«˜æ•ˆæŸ¥æ‰¾ + çµæ´»æ“ä½œ + å¤šç§å®ç°é€‰æ‹©**
- ğŸ”‘ **é”®å€¼å¯¹å­˜å‚¨**ï¼šæ¯ä¸ªå…ƒç´ åŒ…å«é”®(Key)å’Œå€¼(Value)ï¼Œå½¢æˆä¸€å¯¹ä¸€æ˜ å°„å…³ç³»
- ğŸ” **é”®å”¯ä¸€æ€§**ï¼šæ¯ä¸ªé”®åœ¨Mapä¸­åªèƒ½å‡ºç°ä¸€æ¬¡ï¼Œé‡å¤æ·»åŠ ä¼šè¦†ç›–åŸå€¼
- âš¡ **é«˜æ•ˆæŸ¥æ‰¾**ï¼šå¤§å¤šæ•°å®ç°æä¾›O(1)æŸ¥æ‰¾æ€§èƒ½ï¼Œé€‚åˆé¢‘ç¹æ£€ç´¢
- ğŸ› ï¸ **çµæ´»æ“ä½œ**ï¼šæ”¯æŒåŸºäºé”®çš„å¢åˆ æ”¹æŸ¥å’Œé›†åˆè§†å›¾æ“ä½œ
- ğŸ“¦ **ä¸°å¯Œå®ç°**ï¼šHashMapã€TreeMapã€LinkedHashMapç­‰å¤šç§å®ç°æ»¡è¶³ä¸åŒéœ€æ±‚
:::

## 1. Mapæ¥å£åŸºç¡€æ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯Mapæ¥å£ï¼Ÿ

Mapæ¥å£æ˜¯Javaé›†åˆæ¡†æ¶ä¸­çš„æ ¸å¿ƒæ¥å£ï¼Œç”¨äºå­˜å‚¨é”®å€¼å¯¹ï¼ˆkey-value pairï¼‰æ•°æ®ã€‚

```mermaid
classDiagram
    Map <|.. HashMap
    Map <|.. LinkedHashMap
    Map <|.. TreeMap
    Map <|.. WeakHashMap
    Map <|.. IdentityHashMap
    Map <|-- SortedMap
    SortedMap <|-- NavigableMap
    NavigableMap <|.. TreeMap
    HashMap <|-- LinkedHashMap
    Map <|.. ConcurrentHashMap
    
    class Map {
        +put(K, V) V
        +get(Object) V
        +remove(Object) V
        +containsKey(Object) boolean
        +containsValue(Object) boolean
        +keySet() Set~K~
        +values() Collection~V~
        +entrySet() Set~Entry~
    }
    
    class HashMap {
        -table Node[]
        -size int
        -modCount int
        +HashMap()
        +HashMap(int)
        +HashMap(Map)
    }
    
    class LinkedHashMap {
        -head Entry
        -tail Entry
        +LinkedHashMap()
        +LinkedHashMap(int)
        +accessOrder boolean
    }
    
    class TreeMap {
        -root Entry
        -comparator Comparator
        +TreeMap()
        +TreeMap(Comparator)
    }
    
    class NavigableMap {
        +lowerEntry(K) Entry
        +floorEntry(K) Entry
        +ceilingEntry(K) Entry
        +higherEntry(K) Entry
    }
    
    <<interface>> Map
    <<interface>> SortedMap
    <<interface>> NavigableMap
```

Mapé›†åˆå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒç‰¹å¾ï¼š

- **é”®å€¼å¯¹å­˜å‚¨**ï¼šæ¯ä¸ªå…ƒç´ åŒ…å«ä¸€ä¸ªé”®å’Œä¸€ä¸ªå€¼
- **é”®å”¯ä¸€æ€§**ï¼šé”®ä¸èƒ½é‡å¤ï¼Œå€¼å¯ä»¥é‡å¤
- **é«˜æ•ˆæŸ¥æ‰¾**ï¼šåŸºäºé”®çš„å¿«é€ŸæŸ¥æ‰¾ï¼Œæ—¶é—´å¤æ‚åº¦O(1)
- **çµæ´»æ“ä½œ**ï¼šæ”¯æŒå¢åˆ æ”¹æŸ¥ã€æ‰¹é‡æ“ä½œç­‰
- **å¤šç§å®ç°**ï¼šæä¾›å¤šç§å®ç°ç±»æ»¡è¶³ä¸åŒéœ€æ±‚

### 1.2 Mapæ¥å£çš„é‡è¦æ€§

| é‡è¦æ€§ | å…·ä½“ä½“ç° | ä¸šåŠ¡ä»·å€¼ |
|--------|----------|----------|
| **æ•°æ®å…³è”** | å»ºç«‹é”®ä¸å€¼ä¹‹é—´çš„æ˜ å°„å…³ç³» | æ”¯æŒå¤æ‚çš„æ•°æ®å…³è”éœ€æ±‚ |
| **å¿«é€ŸæŸ¥æ‰¾** | åŸºäºé”®çš„O(1)æŸ¥æ‰¾æ€§èƒ½ | æé«˜æ•°æ®æ£€ç´¢æ•ˆç‡ |
| **ç¼“å­˜å®ç°** | å¤©ç„¶é€‚åˆç¼“å­˜æ•°æ®ç»“æ„ | æ”¯æŒå„ç§ç¼“å­˜åœºæ™¯ |
| **é…ç½®ç®¡ç†** | é”®å€¼å¯¹å½¢å¼çš„é…ç½®å­˜å‚¨ | ç®€åŒ–é…ç½®ç®¡ç†é€»è¾‘ |

### 1.3 Mapæ¥å£è®¾è®¡åŸåˆ™

Mapæ¥å£çš„è®¾è®¡éµå¾ªä»¥ä¸‹å‡ ä¸ªæ ¸å¿ƒåŸåˆ™ï¼š

#### é”®å€¼å¯¹åŸåˆ™
æä¾›é”®ä¸å€¼ä¹‹é—´çš„æ˜ å°„å…³ç³»ï¼Œæ”¯æŒåŸºäºé”®çš„å¿«é€Ÿè®¿é—®

#### é”®å”¯ä¸€æ€§åŸåˆ™  
ç¡®ä¿é”®çš„å”¯ä¸€æ€§ï¼Œé¿å…æ•°æ®å†²çªå’Œè¦†ç›–

#### é«˜æ•ˆæŸ¥æ‰¾åŸåˆ™
åŸºäºå“ˆå¸Œç®—æ³•å®ç°é«˜æ•ˆçš„æŸ¥æ‰¾å’Œè®¿é—®

#### çµæ´»æ“ä½œåŸåˆ™
æ”¯æŒä¸°å¯Œçš„æ“ä½œæ–¹æ³•ï¼Œæ»¡è¶³å„ç§ä½¿ç”¨åœºæ™¯

```java title="Mapæ¥å£æ ¸å¿ƒæ–¹æ³•ç¤ºä¾‹"
public interface Map<K,V> {
    
    // ========== åŸºæœ¬æ“ä½œ ==========
    V put(K key, V value);                    // æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹
    V get(Object key);                        // æ ¹æ®é”®è·å–å€¼
    V remove(Object key);                     // æ ¹æ®é”®åˆ é™¤é”®å€¼å¯¹
    boolean containsKey(Object key);          // æ˜¯å¦åŒ…å«æŒ‡å®šé”®
    boolean containsValue(Object value);      // æ˜¯å¦åŒ…å«æŒ‡å®šå€¼
    
    // ========== é›†åˆæ“ä½œ ==========
    Set<K> keySet();                          // è·å–æ‰€æœ‰é”®çš„é›†åˆ
    Collection<V> values();                   // è·å–æ‰€æœ‰å€¼çš„é›†åˆ
    Set<Map.Entry<K,V>> entrySet();          // è·å–æ‰€æœ‰é”®å€¼å¯¹çš„é›†åˆ
    
    // ========== æ‰¹é‡æ“ä½œ ==========
    void putAll(Map<? extends K,? extends V> m); // æ·»åŠ å¦ä¸€ä¸ªMapçš„æ‰€æœ‰å…ƒç´ 
    void clear();                             // æ¸…ç©ºMap
    
    // ========== æŸ¥è¯¢æ“ä½œ ==========
    int size();                               // è·å–å…ƒç´ ä¸ªæ•°
    boolean isEmpty();                        // åˆ¤æ–­æ˜¯å¦ä¸ºç©º
}
```

### 1.4 Mapæ¥å£æ ¸å¿ƒæ–¹æ³•è¯¦è§£

Mapæ¥å£æä¾›äº†ä¸°å¯Œçš„æ–¹æ³•æ¥æ“ä½œé”®å€¼å¯¹é›†åˆï¼Œè¿™äº›æ–¹æ³•å¯ä»¥åˆ†ä¸ºå‡ ä¸ªä¸»è¦ç±»åˆ«ï¼š

```mermaid
graph TD
    A["Mapæ ¸å¿ƒæ–¹æ³•"] --> B["åŸºæœ¬æ“ä½œ"]
    A --> C["é›†åˆè§†å›¾"]
    A --> D["æ‰¹é‡æ“ä½œ"]
    A --> E["Java8+æ–°å¢"]
    
    B --> B1["put/get"]
    B --> B2["remove"]
    B --> B3["containsKey/Value"]
    
    C --> C1["keySet"]
    C --> C2["values"]
    C --> C3["entrySet"]
    
    D --> D1["putAll"]
    D --> D2["clear"]
    
    E --> E1["compute"]
    E --> E2["merge"]
    E --> E3["forEach"]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B,C,D,E fill:#bbf,stroke:#333,stroke-width:1px
```

<Tabs>
<TabItem value="basic" label="åŸºæœ¬æ“ä½œæ–¹æ³•">

```java title="MapåŸºæœ¬æ“ä½œæ–¹æ³•"
public interface Map<K,V> {
    
    // æ·»åŠ å’Œæ›´æ–°
    V put(K key, V value);                    // æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹
    V putIfAbsent(K key, V value);            // å¦‚æœé”®ä¸å­˜åœ¨åˆ™æ·»åŠ 
    
    // è·å–å’ŒæŸ¥æ‰¾
    V get(Object key);                        // æ ¹æ®é”®è·å–å€¼
    V getOrDefault(Object key, V defaultValue); // è·å–å€¼ï¼Œä¸å­˜åœ¨è¿”å›é»˜è®¤å€¼
    boolean containsKey(Object key);          // æ˜¯å¦åŒ…å«æŒ‡å®šé”®
    boolean containsValue(Object value);      // æ˜¯å¦åŒ…å«æŒ‡å®šå€¼
    
    // åˆ é™¤æ“ä½œ
    V remove(Object key);                     // æ ¹æ®é”®åˆ é™¤é”®å€¼å¯¹
    boolean remove(Object key, Object value); // æ ¹æ®é”®å€¼å¯¹åˆ é™¤
}
```

| æ–¹æ³• | æè¿° | è¿”å›å€¼ | ç‰¹æ®Šè¡Œä¸º |
|------|------|--------|----------|
| `put(K,V)` | æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹ | åŸå€¼æˆ–null | é”®å·²å­˜åœ¨æ—¶ä¼šè¦†ç›–åŸå€¼ |
| `get(Object)` | è·å–æŒ‡å®šé”®çš„å€¼ | å€¼æˆ–null | é”®ä¸å­˜åœ¨è¿”å›null |
| `remove(Object)` | åˆ é™¤é”®å€¼å¯¹ | è¢«åˆ é™¤çš„å€¼æˆ–null | é”®ä¸å­˜åœ¨è¿”å›null |
| `containsKey(Object)` | æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨ | boolean | HashMapä¸ºO(1)ï¼ŒTreeMapä¸ºO(log n) |
| `containsValue(Object)` | æ£€æŸ¥å€¼æ˜¯å¦å­˜åœ¨ | boolean | éå†å…¨éƒ¨å…ƒç´ ï¼Œæ€§èƒ½è¾ƒå·®O(n) |

</TabItem>
<TabItem value="view" label="é›†åˆè§†å›¾æ–¹æ³•">
```java title="Mapé›†åˆè§†å›¾æ–¹æ³•"
public interface Map<K,V> {
    
    // é”®é›†åˆè§†å›¾
    Set<K> keySet();                          // è·å–æ‰€æœ‰é”®çš„Setè§†å›¾
    NavigableSet<K> navigableKeySet();        // è·å–å¯å¯¼èˆªçš„é”®Setè§†å›¾ï¼ˆSortedMapï¼‰
    
    // å€¼é›†åˆè§†å›¾
    Collection<V> values();                   // è·å–æ‰€æœ‰å€¼çš„Collectionè§†å›¾
    
    // é”®å€¼å¯¹é›†åˆè§†å›¾
    Set<Map.Entry<K,V>> entrySet();          // è·å–æ‰€æœ‰é”®å€¼å¯¹çš„Setè§†å›¾
}
```
    
| æ–¹æ³• | æè¿° | è¿”å›è§†å›¾ç‰¹æ€§ | åº”ç”¨åœºæ™¯ |
|------|------|------------|----------|
| `keySet()` | è·å–æ‰€æœ‰é”®çš„Set | é”®é›†åˆï¼Œä¸åŸMapåŒæ­¥ | éœ€è¦éå†æˆ–æ“ä½œæ‰€æœ‰é”®æ—¶ |
| `values()` | è·å–æ‰€æœ‰å€¼çš„é›†åˆ | å€¼é›†åˆï¼Œä¸åŸMapåŒæ­¥ | éœ€è¦éå†æˆ–è®¿é—®æ‰€æœ‰å€¼æ—¶ |
| `entrySet()` | è·å–æ‰€æœ‰é”®å€¼å¯¹ | Entryé›†åˆï¼Œä¸åŸMapåŒæ­¥ | åŒæ—¶éœ€è¦é”®å’Œå€¼ï¼Œæ•ˆç‡æœ€é«˜ |

:::info è§†å›¾æ“ä½œç‰¹æ€§
Mapè¿”å›çš„é›†åˆè§†å›¾å…·æœ‰ä»¥ä¸‹ç‰¹æ€§ï¼š
- è§†å›¾æ˜¯**åŠ¨æ€çš„**ï¼Œå¯¹è§†å›¾çš„ä¿®æ”¹ä¼šåæ˜ åˆ°åŸMapï¼Œåä¹‹äº¦ç„¶
- é€šè¿‡è§†å›¾çš„`remove()`æ–¹æ³•å¯ä»¥åˆ é™¤Mapä¸­çš„å…ƒç´ 
- ä¸å…è®¸é€šè¿‡é”®é›†è§†å›¾æ·»åŠ å…ƒç´ ï¼ˆä¼šæŠ›å‡º`UnsupportedOperationException`ï¼‰
- è§†å›¾å¯¹è±¡ä¸éœ€è¦é¢å¤–å†…å­˜ï¼Œå®ƒä»¬å¼•ç”¨çš„æ˜¯åŒä¸€ä¸ªåº•å±‚æ•°æ®ç»“æ„
:::

```java title="è§†å›¾æ“ä½œç¤ºä¾‹"
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

// ä½¿ç”¨keySetéå†
for (String key : map.keySet()) {
    System.out.println(key);  // è¾“å‡º: A, B
}

// ä½¿ç”¨valueséå†
for (Integer value : map.values()) {
    System.out.println(value);  // è¾“å‡º: 1, 2
}

// ä½¿ç”¨entrySetéå† (æœ€é«˜æ•ˆ)
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

</TabItem>
<TabItem value="batch" label="æ‰¹é‡æ“ä½œæ–¹æ³•">
```java title="Mapæ‰¹é‡æ“ä½œæ–¹æ³•"
public interface Map<K,V> {
    
    // æ‰¹é‡æ·»åŠ 
    void putAll(Map<? extends K,? extends V> m); // æ·»åŠ å¦ä¸€ä¸ªMapçš„æ‰€æœ‰å…ƒç´ 
    
    // æ‰¹é‡åˆ é™¤
    void clear();                             // æ¸…ç©ºMap
    
    // æ¡ä»¶æ“ä½œ
    V replace(K key, V value);                // æ›¿æ¢æŒ‡å®šé”®çš„å€¼
    boolean replace(K key, V oldValue, V newValue); // æ¡ä»¶æ›¿æ¢
    void replaceAll(BiFunction<? super K,? super V,? extends V> function); // æ‰¹é‡æ›¿æ¢
}
```

| æ–¹æ³• | æè¿° | è¿”å›å€¼ | æ€§èƒ½ç‰¹å¾ |
|------|------|--------|----------|
| `putAll(Map)` | æ‰¹é‡æ·»åŠ é”®å€¼å¯¹ | void | æ—¶é—´å¤æ‚åº¦O(n) |
| `clear()` | æ¸…ç©ºæ‰€æœ‰é”®å€¼å¯¹ | void | æ—¶é—´å¤æ‚åº¦O(n) |
| `replace(K,V)` | æ›¿æ¢æŒ‡å®šé”®çš„å€¼ | åŸå€¼æˆ–null | é”®ä¸å­˜åœ¨æ—¶ä¸æ“ä½œ |

</TabItem>
<TabItem value="java8" label="Java 8+ æ–°å¢æ–¹æ³•">
```java title="MapåŸå­æ“ä½œæ–¹æ³•"
public interface Map<K,V> {
    
    // Java 8+ æ–°å¢æ–¹æ³•
    default V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) {
        // å¦‚æœé”®ä¸å­˜åœ¨ï¼Œåˆ™è®¡ç®—å€¼å¹¶æ’å…¥
    }
    
    default V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) {
        // å¦‚æœé”®å­˜åœ¨ï¼Œåˆ™é‡æ–°è®¡ç®—å€¼
    }
    
    default V compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) {
        // è®¡ç®—æ–°å€¼ï¼ˆæ— è®ºé”®æ˜¯å¦å­˜åœ¨ï¼‰
    }
    
    default V merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) {
        // åˆå¹¶ç°æœ‰å€¼ä¸ç»™å®šå€¼
    }
    
    default void forEach(BiConsumer<? super K,? super V> action) {
        // å¯¹æ¯ä¸ªé”®å€¼å¯¹æ‰§è¡Œæ“ä½œ
    }
}
```

| æ–¹æ³• | æè¿° | ä½¿ç”¨åœºæ™¯ | ä¼˜åŠ¿ |
|------|------|----------|------|
| `computeIfAbsent` | é”®ä¸å­˜åœ¨æ—¶æ‰è®¡ç®—å¹¶æ’å…¥ | ç¼“å­˜å®ç° | é¿å…é‡å¤è®¡ç®— |
| `compute` | é‡æ–°è®¡ç®—é”®çš„å€¼ | å€¼ä¾èµ–äºé”®å’Œæ—§å€¼ | åŸå­æ›´æ–° |
| `merge` | åˆå¹¶ç°æœ‰å€¼å’Œæ–°å€¼ | ç´¯ç§¯ç»Ÿè®¡ | åŸå­æ›´æ–° |
| `forEach` | éå†æ‰€æœ‰é”®å€¼å¯¹ | æ‰¹é‡å¤„ç† | ç®€æ´è¯­æ³• |

```java title="Java 8 Mapæ–¹æ³•ç¤ºä¾‹"
Map<String, Integer> scores = new HashMap<>();

// computeIfAbsentç¤ºä¾‹
scores.computeIfAbsent("Alice", key -> calculateScore(key));  // é”®ä¸å­˜åœ¨æ—¶æ‰è®¡ç®—

// è®¡æ•°å™¨ç¤ºä¾‹
Map<String, Integer> wordCounts = new HashMap<>();
String[] words = {"apple", "banana", "apple", "orange", "banana", "apple"};

for (String word : words) {
    wordCounts.merge(word, 1, (oldValue, value) -> oldValue + value);
}

// ç»“æœ: {orange=1, banana=2, apple=3}
```

</TabItem>
</Tabs>

### 1.5 Mapæ¥å£æ–¹æ³•åˆ†ç±»å¯¹æ¯”

| æ–¹æ³•ç±»åˆ« | ä¸»è¦æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ä½¿ç”¨åœºæ™¯ |
|----------|----------|------------|----------|
| **åŸºæœ¬æ“ä½œ** | put(K,V), get(K), remove(K) | O(1) - O(log n) | æ—¥å¸¸çš„å¢åˆ æ”¹æŸ¥æ“ä½œ |
| **æŸ¥æ‰¾æ“ä½œ** | containsKey(K), containsValue(V) | O(1) - O(n) | é”®å€¼å­˜åœ¨æ€§æ£€æŸ¥ |
| **é›†åˆè§†å›¾** | keySet(), values(), entrySet() | O(1) | éå†å’Œæ‰¹é‡æ“ä½œ |
| **æ‰¹é‡æ“ä½œ** | putAll(Map), clear() | O(n) | æ‰¹é‡æ•°æ®å¤„ç† |

:::tip æ€§èƒ½è€ƒè™‘
- åŸºæœ¬æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å–å†³äºå…·ä½“å®ç°ç±»
- HashMapçš„æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ä¸ºO(1)
- TreeMapçš„æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ä¸ºO(log n)
- é€‰æ‹©å®ç°ç±»æ—¶åº”æ ¹æ®æ€§èƒ½è¦æ±‚å’Œä½¿ç”¨åœºæ™¯
::: 

## 2. Map å®ç°ç±»è¯¦è§£

```mermaid
graph TD
    subgraph æ€§èƒ½æ¯”è¾ƒ
        A["Mapå®ç°ç±»"] --> B["HashMap (æŸ¥æ‰¾å¿«)"]
        A --> C["LinkedHashMap (ä¿æŒé¡ºåº)"]
        A --> D["TreeMap (æœ‰åº)"]
        A --> E["ConcurrentHashMap (çº¿ç¨‹å®‰å…¨)"]
    end
    
    subgraph æ—¶é—´å¤æ‚åº¦
        B --> B1["æŸ¥æ‰¾/æ·»åŠ /åˆ é™¤: O(1)"]
        B --> B2["æ— åº"]
        
        C --> C1["æŸ¥æ‰¾/æ·»åŠ /åˆ é™¤: O(1)"]
        C --> C2["ä¿æŒæ’å…¥é¡ºåº"]
        
        D --> D1["æŸ¥æ‰¾/æ·»åŠ /åˆ é™¤: O(log n)"]
        D --> D2["è‡ªç„¶æ’åºæˆ–æ¯”è¾ƒå™¨æ’åº"]
        
        E --> E1["æŸ¥æ‰¾/æ·»åŠ /åˆ é™¤: O(1)"]
        E --> E2["åˆ†æ®µé”æˆ–CASä¿è¯å¹¶å‘å®‰å…¨"]
    end
    
    classDef default fill:#f9f9f9,stroke:#333,stroke-width:1px;
    classDef fast fill:#d1f0d1,stroke:#333,stroke-width:1px;
    classDef slow fill:#f0d1d1,stroke:#333,stroke-width:1px;
    
    class B1,C1,E1 fast;
    class D1 slow;
```

<Tabs>
<TabItem value="hashmap" label="HashMap å®ç°">

### 2.1 HashMap æ¦‚è¿°

:::tip æ ¸å¿ƒç‰¹ç‚¹
HashMapæ˜¯åŸºäºå“ˆå¸Œè¡¨å®ç°çš„Mapï¼Œæ˜¯Javaä¸­æœ€å¸¸ç”¨çš„Mapå®ç°ç±»ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- ğŸ” **å“ˆå¸Œè¡¨å®ç°**ï¼šåŸºäºæ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘çš„æ•°æ®ç»“æ„
- ğŸ”€ **æ— åºæ€§**ï¼šä¸ä¿è¯å…ƒç´ çš„é¡ºåº
- âšª **å…è®¸null**ï¼šå…è®¸nullé”®å’Œnullå€¼
- âš ï¸ **çº¿ç¨‹ä¸å®‰å…¨**ï¼šåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹éœ€è¦å¤–éƒ¨åŒæ­¥
- âš¡ **é«˜æ•ˆæ“ä½œ**ï¼šæŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ€§èƒ½å¥½ï¼Œå¹³å‡O(1)
:::

#### é€‚ç”¨åœºæ™¯
- ä¸€èˆ¬çš„é”®å€¼å¯¹å­˜å‚¨éœ€æ±‚
- éœ€è¦é«˜æ•ˆçš„æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ“ä½œ
- å¯¹å…ƒç´ é¡ºåºæ²¡æœ‰è¦æ±‚
- å•çº¿ç¨‹ç¯å¢ƒæˆ–å·²è¿›è¡Œå¤–éƒ¨åŒæ­¥

### 2.2 HashMap å†…éƒ¨ç»“æ„

HashMapåŸºäºå“ˆå¸Œè¡¨å®ç°ï¼Œå†…éƒ¨ä½¿ç”¨æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘çš„æ•°æ®ç»“æ„ã€‚å½“é“¾è¡¨é•¿åº¦è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œä¼šè½¬æ¢ä¸ºçº¢é»‘æ ‘ä»¥æé«˜æ€§èƒ½ã€‚

#### æ ¸å¿ƒå­—æ®µ

```java title="HashMapæ ¸å¿ƒå­—æ®µ"
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
    
    // é»˜è®¤åˆå§‹å®¹é‡
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
    
    // æœ€å¤§å®¹é‡
    static final int MAXIMUM_CAPACITY = 1 << 30;
    
    // é»˜è®¤è´Ÿè½½å› å­
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    
    // é“¾è¡¨è½¬çº¢é»‘æ ‘çš„é˜ˆå€¼
    static final int TREEIFY_THRESHOLD = 8;
    
    // çº¢é»‘æ ‘è½¬é“¾è¡¨çš„é˜ˆå€¼
    static final int UNTREEIFY_THRESHOLD = 6;
    
    // æœ€å°æ ‘åŒ–å®¹é‡
    static final int MIN_TREEIFY_CAPACITY = 64;
    
    // å“ˆå¸Œè¡¨
    transient Node<K,V>[] table;
    
    // é”®å€¼å¯¹é›†åˆ
    transient Set<Map.Entry<K,V>> entrySet;
    
    // å…ƒç´ ä¸ªæ•°
    transient int size;
    
    // ä¿®æ”¹æ¬¡æ•°
    transient int modCount;
    
    // é˜ˆå€¼
    int threshold;
    
    // è´Ÿè½½å› å­
    final float loadFactor;
}
```

#### æ„é€ æ–¹æ³•

```java title="HashMapæ„é€ æ–¹æ³•"
public class HashMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * æ„é€ ä¸€ä¸ªé»˜è®¤åˆå§‹å®¹é‡(16)å’Œé»˜è®¤è´Ÿè½½å› å­(0.75)çš„ç©ºHashMap
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
    }
    
    /**
     * æ„é€ ä¸€ä¸ªæŒ‡å®šåˆå§‹å®¹é‡çš„ç©ºHashMap
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    /**
     * æ„é€ ä¸€ä¸ªæŒ‡å®šåˆå§‹å®¹é‡å’Œè´Ÿè½½å› å­çš„ç©ºHashMap
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
        
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    
    /**
     * æ„é€ ä¸€ä¸ªåŒ…å«æŒ‡å®šMapå…ƒç´ çš„HashMap
     */
    public HashMap(Map<? extends K, ? extends V> m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
}
```

#### å†…å­˜å¸ƒå±€ç¤ºæ„å›¾

```
HashMap å®ä¾‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ table: Node<K,V>[]                      â”‚
â”‚ â”œâ”€â”€ [0] â†’ Node("key1", "value1")       â”‚
â”‚ â”œâ”€â”€ [1] â†’ Node("key2", "value2") â†’ Node("key10", "value10")
â”‚ â”œâ”€â”€ [2] â†’ null                         â”‚
â”‚ â””â”€â”€ [3] â†’ TreeNode("key3", "value3")   â”‚
â”‚ size: 4                                â”‚
â”‚ threshold: 12                          â”‚
â”‚ loadFactor: 0.75                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 HashMap æ ¸å¿ƒæ–¹æ³•å®ç°

#### 2.3.1 å“ˆå¸Œç®—æ³•

HashMapä½¿ç”¨é«˜æ•ˆçš„å“ˆå¸Œç®—æ³•æ¥è®¡ç®—é”®çš„å“ˆå¸Œå€¼ï¼š

```java title="HashMapå“ˆå¸Œç®—æ³•"
public class HashMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * è®¡ç®—é”®çš„å“ˆå¸Œå€¼
     * ä½¿ç”¨é«˜16ä½å¼‚æˆ–ä½16ä½çš„æ–¹å¼å‡å°‘å†²çª
     */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    
    /**
     * è®¡ç®—æ•°ç»„ç´¢å¼•
     * ä½¿ç”¨ä½è¿ç®—æ›¿ä»£å–æ¨¡è¿ç®—ï¼Œæé«˜æ€§èƒ½
     */
    static int indexFor(int h, int length) {
        return h & (length - 1);
    }
    
    /**
     * è®¡ç®—å¤§äºç­‰äºç»™å®šå®¹é‡çš„æœ€å°2çš„å¹‚
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
}
```

#### 2.3.2 èŠ‚ç‚¹ç»“æ„

HashMapæ”¯æŒä¸¤ç§èŠ‚ç‚¹ç±»å‹ï¼šé“¾è¡¨èŠ‚ç‚¹å’Œçº¢é»‘æ ‘èŠ‚ç‚¹ï¼š

```java title="HashMapèŠ‚ç‚¹ç»“æ„"
public class HashMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * é“¾è¡¨èŠ‚ç‚¹
     */
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
    
    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
    
    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + "=" + value; }
    
    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }
    
    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    
    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
        }
    }
    
    /**
     * çº¢é»‘æ ‘èŠ‚ç‚¹ï¼ˆç»§æ‰¿è‡ªNodeï¼‰
     */
    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // çˆ¶èŠ‚ç‚¹
        TreeNode<K,V> left;    // å·¦å­èŠ‚ç‚¹
        TreeNode<K,V> right;   // å³å­èŠ‚ç‚¹
        TreeNode<K,V> prev;    // å‰é©±èŠ‚ç‚¹
        boolean red;           // é¢œè‰²æ ‡è®°
        
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
    }
}
```

#### 2.3.3 æ·»åŠ å…ƒç´ 

```java title="HashMapæ·»åŠ å…ƒç´ å®ç°"
public class HashMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹
     * æ—¶é—´å¤æ‚åº¦ï¼šå¹³å‡O(1)ï¼Œæœ€åæƒ…å†µO(n)
     */
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    /**
     * æ ¸å¿ƒæ·»åŠ æ–¹æ³•
     */
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        
        // å¦‚æœè¡¨ä¸ºç©ºæˆ–é•¿åº¦ä¸º0ï¼Œè¿›è¡Œåˆå§‹åŒ–
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        
        // è®¡ç®—ç´¢å¼•ä½ç½®
        if ((p = tab[i = (n - 1) & hash]) == null)
            // å¦‚æœè¯¥ä½ç½®ä¸ºç©ºï¼Œç›´æ¥åˆ›å»ºæ–°èŠ‚ç‚¹
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                // å¦‚æœé”®ç›¸åŒï¼Œæ›´æ–°å€¼
                e = p;
            else if (p instanceof TreeNode)
                // å¦‚æœæ˜¯çº¢é»‘æ ‘èŠ‚ç‚¹ï¼Œåœ¨æ ‘ä¸­æ’å…¥
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                // åœ¨é“¾è¡¨ä¸­æŸ¥æ‰¾æˆ–æ’å…¥
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1)
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            
            if (e != null) { // å¦‚æœæ‰¾åˆ°äº†ç›¸åŒçš„é”®
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
}
```

#### 2.3.4 æ‰©å®¹æœºåˆ¶

å½“HashMapçš„å…ƒç´ ä¸ªæ•°è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œä¼šè‡ªåŠ¨æ‰©å®¹ï¼š

```java title="HashMapæ‰©å®¹æœºåˆ¶"
public class HashMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * æ‰©å®¹æ–¹æ³•
     */
    final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // åŒå€æ‰©å®¹
        }
        else if (oldThr > 0)
            newCap = oldThr;
        else {
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        
        if (oldTab != null) {
            // é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else {
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
}
```

:::tip æ‰©å®¹ç­–ç•¥
- é»˜è®¤åˆå§‹å®¹é‡ï¼š16
- æ‰©å®¹è§¦å‘ï¼šå½“å…ƒç´ ä¸ªæ•°è¶…è¿‡thresholdæ—¶
- æ‰©å®¹å€æ•°ï¼š2å€ï¼ˆnewCap = oldCap \<\< 1ï¼‰
- é˜ˆå€¼è®¡ç®—ï¼šthreshold = capacity * loadFactor
- æ‰©å®¹å¼€é”€ï¼šéœ€è¦é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ ï¼Œå¼€é”€è¾ƒå¤§
:::

### 2.4 HashMap æ€§èƒ½åˆ†æ

#### 2.4.1 æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------|
| **æŸ¥æ‰¾** | å¹³å‡O(1) | åŸºäºå“ˆå¸Œå€¼ç›´æ¥å®šä½ |
| **æ’å…¥** | å¹³å‡O(1) | ç›´æ¥æ’å…¥æˆ–æ›´æ–° |
| **åˆ é™¤** | å¹³å‡O(1) | ç›´æ¥åˆ é™¤èŠ‚ç‚¹ |
| **éå†** | O(n) | éœ€è¦éå†æ‰€æœ‰å…ƒç´  |

#### 2.4.2 ç©ºé—´å¤æ‚åº¦

- **å­˜å‚¨å¼€é”€**ï¼šæ¯ä¸ªé”®å€¼å¯¹éœ€è¦ä¸€ä¸ªNodeå¯¹è±¡
- **æ•°ç»„å¼€é”€**ï¼šå“ˆå¸Œè¡¨æ•°ç»„çš„ç©ºé—´å¼€é”€
- **é“¾è¡¨å¼€é”€**ï¼šå†²çªæ—¶é“¾è¡¨çš„é¢å¤–ç©ºé—´
- **çº¢é»‘æ ‘å¼€é”€**ï¼šæ ‘åŒ–æ—¶çš„é¢å¤–ç©ºé—´

#### 2.4.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

```java title="HashMapæ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹"
public class HashMapOptimization {
    
    public static void main(String[] args) {
        // 1. é¢„åˆ†é…å®¹é‡ï¼Œé¿å…é¢‘ç¹æ‰©å®¹
        Map<String, Integer> map1 = new HashMap<>(1000);
        
        // 2. é€‰æ‹©åˆé€‚çš„è´Ÿè½½å› å­
        Map<String, Integer> map2 = new HashMap<>(16, 0.5f); // é™ä½è´Ÿè½½å› å­
        
        // 3. ä½¿ç”¨åˆé€‚çš„é”®ç±»å‹
        Map<String, Integer> goodKeys = new HashMap<>(); // æ¨èï¼šä¸å¯å˜å¯¹è±¡
        // Map<StringBuilder, Integer> badKeys = new HashMap<>(); // ä¸æ¨èï¼šå¯å˜å¯¹è±¡
        
        // 4. æ‰¹é‡æ“ä½œ
        Map<String, Integer> sourceMap = new HashMap<>();
        sourceMap.put("A", 1);
        sourceMap.put("B", 2);
        
        Map<String, Integer> targetMap = new HashMap<>();
        targetMap.putAll(sourceMap); // æ‰¹é‡æ·»åŠ 
        
        // 5. ä½¿ç”¨getOrDefaulté¿å…nullæ£€æŸ¥
        Integer value = targetMap.getOrDefault("C", 0);
        
        // 6. ä½¿ç”¨computeIfAbsentå»¶è¿Ÿåˆå§‹åŒ–
        targetMap.computeIfAbsent("D", k -> expensiveOperation(k));
    }
    
    private static Integer expensiveOperation(String key) {
        // æ¨¡æ‹Ÿæ˜‚è´µçš„æ“ä½œ
        return key.length() * 10;
    }
}
```

### 2.5 HashMap ä½¿ç”¨ç¤ºä¾‹

#### 2.5.1 åŸºæœ¬æ“ä½œç¤ºä¾‹

```java title="HashMapåŸºæœ¬æ“ä½œç¤ºä¾‹"
public class HashMapBasicExample {
    
    public static void main(String[] args) {
        // åˆ›å»ºHashMap
        Map<String, Integer> map = new HashMap<>();
        
        // æ·»åŠ å…ƒç´ 
        map.put("Java", 1);
        map.put("Python", 2);
        map.put("C++", 3);
        
        // è·å–å…ƒç´ 
        Integer value = map.get("Java");
        System.out.println("Javaçš„å€¼: " + value);
        
        // æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
        boolean containsKey = map.containsKey("Java");
        System.out.println("æ˜¯å¦åŒ…å«Java: " + containsKey);
        
        // æ£€æŸ¥å€¼æ˜¯å¦å­˜åœ¨
        boolean containsValue = map.containsValue(2);
        System.out.println("æ˜¯å¦åŒ…å«å€¼2: " + containsValue);
        
        // åˆ é™¤å…ƒç´ 
        map.remove("C++");
        
        // éå†é”®å€¼å¯¹
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // éå†é”®
        for (String key : map.keySet()) {
            System.out.println("é”®: " + key);
        }
        
        // éå†å€¼
        for (Integer val : map.values()) {
            System.out.println("å€¼: " + val);
        }
    }
}
```

#### 2.5.2 é«˜çº§æ“ä½œç¤ºä¾‹

```java title="HashMapé«˜çº§æ“ä½œç¤ºä¾‹"
public class HashMapAdvancedExample {
    
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        
        // æ‰¹é‡æ·»åŠ 
        map.putAll(Map.of("A", 1, "B", 2, "C", 3));
        
        // æ¡ä»¶æ“ä½œ
        map.putIfAbsent("A", 10); // å¦‚æœé”®ä¸å­˜åœ¨åˆ™æ·»åŠ 
        map.replace("B", 2, 20);  // æ¡ä»¶æ›¿æ¢
        map.remove("C", 3);       // æ¡ä»¶åˆ é™¤
        
        // è®¡ç®—æ“ä½œ
        map.compute("D", (k, v) -> (v == null) ? 1 : v + 1);
        map.computeIfAbsent("E", k -> k.length());
        map.computeIfPresent("A", (k, v) -> v * 2);
        
        // åˆå¹¶æ“ä½œ
        map.merge("F", 1, (oldValue, newValue) -> oldValue + newValue);
        
        // æ‰¹é‡æ›¿æ¢
        map.replaceAll((k, v) -> v * 10);
        
        System.out.println("æ“ä½œåçš„Map: " + map);
    }
} 

</TabItem>
<TabItem value="linkedhashmap" label="LinkedHashMap å®ç°">

### 3.1 LinkedHashMap æ¦‚è¿°

:::tip æ ¸å¿ƒç‰¹ç‚¹
LinkedHashMapæ˜¯HashMapçš„å­ç±»ï¼Œå®ƒåœ¨HashMapçš„åŸºç¡€ä¸Šç»´æŠ¤äº†ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- ğŸ”„ **ç»§æ‰¿HashMap**ï¼šæ‹¥æœ‰HashMapçš„æ‰€æœ‰ç‰¹æ€§
- ğŸ“ **ç»´æŠ¤é¡ºåº**ï¼šç»´æŠ¤æ’å…¥é¡ºåºæˆ–è®¿é—®é¡ºåº
- ğŸ”— **åŒå‘é“¾è¡¨**ï¼šé€šè¿‡åŒå‘é“¾è¡¨ç»´æŠ¤å…ƒç´ é¡ºåº
- ğŸ—„ï¸ **LRUç¼“å­˜**ï¼šå¯ä»¥å®ç°LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ç¼“å­˜
- ğŸ“‰ **æ€§èƒ½ç•¥ä½**ï¼šç›¸æ¯”HashMapæœ‰è½»å¾®çš„æ€§èƒ½å¼€é”€
:::

#### é€‚ç”¨åœºæ™¯
- éœ€è¦ä¿æŒå…ƒç´ æ’å…¥é¡ºåºçš„åœºæ™¯
- éœ€è¦å®ç°LRUç¼“å­˜çš„åœºæ™¯
- éœ€è¦æŒ‰è®¿é—®é¡ºåºæ’åºçš„åœºæ™¯
- å¯¹é¡ºåºæœ‰è¦æ±‚ä½†ä¸éœ€è¦æ’åºçš„åœºæ™¯

### 3.2 LinkedHashMap å†…éƒ¨ç»“æ„

LinkedHashMapåœ¨HashMapçš„åŸºç¡€ä¸Šå¢åŠ äº†åŒå‘é“¾è¡¨æ¥ç»´æŠ¤å…ƒç´ é¡ºåºï¼š

```java title="LinkedHashMapæ ¸å¿ƒå­—æ®µ"
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {
    
    // åŒå‘é“¾è¡¨èŠ‚ç‚¹
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;  // å‰é©±å’Œåç»§èŠ‚ç‚¹
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
    
    // å¤´èŠ‚ç‚¹
    transient LinkedHashMap.Entry<K,V> head;
    
    // å°¾èŠ‚ç‚¹
    transient LinkedHashMap.Entry<K,V> tail;
    
    // æ˜¯å¦æŒ‰è®¿é—®é¡ºåºæ’åº
    final boolean accessOrder;
}
```

#### å†…å­˜å¸ƒå±€ç¤ºæ„å›¾

```
LinkedHashMap å®ä¾‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HashMapéƒ¨åˆ†                              â”‚
â”‚ table: Node<K,V>[]                      â”‚
â”‚ â”œâ”€â”€ [0] â†’ Entry("key1", "value1")      â”‚
â”‚ â”œâ”€â”€ [1] â†’ Entry("key2", "value2")      â”‚
â”‚ â””â”€â”€ [2] â†’ null                         â”‚
â”‚                                         â”‚
â”‚ åŒå‘é“¾è¡¨éƒ¨åˆ†                             â”‚
â”‚ head â†’ Entry1 â†â†’ Entry2 â†â†’ Entry3 â† tailâ”‚
â”‚         â”‚         â”‚         â”‚           â”‚
â”‚      before    before    before        â”‚
â”‚      after     after     after         â”‚
â”‚                                         â”‚
â”‚ accessOrder: false                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 LinkedHashMap æ ¸å¿ƒæ–¹æ³•å®ç°

#### 3.3.1 èŠ‚ç‚¹é“¾æ¥

```java title="LinkedHashMapèŠ‚ç‚¹é“¾æ¥"
public class LinkedHashMap<K,V> extends HashMap<K,V> {
    
    /**
     * åœ¨é“¾è¡¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹
     */
    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
        LinkedHashMap.Entry<K,V> last = tail;
        tail = p;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
    }
    
    /**
     * åœ¨é“¾è¡¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹
     */
    private void linkNodeFirst(LinkedHashMap.Entry<K,V> p) {
        LinkedHashMap.Entry<K,V> first = head;
        head = p;
        if (first == null)
            tail = p;
        else {
            p.after = first;
            first.before = p;
        }
    }
    
    /**
     * ä»é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹
     */
    private void unlinkNode(LinkedHashMap.Entry<K,V> p) {
        LinkedHashMap.Entry<K,V> before = p.before;
        LinkedHashMap.Entry<K,V> after = p.after;
        
        if (before == null)
            head = after;
        else {
            before.after = after;
            p.before = null;
        }
        
        if (after == null)
            tail = before;
        else {
            after.before = before;
            p.after = null;
        }
    }
}
```

#### 3.3.2 è®¿é—®é¡ºåºç»´æŠ¤

```java title="LinkedHashMapè®¿é—®é¡ºåºç»´æŠ¤"
public class LinkedHashMap<K,V> extends HashMap<K,V> {
    
    /**
     * è®¿é—®èŠ‚ç‚¹åçš„å¤„ç†
     */
    void afterNodeAccess(Node<K,V> e) {
        LinkedHashMap.Entry<K,V> last;
        if (accessOrder && (last = tail) != e) {
            LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e;
            LinkedHashMap.Entry<K,V> b = p.before;
            LinkedHashMap.Entry<K,V> a = p.after;
            p.after = null;
            if (b == null)
                head = a;
            else
                b.after = a;
            if (a != null)
                a.before = b;
            else
                last = b;
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }
    
    /**
     * æ’å…¥èŠ‚ç‚¹åçš„å¤„ç†
     */
    void afterNodeInsertion(boolean evict) {
        LinkedHashMap.Entry<K,V> first;
        if (evict && (first = head) != null && removeEldestEntry(first)) {
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }
    
    /**
     * æ˜¯å¦ç§»é™¤æœ€è€çš„èŠ‚ç‚¹ï¼ˆç”¨äºLRUç¼“å­˜ï¼‰
     */
    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
        return false; // é»˜è®¤ä¸ç§»é™¤
    }
}
```

### 3.4 LinkedHashMap ä½¿ç”¨ç¤ºä¾‹

#### 3.4.1 åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹

```java title="LinkedHashMapåŸºæœ¬ä½¿ç”¨ç¤ºä¾‹"
public class LinkedHashMapBasicExample {
    
    public static void main(String[] args) {
        // æŒ‰æ’å…¥é¡ºåºæ’åº
        Map<String, Integer> insertOrderMap = new LinkedHashMap<>();
        insertOrderMap.put("Java", 1);
        insertOrderMap.put("Python", 2);
        insertOrderMap.put("C++", 3);
        
        System.out.println("æŒ‰æ’å…¥é¡ºåº:");
        for (Map.Entry<String, Integer> entry : insertOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // æŒ‰è®¿é—®é¡ºåºæ’åº
        Map<String, Integer> accessOrderMap = new LinkedHashMap<>(16, 0.75f, true);
        accessOrderMap.put("Java", 1);
        accessOrderMap.put("Python", 2);
        accessOrderMap.put("C++", 3);
        
        // è®¿é—®å…ƒç´ ï¼Œä¼šæ”¹å˜é¡ºåº
        accessOrderMap.get("Java");
        accessOrderMap.get("Python");
        
        System.out.println("æŒ‰è®¿é—®é¡ºåº:");
        for (Map.Entry<String, Integer> entry : accessOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

#### 3.4.2 LRUç¼“å­˜å®ç°

```java title="LinkedHashMapå®ç°LRUç¼“å­˜"
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75f, true); // æŒ‰è®¿é—®é¡ºåºæ’åº
        this.capacity = capacity;
    }
    
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity; // è¶…è¿‡å®¹é‡æ—¶ç§»é™¤æœ€è€çš„å…ƒç´ 
    }
    
    public static void main(String[] args) {
        LRUCache<String, Integer> cache = new LRUCache<>(3);
        
        cache.put("A", 1);
        cache.put("B", 2);
        cache.put("C", 3);
        
        System.out.println("åˆå§‹ç¼“å­˜: " + cache);
        
        cache.get("A"); // è®¿é—®Aï¼ŒAå˜ä¸ºæœ€æ–°
        cache.put("D", 4); // æ·»åŠ Dï¼ŒBè¢«ç§»é™¤ï¼ˆæœ€è€çš„ï¼‰
        
        System.out.println("è®¿é—®Aåæ·»åŠ D: " + cache);
    }
}
```

</TabItem>
<TabItem value="treemap" label="TreeMap å®ç°">

### 4.1 TreeMap æ¦‚è¿°

:::tip æ ¸å¿ƒç‰¹ç‚¹
TreeMapæ˜¯åŸºäºçº¢é»‘æ ‘å®ç°çš„Mapï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- ğŸŒ³ **çº¢é»‘æ ‘å®ç°**ï¼šåŸºäºçº¢é»‘æ ‘çš„æœ‰åºæ•°æ®ç»“æ„
- ğŸ“Š **æœ‰åºæ€§**ï¼šæŒ‰é”®çš„è‡ªç„¶é¡ºåºæˆ–è‡ªå®šä¹‰é¡ºåºæ’åº
- â›” **ä¸å…è®¸nullé”®**ï¼šé”®ä¸èƒ½ä¸ºnullï¼Œå€¼å¯ä»¥ä¸ºnull
- âš ï¸ **çº¿ç¨‹ä¸å®‰å…¨**ï¼šåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹éœ€è¦å¤–éƒ¨åŒæ­¥
- ğŸ“ˆ **æ€§èƒ½ç¨³å®š**ï¼šæŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ€§èƒ½ä¸ºO(log n)
:::

</TabItem>
</Tabs>

#### é€‚ç”¨åœºæ™¯
- éœ€è¦æŒ‰é”®æ’åºçš„åœºæ™¯
- éœ€è¦èŒƒå›´æŸ¥è¯¢çš„åœºæ™¯
- éœ€è¦è·å–æœ€å¤§æœ€å°é”®çš„åœºæ™¯
- å¯¹æ€§èƒ½ç¨³å®šæ€§è¦æ±‚è¾ƒé«˜çš„åœºæ™¯

### 4.2 TreeMap å†…éƒ¨ç»“æ„

TreeMapåŸºäºçº¢é»‘æ ‘å®ç°ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«é”®å€¼å¯¹å’Œå·¦å³å­èŠ‚ç‚¹ï¼š

```java title="TreeMapæ ¸å¿ƒå­—æ®µ"
public class TreeMap<K,V> extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable {
    
    // æ¯”è¾ƒå™¨
    private final Comparator<? super K> comparator;
    
    // æ ¹èŠ‚ç‚¹
    private transient Entry<K,V> root;
    
    // å…ƒç´ ä¸ªæ•°
    private transient int size = 0;
    
    // ä¿®æ”¹æ¬¡æ•°
    private transient int modCount = 0;
    
    // çº¢é»‘æ ‘èŠ‚ç‚¹
    static final class Entry<K,V> implements Map.Entry<K,V> {
        K key;
        V value;
        Entry<K,V> left;
        Entry<K,V> right;
        Entry<K,V> parent;
        boolean color = BLACK;
        
        Entry(K key, V value, Entry<K,V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }
    }
}
```

### 4.3 TreeMap æ ¸å¿ƒæ–¹æ³•å®ç°

#### 4.3.1 æŸ¥æ‰¾æ“ä½œ

```java title="TreeMapæŸ¥æ‰¾æ“ä½œ"
public class TreeMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * æ ¹æ®é”®è·å–å€¼
     * æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
     */
    public V get(Object key) {
        Entry<K,V> p = getEntry(key);
        return (p == null ? null : p.value);
    }
    
    /**
     * æŸ¥æ‰¾æŒ‡å®šé”®çš„èŠ‚ç‚¹
     */
    final Entry<K,V> getEntry(Object key) {
        if (comparator != null)
            return getEntryUsingComparator(key);
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
        Entry<K,V> p = root;
        while (p != null) {
            int cmp = k.compareTo(p.key);
            if (cmp < 0)
                p = p.left;
            else if (cmp > 0)
                p = p.right;
            else
                return p;
        }
        return null;
    }
    
    /**
     * ä½¿ç”¨æ¯”è¾ƒå™¨æŸ¥æ‰¾
     */
    final Entry<K,V> getEntryUsingComparator(Object key) {
        @SuppressWarnings("unchecked")
        K k = (K) key;
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            Entry<K,V> p = root;
            while (p != null) {
                int cmp = cpr.compare(k, p.key);
                if (cmp < 0)
                    p = p.left;
                else if (cmp > 0)
                    p = p.right;
                else
                    return p;
            }
        }
        return null;
    }
}
```

#### 4.3.2 æ’å…¥æ“ä½œ

```java title="TreeMapæ’å…¥æ“ä½œ"
public class TreeMap<K,V> extends AbstractMap<K,V> {
    
    /**
     * æ·»åŠ æˆ–æ›´æ–°é”®å€¼å¯¹
     * æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
     */
    public V put(K key, V value) {
        Entry<K,V> t = root;
        if (t == null) {
            compare(key, key); // ç±»å‹æ£€æŸ¥
            root = new Entry<>(key, value, null);
            size = 1;
            modCount++;
            return null;
        }
        int cmp;
        Entry<K,V> parent;
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        } else {
            if (key == null)
                throw new NullPointerException();
            @SuppressWarnings("unchecked")
            Comparable<? super K> k = (Comparable<? super K>) key;
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        Entry<K,V> e = new Entry<>(key, value, parent);
        if (cmp < 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;
        modCount++;
        return null;
    }
}
```

### 4.4 TreeMap ä½¿ç”¨ç¤ºä¾‹

#### 4.4.1 åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹

```java title="TreeMapåŸºæœ¬ä½¿ç”¨ç¤ºä¾‹"
public class TreeMapBasicExample {
    
    public static void main(String[] args) {
        // è‡ªç„¶é¡ºåºæ’åº
        Map<String, Integer> naturalOrderMap = new TreeMap<>();
        naturalOrderMap.put("Java", 1);
        naturalOrderMap.put("Python", 2);
        naturalOrderMap.put("C++", 3);
        
        System.out.println("è‡ªç„¶é¡ºåº:");
        for (Map.Entry<String, Integer> entry : naturalOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // è‡ªå®šä¹‰æ¯”è¾ƒå™¨
        Map<String, Integer> customOrderMap = new TreeMap<>((s1, s2) -> s2.compareTo(s1));
        customOrderMap.put("Java", 1);
        customOrderMap.put("Python", 2);
        customOrderMap.put("C++", 3);
        
        System.out.println("è‡ªå®šä¹‰é¡ºåº:");
        for (Map.Entry<String, Integer> entry : customOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

#### 4.4.2 å¯¼èˆªæ–¹æ³•ç¤ºä¾‹

```java title="TreeMapå¯¼èˆªæ–¹æ³•ç¤ºä¾‹"
public class TreeMapNavigationExample {
    
    public static void main(String[] args) {
        TreeMap<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("A", 1);
        treeMap.put("B", 2);
        treeMap.put("C", 3);
        treeMap.put("D", 4);
        treeMap.put("E", 5);
        
        // è·å–ç¬¬ä¸€ä¸ªå…ƒç´ 
        Map.Entry<String, Integer> first = treeMap.firstEntry();
        System.out.println("ç¬¬ä¸€ä¸ªå…ƒç´ : " + first.getKey() + "=" + first.getValue());
        
        // è·å–æœ€åä¸€ä¸ªå…ƒç´ 
        Map.Entry<String, Integer> last = treeMap.lastEntry();
        System.out.println("æœ€åä¸€ä¸ªå…ƒç´ : " + last.getKey() + "=" + last.getValue());
        
        // è·å–å°äºæŒ‡å®šé”®çš„æœ€å¤§é”®å€¼å¯¹
        Map.Entry<String, Integer> lower = treeMap.lowerEntry("C");
        System.out.println("å°äºCçš„æœ€å¤§å…ƒç´ : " + lower.getKey() + "=" + lower.getValue());
        
        // è·å–å¤§äºæŒ‡å®šé”®çš„æœ€å°é”®å€¼å¯¹
        Map.Entry<String, Integer> higher = treeMap.higherEntry("B");
        System.out.println("å¤§äºBçš„æœ€å°å…ƒç´ : " + higher.getKey() + "=" + higher.getValue());
        
        // èŒƒå›´æŸ¥è¯¢
        SortedMap<String, Integer> subMap = treeMap.subMap("B", "D");
        System.out.println("Båˆ°Dçš„å­Map: " + subMap);
    }
}
```

## 5. ConcurrentHashMap å®ç°ç±»è¯¦è§£

### 5.1 ConcurrentHashMap æ¦‚è¿°

:::tip æ ¸å¿ƒç‰¹ç‚¹
ConcurrentHashMapæ˜¯çº¿ç¨‹å®‰å…¨çš„HashMapå®ç°ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- **çº¿ç¨‹å®‰å…¨**ï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®
- **åˆ†æ®µé”æœºåˆ¶**ï¼šä½¿ç”¨åˆ†æ®µé”å‡å°‘é”ç«äº‰
- **ä¸å…è®¸null**ï¼šé”®å’Œå€¼éƒ½ä¸èƒ½ä¸ºnull
- **é«˜æ€§èƒ½**ï¼šæ€§èƒ½ä¼˜äºHashtableå’ŒCollections.synchronizedMap
- **åŸå­æ“ä½œ**ï¼šæä¾›åŸå­æ“ä½œæ–¹æ³•
:::

#### é€‚ç”¨åœºæ™¯
- å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„Mapæ“ä½œ
- é«˜å¹¶å‘åœºæ™¯ä¸‹çš„ç¼“å­˜å®ç°
- éœ€è¦çº¿ç¨‹å®‰å…¨çš„é”®å€¼å¯¹å­˜å‚¨
- å¯¹æ€§èƒ½è¦æ±‚è¾ƒé«˜çš„å¹¶å‘åº”ç”¨

### 5.2 ConcurrentHashMap å†…éƒ¨ç»“æ„

ConcurrentHashMapä½¿ç”¨åˆ†æ®µé”æœºåˆ¶ï¼Œå°†æ•´ä¸ªMapåˆ†æˆå¤šä¸ªæ®µï¼Œæ¯ä¸ªæ®µä½¿ç”¨ç‹¬ç«‹çš„é”ï¼š

```java title="ConcurrentHashMapæ ¸å¿ƒå­—æ®µ"
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {
    
    // æ®µæ•°ç»„
    final Segment<K,V>[] segments;
    
    // æ®µçš„æ•°é‡
    static final int DEFAULT_CONCURRENCY_LEVEL = 16;
    
    // æ®µç±»
    static final class Segment<K,V> extends ReentrantLock implements Serializable {
        transient volatile HashEntry<K,V>[] table;
        transient int count;
        transient int modCount;
        transient int threshold;
        final float loadFactor;
    }
    
    // å“ˆå¸Œè¡¨èŠ‚ç‚¹
    static final class HashEntry<K,V> {
        final K key;
        final int hash;
        volatile V value;
        final HashEntry<K,V> next;
        
        HashEntry(K key, int hash, HashEntry<K,V> next, V value) {
            this.key = key;
            this.hash = hash;
            this.next = next;
            this.value = value;
        }
    }
}
```

### 5.3 ConcurrentHashMap ä½¿ç”¨ç¤ºä¾‹

#### 5.3.1 åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹

```java title="ConcurrentHashMapåŸºæœ¬ä½¿ç”¨ç¤ºä¾‹"
public class ConcurrentHashMapBasicExample {
    
    public static void main(String[] args) {
        Map<String, Integer> map = new ConcurrentHashMap<>();
        
        // å¤šçº¿ç¨‹å®‰å…¨æ“ä½œ
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                map.put("Thread1-" + i, i);
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                map.put("Thread2-" + i, i);
            }
        });
        
        t1.start();
        t2.start();
        
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("æœ€ç»ˆå¤§å°: " + map.size());
    }
}
```

#### 5.3.2 åŸå­æ“ä½œç¤ºä¾‹

```java title="ConcurrentHashMapåŸå­æ“ä½œç¤ºä¾‹"
public class ConcurrentHashMapAtomicExample {
    
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // åŸå­æ“ä½œ
        map.putIfAbsent("key", 1);  // å¦‚æœé”®ä¸å­˜åœ¨åˆ™æ·»åŠ 
        map.replace("key", 1, 2);   // å¦‚æœå€¼ç­‰äº1åˆ™æ›¿æ¢ä¸º2
        map.remove("key", 2);       // å¦‚æœå€¼ç­‰äº2åˆ™åˆ é™¤
        
        // åŸå­æ›´æ–°
        map.put("counter", 0);
        map.compute("counter", (k, v) -> v + 1);
        map.merge("counter", 1, Integer::sum);
        
        System.out.println("æœ€ç»ˆç»“æœ: " + map);
    }
} 

## 6. å…¶ä»–Mapå®ç°

### 6.1 Hashtable

Hashtableæ˜¯Javaæ—©æœŸæä¾›çš„çº¿ç¨‹å®‰å…¨çš„Mapå®ç°ï¼Œç°åœ¨å·²ç»ä¸æ¨èä½¿ç”¨ï¼š

```java title="Hashtableç¤ºä¾‹"
public class HashtableExample {
    
    public static void main(String[] args) {
        Map<String, Integer> map = new Hashtable<>();
        
        // åŸºæœ¬æ“ä½œ
        map.put("Java", 1);
        map.put("Python", 2);
        
        // ä¸å…è®¸nullé”®å’Œnullå€¼
        // map.put(null, 1);  // æŠ›å‡ºNullPointerException
        // map.put("key", null);  // æŠ›å‡ºNullPointerException
        
        System.out.println(map);
        
        // æ€§èƒ½å¯¹æ¯”
        long start = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            map.put("key" + i, i);
        }
        long end = System.currentTimeMillis();
        System.out.println("Hashtableæ’å…¥100000ä¸ªå…ƒç´ è€—æ—¶: " + (end - start) + "ms");
    }
}
```

### 6.2 WeakHashMap

WeakHashMapä½¿ç”¨å¼±å¼•ç”¨ä½œä¸ºé”®ï¼Œå½“é”®ä¸å†è¢«å¼ºå¼•ç”¨æ—¶ï¼Œå¯¹åº”çš„é”®å€¼å¯¹ä¼šè¢«è‡ªåŠ¨å›æ”¶ï¼š

```java title="WeakHashMapç¤ºä¾‹"
public class WeakHashMapExample {
    
    public static void main(String[] args) {
        Map<String, Integer> map = new WeakHashMap<>();
        
        String key1 = new String("key1");
        String key2 = new String("key2");
        
        map.put(key1, 1);
        map.put(key2, 2);
        
        System.out.println("GCå‰: " + map.size()); // 2
        
        // é‡Šæ”¾å¼ºå¼•ç”¨
        key1 = null;
        key2 = null;
        
        // è§¦å‘GC
        System.gc();
        
        System.out.println("GCå: " + map.size()); // 0
    }
}
```

### 6.3 IdentityHashMap

IdentityHashMapä½¿ç”¨`==`è€Œä¸æ˜¯`equals()`æ¥æ¯”è¾ƒé”®ï¼Œé€‚ç”¨äºéœ€è¦ç²¾ç¡®å¯¹è±¡å¼•ç”¨çš„åœºæ™¯ï¼š

```java title="IdentityHashMapç¤ºä¾‹"
public class IdentityHashMapExample {
    
    public static void main(String[] args) {
        Map<String, Integer> normalMap = new HashMap<>();
        Map<String, Integer> identityMap = new IdentityHashMap<>();
        
        String key1 = new String("key");
        String key2 = new String("key");
        
        // HashMapä½¿ç”¨equals()æ¯”è¾ƒ
        normalMap.put(key1, 1);
        normalMap.put(key2, 2);
        System.out.println("HashMapå¤§å°: " + normalMap.size()); // 1
        
        // IdentityHashMapä½¿ç”¨==æ¯”è¾ƒ
        identityMap.put(key1, 1);
        identityMap.put(key2, 2);
        System.out.println("IdentityHashMapå¤§å°: " + identityMap.size()); // 2
    }
}
```

## 7. å®é™…åº”ç”¨åœºæ™¯

```mermaid
graph TD
    subgraph åº”ç”¨åœºæ™¯
        S1[Mapåº”ç”¨åœºæ™¯] --> D1[æ•°æ®ç¼“å­˜]
        S1 --> C1[é…ç½®ç®¡ç†]
        S1 --> M1[ç´¢å¼•æ˜ å°„]
        S1 --> P1[æ•°æ®ç»Ÿè®¡]
    end
    
    D1 --> D11[æœ¬åœ°ç¼“å­˜]
    D1 --> D12[LRUç¼“å­˜]
    D1 --> D13[ç¼“å­˜å¤±æ•ˆ]
    
    C1 --> C11[ç¨‹åºé…ç½®]
    C1 --> C12[åŠ¨æ€å‚æ•°]
    C1 --> C13[Feature Flag]
    
    M1 --> M11[IDæ˜ å°„]
    M1 --> M12[åå‘ç´¢å¼•]
    M1 --> M13[å¤šçº§ç´¢å¼•]
    
    subgraph å®ç°ç±»é€‰æ‹©
        A[å®ç°ç±»é€‰æ‹©] --> B1[HashMap]
        A --> B2[LinkedHashMap]
        A --> B3[TreeMap]
        A --> B4[ConcurrentHashMap]
        
        B1 --> X1[ä¸€èˆ¬åœºæ™¯]
        B2 --> X2[éœ€è¦è®°ä½é¡ºåº/LRUç¼“å­˜]
        B3 --> X3[éœ€è¦æŒ‰é”®æ’åº]
        B4 --> X4[å¹¶å‘ç¯å¢ƒ]
    end
    
    style S1 fill:#f9f,stroke:#333,stroke-width:2px
    style A fill:#bbf,stroke:#333,stroke-width:1px
```

### 7.1 ç¼“å­˜ç³»ç»Ÿ

```java title="ç¼“å­˜ç³»ç»Ÿç¤ºä¾‹"
public class CacheSystemExample {
    
    /**
     * ç®€å•çš„å†…å­˜ç¼“å­˜å®ç°
     */
    public static class SimpleCache<K, V> {
        private final Map<K, V> cache = new ConcurrentHashMap<>();
        private final Map<K, Long> timestamps = new ConcurrentHashMap<>();
        private final long ttl; // ç”Ÿå­˜æ—¶é—´
        
        public SimpleCache(long ttl) {
            this.ttl = ttl;
        }
        
        public V get(K key) {
            V value = cache.get(key);
            if (value != null) {
                Long timestamp = timestamps.get(key);
                if (timestamp != null && System.currentTimeMillis() - timestamp < ttl) {
                    return value;
                } else {
                    // è¿‡æœŸï¼Œåˆ é™¤
                    cache.remove(key);
                    timestamps.remove(key);
                }
            }
            return null;
        }
        
        public void put(K key, V value) {
            cache.put(key, value);
            timestamps.put(key, System.currentTimeMillis());
        }
        
        public void clear() {
            cache.clear();
            timestamps.clear();
        }
    }
    
    public static void main(String[] args) {
        SimpleCache<String, String> cache = new SimpleCache<>(5000); // 5ç§’TTL
        
        cache.put("user:1", "Alice");
        cache.put("user:2", "Bob");
        
        System.out.println("è·å–ç”¨æˆ·1: " + cache.get("user:1"));
        
        // ç­‰å¾…6ç§’åï¼Œç¼“å­˜è¿‡æœŸ
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("6ç§’åè·å–ç”¨æˆ·1: " + cache.get("user:1")); // null
    }
}
```

### 7.2 é…ç½®ç®¡ç†

```java title="é…ç½®ç®¡ç†ç¤ºä¾‹"
public class ConfigManagementExample {
    
    /**
     * é…ç½®ç®¡ç†å™¨
     */
    public static class ConfigManager {
        private final Map<String, Object> config = new ConcurrentHashMap<>();
        private final Map<String, List<ConfigChangeListener>> listeners = new ConcurrentHashMap<>();
        
        public void setConfig(String key, Object value) {
            Object oldValue = config.put(key, value);
            notifyListeners(key, oldValue, value);
        }
        
        public Object getConfig(String key) {
            return config.get(key);
        }
        
        public <T> T getConfig(String key, Class<T> type) {
            Object value = config.get(key);
            return type.isInstance(value) ? type.cast(value) : null;
        }
        
        public void addListener(String key, ConfigChangeListener listener) {
            listeners.computeIfAbsent(key, k -> new ArrayList<>()).add(listener);
        }
        
        private void notifyListeners(String key, Object oldValue, Object newValue) {
            List<ConfigChangeListener> keyListeners = listeners.get(key);
            if (keyListeners != null) {
                for (ConfigChangeListener listener : keyListeners) {
                    listener.onConfigChange(key, oldValue, newValue);
                }
            }
        }
    }
    
    @FunctionalInterface
    interface ConfigChangeListener {
        void onConfigChange(String key, Object oldValue, Object newValue);
    }
    
    public static void main(String[] args) {
        ConfigManager configManager = new ConfigManager();
        
        // æ·»åŠ é…ç½®å˜æ›´ç›‘å¬å™¨
        configManager.addListener("database.url", (key, oldValue, newValue) -> {
            System.out.println("æ•°æ®åº“URLå˜æ›´: " + oldValue + " -> " + newValue);
        });
        
        // è®¾ç½®é…ç½®
        configManager.setConfig("database.url", "jdbc:mysql://localhost:3306/test");
        configManager.setConfig("database.url", "jdbc:mysql://localhost:3306/prod");
        
        // è·å–é…ç½®
        String dbUrl = configManager.getConfig("database.url", String.class);
        System.out.println("å½“å‰æ•°æ®åº“URL: " + dbUrl);
    }
}
```

### 7.3 æ•°æ®ç»Ÿè®¡

```java title="æ•°æ®ç»Ÿè®¡ç¤ºä¾‹"
public class DataStatisticsExample {
    
    /**
     * ç”¨æˆ·è¡Œä¸ºç»Ÿè®¡
     */
    public static class UserBehaviorStats {
        private final Map<String, Integer> pageViews = new ConcurrentHashMap<>();
        private final Map<String, Set<String>> uniqueUsers = new ConcurrentHashMap<>();
        private final Map<String, List<Long>> accessTimes = new ConcurrentHashMap<>();
        
        public void recordPageView(String page, String userId) {
            // é¡µé¢è®¿é—®æ¬¡æ•°ç»Ÿè®¡
            pageViews.merge(page, 1, Integer::sum);
            
            // ç‹¬ç«‹ç”¨æˆ·ç»Ÿè®¡
            uniqueUsers.computeIfAbsent(page, k -> ConcurrentHashMap.newKeySet()).add(userId);
            
            // è®¿é—®æ—¶é—´è®°å½•
            accessTimes.computeIfAbsent(page, k -> new ArrayList<>()).add(System.currentTimeMillis());
        }
        
        public int getPageViews(String page) {
            return pageViews.getOrDefault(page, 0);
        }
        
        public int getUniqueUsers(String page) {
            Set<String> users = uniqueUsers.get(page);
            return users != null ? users.size() : 0;
        }
        
        public double getAverageAccessTime(String page) {
            List<Long> times = accessTimes.get(page);
            if (times == null || times.isEmpty()) {
                return 0.0;
            }
            return times.stream().mapToLong(Long::longValue).average().orElse(0.0);
        }
        
        public Map<String, Integer> getTopPages(int limit) {
            return pageViews.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .limit(limit)
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    Map.Entry::getValue,
                    (e1, e2) -> e1,
                    LinkedHashMap::new
                ));
        }
    }
    
    public static void main(String[] args) {
        UserBehaviorStats stats = new UserBehaviorStats();
        
        // æ¨¡æ‹Ÿç”¨æˆ·è®¿é—®
        stats.recordPageView("home", "user1");
        stats.recordPageView("home", "user2");
        stats.recordPageView("home", "user1");
        stats.recordPageView("products", "user1");
        stats.recordPageView("products", "user3");
        
        System.out.println("é¦–é¡µè®¿é—®æ¬¡æ•°: " + stats.getPageViews("home"));
        System.out.println("é¦–é¡µç‹¬ç«‹ç”¨æˆ·: " + stats.getUniqueUsers("home"));
        System.out.println("çƒ­é—¨é¡µé¢: " + stats.getTopPages(3));
    }
}
```

## 8. æœ€ä½³å®è·µæ€»ç»“

### 8.1 Mapå®ç°ç±»é€‰æ‹©ç­–ç•¥

:::tip é€‰æ‹©å»ºè®®
é€‰æ‹©åˆé€‚çš„Mapå®ç°ç±»éœ€è¦è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š
- **æ€§èƒ½è¦æ±‚**ï¼šHashMapæ€§èƒ½æœ€å¥½ï¼ŒTreeMapæ€§èƒ½ç¨³å®š
- **é¡ºåºè¦æ±‚**ï¼šéœ€è¦é¡ºåºé€‰æ‹©LinkedHashMapæˆ–TreeMap
- **çº¿ç¨‹å®‰å…¨**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒé€‰æ‹©ConcurrentHashMap
- **å†…å­˜ç®¡ç†**ï¼šç¼“å­˜åœºæ™¯è€ƒè™‘WeakHashMap
- **ç‰¹æ®Šéœ€æ±‚**ï¼šæ ¹æ®å…·ä½“ä¸šåŠ¡éœ€æ±‚é€‰æ‹©
:::

| å®ç°ç±» | é€‚ç”¨åœºæ™¯ | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|--------|----------|------|------|
| **HashMap** | ä¸€èˆ¬ç”¨é€” | æ€§èƒ½æœ€å¥½ã€åŠŸèƒ½å®Œæ•´ | æ— åºã€çº¿ç¨‹ä¸å®‰å…¨ |
| **LinkedHashMap** | éœ€è¦ä¿æŒé¡ºåº | ç»´æŠ¤æ’å…¥/è®¿é—®é¡ºåº | æ€§èƒ½ç•¥ä½äºHashMap |
| **TreeMap** | éœ€è¦æ’åº | æœ‰åºã€æ”¯æŒèŒƒå›´æŸ¥è¯¢ | æ€§èƒ½O(log n) |
| **ConcurrentHashMap** | å¤šçº¿ç¨‹ç¯å¢ƒ | çº¿ç¨‹å®‰å…¨ã€é«˜æ€§èƒ½ | ä¸å…è®¸nullé”®å€¼ |
| **WeakHashMap** | ç¼“å­˜åœºæ™¯ | è‡ªåŠ¨å›æ”¶ã€å†…å­˜å‹å¥½ | é”®å¯èƒ½è¢«å›æ”¶ |
| **Hashtable** | ä¸æ¨èä½¿ç”¨ | çº¿ç¨‹å®‰å…¨ | æ€§èƒ½å·®ã€å·²è¿‡æ—¶ |

### 8.2 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```java title="Mapæ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹"
public class MapPerformanceOptimization {
    
    /**
     * å®¹é‡ä¼˜åŒ–
     */
    public static void capacityOptimization() {
        // é¢„åˆ†é…å®¹é‡ï¼Œé¿å…é¢‘ç¹æ‰©å®¹
        Map<String, Integer> optimizedMap = new HashMap<>(1000);
        
        // é€‰æ‹©åˆé€‚çš„è´Ÿè½½å› å­
        Map<String, Integer> lowLoadFactorMap = new HashMap<>(16, 0.5f);
    }
    
    /**
     * é”®ç±»å‹ä¼˜åŒ–
     */
    public static void keyTypeOptimization() {
        // ä½¿ç”¨ä¸å¯å˜å¯¹è±¡ä½œä¸ºé”®
        Map<String, Integer> goodKeys = new HashMap<>();
        
        // é¿å…ä½¿ç”¨å¯å˜å¯¹è±¡ä½œä¸ºé”®
        // Map<StringBuilder, Integer> badKeys = new HashMap<>();
    }
    
    /**
     * æ‰¹é‡æ“ä½œä¼˜åŒ–
     */
    public static void batchOperationOptimization() {
        Map<String, Integer> sourceMap = new HashMap<>();
        sourceMap.put("A", 1);
        sourceMap.put("B", 2);
        
        Map<String, Integer> targetMap = new HashMap<>();
        targetMap.putAll(sourceMap); // æ‰¹é‡æ·»åŠ 
        
        // æ‰¹é‡åˆ é™¤
        targetMap.keySet().removeAll(Arrays.asList("A", "B"));
    }
    
    /**
     * åŸå­æ“ä½œä¼˜åŒ–
     */
    public static void atomicOperationOptimization() {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // ä½¿ç”¨åŸå­æ“ä½œé¿å…ç«æ€æ¡ä»¶
        map.putIfAbsent("key", 1);
        map.replace("key", 1, 2);
        map.compute("counter", (k, v) -> (v == null) ? 1 : v + 1);
    }
}
```

### 8.3 å¸¸è§é™·é˜±å’Œè§£å†³æ–¹æ¡ˆ

:::caution æ³¨æ„äº‹é¡¹
1. **HashMapçš„çº¿ç¨‹å®‰å…¨é—®é¢˜**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹éœ€è¦å¤–éƒ¨åŒæ­¥
2. **TreeMapçš„nullé”®é™åˆ¶**ï¼šé”®ä¸èƒ½ä¸ºnullï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
3. **ConcurrentHashMapçš„nullé™åˆ¶**ï¼šé”®å’Œå€¼éƒ½ä¸èƒ½ä¸ºnull
4. **WeakHashMapçš„é”®å›æ”¶**ï¼šé”®å¯èƒ½è¢«åƒåœ¾å›æ”¶ï¼Œéœ€è¦è°¨æ…ä½¿ç”¨
:::

```java title="å¸¸è§é™·é˜±ç¤ºä¾‹"
public class MapCommonTraps {
    
    /**
     * çº¿ç¨‹å®‰å…¨é—®é¢˜
     */
    public static void threadSafetyTrap() {
        Map<String, Integer> map = new HashMap<>();
        
        // é”™è¯¯ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ç›´æ¥ä½¿ç”¨HashMap
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                map.put("key" + i, i);
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                map.put("key" + i, i);
            }
        });
        
        // æ­£ç¡®ï¼šä½¿ç”¨ConcurrentHashMap
        Map<String, Integer> safeMap = new ConcurrentHashMap<>();
    }
    
    /**
     * nullå€¼å¤„ç†
     */
    public static void nullValueTrap() {
        // TreeMapä¸å…è®¸nullé”®
        try {
            TreeMap<String, Integer> treeMap = new TreeMap<>();
            treeMap.put(null, 1); // æŠ›å‡ºNullPointerException
        } catch (Exception e) {
            System.out.println("TreeMapä¸å…è®¸nullé”®: " + e.getMessage());
        }
        
        // ConcurrentHashMapä¸å…è®¸nullé”®å’Œnullå€¼
        try {
            ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
            concurrentMap.put("key", null); // æŠ›å‡ºNullPointerException
        } catch (Exception e) {
            System.out.println("ConcurrentHashMapä¸å…è®¸nullå€¼: " + e.getMessage());
        }
    }
    
    /**
     * é”®çš„ä¸å¯å˜æ€§
     */
    public static void keyImmutabilityTrap() {
        Map<StringBuilder, Integer> badMap = new HashMap<>();
        StringBuilder key = new StringBuilder("key");
        badMap.put(key, 1);
        
        // ä¿®æ”¹é”®çš„å†…å®¹
        key.append("Modified");
        
        // ç°åœ¨æ— æ³•é€šè¿‡åŸé”®è·å–å€¼
        System.out.println("ä¿®æ”¹é”®åè·å–å€¼: " + badMap.get(new StringBuilder("key"))); // null
        System.out.println("ä¿®æ”¹åçš„é”®è·å–å€¼: " + badMap.get(key)); // 1
    }
}
```

## 9. æ€»ç»“

Mapæ¥å£ä½œä¸ºJavaé›†åˆæ¡†æ¶çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæä¾›äº†é”®å€¼å¯¹å­˜å‚¨çš„æ ¸å¿ƒåŠŸèƒ½ã€‚é€šè¿‡æ·±å…¥ç†è§£HashMapã€LinkedHashMapã€TreeMapå’ŒConcurrentHashMapçš„å®ç°åŸç†ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®å…·ä½“çš„ä½¿ç”¨åœºæ™¯é€‰æ‹©æœ€åˆé€‚çš„å®ç°ç±»ï¼Œå¹¶é€šè¿‡æœ€ä½³å®è·µæ¥ä¼˜åŒ–æ€§èƒ½ã€é¿å…å¸¸è§é™·é˜±ã€‚

åœ¨å®é™…å¼€å‘ä¸­ï¼Œéœ€è¦ç»¼åˆè€ƒè™‘ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š
- **æ€§èƒ½è¦æ±‚**ï¼šæ ¹æ®è®¿é—®æ¨¡å¼é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
- **é¡ºåºè¦æ±‚**ï¼šæ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©æœ‰åºæˆ–æ— åºçš„å®ç°
- **çº¿ç¨‹å®‰å…¨**ï¼šåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹é€‰æ‹©åˆé€‚çš„å®ç°
- **å†…å­˜ç®¡ç†**ï¼šè€ƒè™‘å†…å­˜ä½¿ç”¨å’Œåƒåœ¾å›æ”¶çš„å½±å“
- **ç‰¹æ®Šéœ€æ±‚**ï¼šæ ¹æ®å…·ä½“ä¸šåŠ¡åœºæ™¯é€‰æ‹©ç‰¹æ®Šå®ç°

é€šè¿‡åˆç†ä½¿ç”¨Mapé›†åˆï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºå‡ºé«˜æ•ˆã€å¯é çš„Javaåº”ç”¨ç¨‹åºã€‚

## 10. é¢è¯•é¢˜ç²¾é€‰

### 10.1 åŸºç¡€æ¦‚å¿µé¢˜

**Q: HashMapå’ŒHashtableçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**

A: ä¸»è¦åŒºåˆ«åŒ…æ‹¬ï¼š
- **çº¿ç¨‹å®‰å…¨**ï¼šHashMapçº¿ç¨‹ä¸å®‰å…¨ï¼ŒHashtableçº¿ç¨‹å®‰å…¨ï¼ˆåŒæ­¥ï¼‰
- **nullå€¼å¤„ç†**ï¼šHashMapå…è®¸nullé”®å’Œnullå€¼ï¼ŒHashtableä¸å…è®¸
- **æ€§èƒ½**ï¼šHashMapæ€§èƒ½æ›´å¥½ï¼ŒHashtableæ€§èƒ½è¾ƒå·®
- **ç»§æ‰¿å…³ç³»**ï¼šHashMapç»§æ‰¿AbstractMapï¼ŒHashtableç»§æ‰¿Dictionary
- **æ¨èä½¿ç”¨**ï¼šHashMapæ˜¯æ¨èé€‰æ‹©ï¼ŒHashtableå·²è¿‡æ—¶

**Q: HashMapçš„å·¥ä½œåŸç†æ˜¯æ€æ ·çš„ï¼Ÿ**

A: HashMapå·¥ä½œåŸç†ï¼š
- **å“ˆå¸Œç®—æ³•**ï¼šä½¿ç”¨`hashCode()`å’Œä½è¿ç®—è®¡ç®—å“ˆå¸Œå€¼
- **ç´¢å¼•è®¡ç®—**ï¼š`hash &amp; (length - 1)`è®¡ç®—æ•°ç»„ç´¢å¼•
- **å†²çªå¤„ç†**ï¼šé“¾è¡¨æ³•å¤„ç†å“ˆå¸Œå†²çªï¼Œé“¾è¡¨é•¿åº¦è¶…è¿‡8æ—¶è½¬ä¸ºçº¢é»‘æ ‘
- **æ‰©å®¹æœºåˆ¶**ï¼šè´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼æ—¶è¿›è¡Œ2å€æ‰©å®¹
- **é‡æ–°å“ˆå¸Œ**ï¼šæ‰©å®¹æ—¶é‡æ–°è®¡ç®—æ‰€æœ‰å…ƒç´ çš„ç´¢å¼•

### 10.2 æ€§èƒ½ä¼˜åŒ–é¢˜

**Q: å¦‚ä½•ä¼˜åŒ–HashMapçš„æ€§èƒ½ï¼Ÿ**

A: ä¸»è¦ä¼˜åŒ–ç­–ç•¥ï¼š
- **é¢„åˆ†é…å®¹é‡**ï¼šä½¿ç”¨å¸¦åˆå§‹å®¹é‡çš„æ„é€ å‡½æ•°é¿å…é¢‘ç¹æ‰©å®¹
- **åˆé€‚çš„è´Ÿè½½å› å­**ï¼šæ ¹æ®å†…å­˜å’Œæ€§èƒ½éœ€æ±‚è°ƒæ•´è´Ÿè½½å› å­
- **åˆé€‚çš„é”®ç±»å‹**ï¼šä½¿ç”¨ä¸å¯å˜å¯¹è±¡ä½œä¸ºé”®ï¼Œé¿å…é”®è¢«ä¿®æ”¹
- **æ‰¹é‡æ“ä½œ**ï¼šä½¿ç”¨`putAll()`ç­‰æ–¹æ³•è¿›è¡Œæ‰¹é‡æ“ä½œ
- **é¿å…é¢‘ç¹æ‰©å®¹**ï¼šåˆç†é¢„ä¼°å…ƒç´ æ•°é‡ï¼Œè®¾ç½®åˆé€‚çš„åˆå§‹å®¹é‡

**Q: ä»€ä¹ˆåœºæ™¯ä¸‹é€‰æ‹©TreeMapï¼Ÿ**

A: TreeMapé€‚ç”¨åœºæ™¯ï¼š
- éœ€è¦æŒ‰é”®æ’åºçš„åœºæ™¯
- éœ€è¦èŒƒå›´æŸ¥è¯¢çš„åœºæ™¯
- éœ€è¦è·å–æœ€å¤§æœ€å°é”®çš„åœºæ™¯
- å¯¹æ€§èƒ½ç¨³å®šæ€§è¦æ±‚è¾ƒé«˜çš„åœºæ™¯
- éœ€è¦è‡ªå®šä¹‰æ’åºè§„åˆ™çš„åœºæ™¯

### 10.3 å®è·µåº”ç”¨é¢˜

**Q: å¦‚ä½•å®ç°çº¿ç¨‹å®‰å…¨çš„Mapæ“ä½œï¼Ÿ**

A: çº¿ç¨‹å®‰å…¨æ–¹æ¡ˆï¼š
- **ConcurrentHashMap**ï¼šæ¨èçš„å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„Mapå®ç°
- **Collections.synchronizedMap()**ï¼šåŒ…è£…ç°æœ‰Mapæä¾›åŒæ­¥
- **Hashtable**ï¼šä¸æ¨èï¼Œæ€§èƒ½è¾ƒå·®
- **å¤–éƒ¨åŒæ­¥**ï¼šä½¿ç”¨synchronizedæˆ–Lockè¿›è¡Œå¤–éƒ¨åŒæ­¥
- **åŸå­æ“ä½œ**ï¼šä½¿ç”¨ConcurrentHashMapçš„åŸå­æ“ä½œæ–¹æ³•

**Q: å¦‚ä½•å®ç°LRUç¼“å­˜ï¼Ÿ**

A: LRUç¼“å­˜å®ç°æ–¹æ¡ˆï¼š
- **LinkedHashMap**ï¼šç»§æ‰¿LinkedHashMapï¼Œé‡å†™`removeEldestEntry()`æ–¹æ³•
- **è‡ªå®šä¹‰å®ç°**ï¼šä½¿ç”¨HashMap + åŒå‘é“¾è¡¨å®ç°
- **ç¬¬ä¸‰æ–¹åº“**ï¼šä½¿ç”¨Guava Cacheæˆ–Caffeineç­‰ç¼“å­˜åº“
- **Redis**ï¼šä½¿ç”¨Redisçš„LRUæ·˜æ±°ç­–ç•¥

### 10.4 é«˜çº§ç‰¹æ€§é¢˜

**Q: ConcurrentHashMapçš„çº¿ç¨‹å®‰å…¨æœºåˆ¶æ˜¯ä»€ä¹ˆï¼Ÿ**

A: ConcurrentHashMapçº¿ç¨‹å®‰å…¨æœºåˆ¶ï¼š
- **åˆ†æ®µé”**ï¼šå°†æ•´ä¸ªMapåˆ†æˆå¤šä¸ªæ®µï¼Œæ¯ä¸ªæ®µä½¿ç”¨ç‹¬ç«‹çš„é”
- **æ®µå†…åŒæ­¥**ï¼šæ¯ä¸ªæ®µä½¿ç”¨ReentrantLockè¿›è¡ŒåŒæ­¥
- **è¯»ä¸åŠ é”**ï¼šè¯»å–æ“ä½œä¸éœ€è¦åŠ é”ï¼Œæé«˜å¹¶å‘æ€§èƒ½
- **å†™åŠ é”**ï¼šå†™å…¥æ“ä½œåªé”å®šå¯¹åº”çš„æ®µï¼Œå‡å°‘é”ç«äº‰
- **åŸå­æ“ä½œ**ï¼šæä¾›åŸå­æ“ä½œæ–¹æ³•å¦‚`putIfAbsent()`ã€`replace()`ç­‰

**Q: TreeMapå’ŒHashMapçš„æ€§èƒ½å¯¹æ¯”å¦‚ä½•ï¼Ÿ**

A: æ€§èƒ½å¯¹æ¯”ï¼š
- **æ—¶é—´å¤æ‚åº¦**ï¼šHashMapå¹³å‡O(1)ï¼ŒTreeMap O(log n)
- **ç©ºé—´å¤æ‚åº¦**ï¼šHashMapç•¥é«˜ï¼ˆæ•°ç»„+é“¾è¡¨ï¼‰ï¼ŒTreeMapè¾ƒä½ï¼ˆçº¢é»‘æ ‘ï¼‰
- **æ’å…¥æ€§èƒ½**ï¼šHashMapæ›´å¿«ï¼ŒTreeMapéœ€è¦ç»´æŠ¤æ ‘ç»“æ„
- **æŸ¥æ‰¾æ€§èƒ½**ï¼šHashMapæ›´å¿«ï¼ŒTreeMapéœ€è¦éå†æ ‘
- **éå†æ€§èƒ½**ï¼šTreeMapæœ‰åºéå†æ›´å¿«ï¼ŒHashMapæ— åº
- **å†…å­˜ä½¿ç”¨**ï¼šTreeMapæ›´èŠ‚çœå†…å­˜ï¼ŒHashMapæœ‰æ•°ç»„å¼€é”€

:::tip é¢è¯•è¦ç‚¹
1. **ç†è§£åº•å±‚å®ç°**ï¼šæŒæ¡å„ç§Mapçš„å†…éƒ¨ç»“æ„å’Œå®ç°åŸç†
2. **æ€§èƒ½åˆ†æ**ï¼šèƒ½å¤Ÿåˆ†æä¸åŒæ“ä½œçš„æ—¶é—´å¤æ‚åº¦å’Œæ€§èƒ½ç‰¹ç‚¹
3. **åœºæ™¯é€‰æ‹©**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„Mapå®ç°ç±»
4. **çº¿ç¨‹å®‰å…¨**ï¼šç†è§£å¹¶å‘ç¯å¢ƒä¸‹çš„ä½¿ç”¨æ–¹æ¡ˆå’Œæ³¨æ„äº‹é¡¹
5. **æœ€ä½³å®è·µ**ï¼šäº†è§£æ€§èƒ½ä¼˜åŒ–å’Œå¸¸è§é™·é˜±çš„è§£å†³æ–¹æ¡ˆ
:::

---

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†Java Mapé›†åˆçš„æ ¸å¿ƒæ¦‚å¿µã€å®ç°åŸç†å’Œæœ€ä½³å®è·µã€‚Mapæ˜¯Javaå¼€å‘ä¸­æœ€å¸¸ç”¨çš„é›†åˆç±»å‹ä¹‹ä¸€ï¼Œæ·±å…¥ç†è§£å…¶ç‰¹æ€§å’Œä½¿ç”¨åœºæ™¯ï¼Œå¯¹äºç¼–å†™é«˜æ•ˆã€å¯é çš„Javaç¨‹åºè‡³å…³é‡è¦ã€‚ 