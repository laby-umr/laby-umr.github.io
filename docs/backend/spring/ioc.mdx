---
sidebar_position: 1
title: "Spring IOC详解"
description: "深入理解Spring控制反转与依赖注入原理"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# Spring IOC 详解

IOC（Inversion of Control，控制反转）是Spring框架的核心概念，它通过依赖注入（DI）实现了对象创建和依赖关系的管理，让开发者专注于业务逻辑的实现。

:::tip 核心价值
IOC = 控制反转 + 依赖注入 + 对象管理 + 松耦合设计
:::

## 1. IOC基础概念

### 1.1 什么是IOC？

IOC是一种设计模式，它将对象的创建和依赖关系的管理从代码中分离出来，交给容器来处理。这样可以降低代码的耦合度，提高代码的可维护性和可测试性。

#### 传统方式 vs IOC方式
```java title="传统对象创建方式"
// 传统方式 - 紧耦合
public class UserService {
    private UserRepository userRepository;
    
    public UserService() {
        // 直接创建依赖对象
        this.userRepository = new UserRepositoryImpl();
    }
    
    public void createUser(User user) {
        userRepository.save(user);
    }
}
```

```java title="IOC方式"
// IOC方式 - 松耦合
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    public void createUser(User user) {
        userRepository.save(user);
    }
}

@Repository
public class UserRepositoryImpl implements UserRepository {
    public void save(User user) {
        // 保存用户逻辑
    }
}
```

### 1.2 IOC容器

Spring IOC容器负责管理对象的生命周期和依赖关系：

```java title="IOC容器示例"
// 创建IOC容器
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

// 从容器获取Bean
UserService userService = context.getBean(UserService.class);

// 使用Bean
userService.createUser(new User("张三"));
```

## 2. 依赖注入方式

### 2.1 构造器注入

```java title="构造器注入"
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // 构造器注入
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public void createUser(User user) {
        userRepository.save(user);
        emailService.sendWelcomeEmail(user.getEmail());
    }
}
```

### 2.2 Setter注入

```java title="Setter注入"
@Service
public class UserService {
    private UserRepository userRepository;
    private EmailService emailService;
    
    // Setter注入
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

### 2.3 字段注入

```java title="字段注入"
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public void createUser(User user) {
        userRepository.save(user);
        emailService.sendWelcomeEmail(user.getEmail());
    }
}
```

:::tip 注入方式选择
- **构造器注入**：推荐使用，可以确保依赖不为null，支持不可变对象
- **Setter注入**：适用于可选依赖
- **字段注入**：简单但不推荐，不利于测试和不可变性
:::

## 3. Bean生命周期

### 3.1 Bean生命周期阶段

```java title="Bean生命周期示例"
@Component
public class UserService implements InitializingBean, DisposableBean {
    
    @PostConstruct
    public void init() {
        System.out.println("1. @PostConstruct - 初始化");
    }
    
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("2. InitializingBean.afterPropertiesSet()");
    }
    
    @PreDestroy
    public void destroy() {
        System.out.println("3. @PreDestroy - 销毁");
    }
    
    @Override
    public void destroy() throws Exception {
        System.out.println("4. DisposableBean.destroy()");
    }
}
```

### 3.2 生命周期回调

| 阶段 | 回调方法 | 说明 |
|------|----------|------|
| **实例化** | 构造器 | 创建Bean实例 |
| **属性注入** | setter方法 | 注入依赖属性 |
| **初始化** | @PostConstruct | 自定义初始化 |
| **初始化** | InitializingBean | 接口初始化 |
| **使用** | 业务方法 | Bean正常使用 |
| **销毁** | @PreDestroy | 自定义销毁 |
| **销毁** | DisposableBean | 接口销毁 |

## 4. Bean作用域

### 4.1 作用域类型

```java title="Bean作用域示例"
@Component
@Scope("singleton") // 单例（默认）
public class SingletonService {
    // 整个容器只有一个实例
}

@Component
@Scope("prototype") // 原型
public class PrototypeService {
    // 每次获取都创建新实例
}

@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionService {
    // 每个会话一个实例
}

@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestService {
    // 每个请求一个实例
}
```

### 4.2 作用域特点

| 作用域 | 说明 | 特点 |
|--------|------|------|
| **singleton** | 单例 | 整个容器只有一个实例，线程安全 |
| **prototype** | 原型 | 每次获取都创建新实例，线程安全 |
| **request** | 请求 | 每个HTTP请求一个实例 |
| **session** | 会话 | 每个HTTP会话一个实例 |
| **application** | 应用 | 每个ServletContext一个实例 |

## 5. 配置方式

### 5.1 注解配置

```java title="注解配置"
@Configuration
@ComponentScan("com.example")
public class AppConfig {
    
    @Bean
    public UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
    
    @Bean
    public EmailService emailService() {
        return new EmailServiceImpl();
    }
}

@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
}
```

### 5.2 XML配置

```xml title="XML配置"
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <bean id="userRepository" class="com.example.repository.UserRepositoryImpl"/>
    
    <bean id="emailService" class="com.example.service.EmailServiceImpl"/>
    
    <bean id="userService" class="com.example.service.UserService">
        <constructor-arg ref="userRepository"/>
        <constructor-arg ref="emailService"/>
    </bean>
    
</beans>
```

### 5.3 Java配置

```java title="Java配置"
@Configuration
public class AppConfig {
    
    @Bean
    public UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
    
    @Bean
    public EmailService emailService() {
        return new EmailServiceImpl();
    }
    
    @Bean
    public UserService userService(UserRepository userRepository, EmailService emailService) {
        return new UserService(userRepository, emailService);
    }
}
```

## 6. 高级特性

### 6.1 条件化Bean

```java title="条件化Bean"
@Configuration
public class AppConfig {
    
    @Bean
    @ConditionalOnProperty(name = "database.type", havingValue = "mysql")
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }
    
    @Bean
    @ConditionalOnProperty(name = "database.type", havingValue = "postgresql")
    public DataSource postgresqlDataSource() {
        return new PostgresqlDataSource();
    }
    
    @Bean
    @ConditionalOnClass(name = "com.mysql.jdbc.Driver")
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

### 6.2 Bean后处理器

```java title="Bean后处理器"
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean初始化前: " + beanName);
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean初始化后: " + beanName);
        return bean;
    }
}
```

### 6.3 工厂Bean

```java title="工厂Bean"
@Component
public class UserServiceFactoryBean implements FactoryBean<UserService> {
    
    @Override
    public UserService getObject() throws Exception {
        // 创建复杂的UserService实例
        return new UserService();
    }
    
    @Override
    public Class<?> getObjectType() {
        return UserService.class;
    }
    
    @Override
    public boolean isSingleton() {
        return true;
    }
}
```

## 7. 面试题精选

### 7.1 基础概念题

**Q: 什么是IOC？它的优势是什么？**

A: IOC（控制反转）是一种设计模式，它将对象的创建和依赖关系的管理从代码中分离出来。优势包括：
- **降低耦合度**：对象之间的依赖关系由容器管理
- **提高可维护性**：修改依赖关系不需要修改业务代码
- **提高可测试性**：可以轻松替换依赖进行测试
- **简化代码**：专注于业务逻辑实现

**Q: Spring IOC容器的核心接口有哪些？**

A: Spring IOC容器的核心接口包括：
- **BeanFactory**：基础容器接口，提供基本的IOC功能
- **ApplicationContext**：BeanFactory的子接口，提供更多企业级功能
- **ConfigurableApplicationContext**：可配置的应用上下文
- **AnnotationConfigApplicationContext**：基于注解的配置上下文

### 7.2 实践题

**Q: Spring中有哪些依赖注入方式？**

A: Spring提供三种依赖注入方式：
- **构造器注入**：通过构造器注入依赖，推荐使用
- **Setter注入**：通过setter方法注入依赖
- **字段注入**：直接在字段上使用@Autowired注解

**Q: Bean的作用域有哪些？**

A: Spring Bean的作用域包括：
- **singleton**：单例（默认），整个容器只有一个实例
- **prototype**：原型，每次获取都创建新实例
- **request**：请求作用域，每个HTTP请求一个实例
- **session**：会话作用域，每个HTTP会话一个实例
- **application**：应用作用域，每个ServletContext一个实例

### 7.3 高级题

**Q: Spring Bean的生命周期是怎样的？**

A: Spring Bean的生命周期包括：
1. **实例化**：创建Bean实例
2. **属性注入**：注入依赖属性
3. **初始化**：执行初始化回调方法
4. **使用**：Bean正常使用
5. **销毁**：执行销毁回调方法

**Q: 如何解决循环依赖问题？**

A: Spring通过三级缓存解决循环依赖：
- **一级缓存**：存放完全初始化好的Bean
- **二级缓存**：存放早期暴露的Bean（未完全初始化）
- **三级缓存**：存放Bean的工厂对象
- 通过提前暴露Bean的引用解决循环依赖

:::tip IOC学习要点
1. **理解核心概念**：掌握IOC、DI、Bean等基本概念
2. **熟悉注入方式**：学会构造器、Setter、字段注入
3. **掌握生命周期**：了解Bean的创建、初始化、销毁过程
4. **学会配置方式**：掌握注解、XML、Java配置
5. **了解高级特性**：学会条件化Bean、后处理器等
:::

---

通过本章的学习，你应该已经掌握了Spring IOC的核心概念、依赖注入方式和Bean生命周期管理。IOC是Spring框架的基础，掌握IOC对于理解整个Spring生态系统至关重要。在实际项目中，合理使用IOC可以构建出松耦合、易维护的应用程序。 