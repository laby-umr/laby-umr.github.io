---
sidebar_position: 4
title: "Spring MVC详解"
description: "深入理解Spring MVC架构、请求处理流程与最佳实践"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# Spring MVC 详解

Spring MVC是Spring框架的核心Web模块，基于MVC（Model-View-Controller）设计模式构建，提供了灵活、强大的Web应用开发解决方案。它是构建企业级Web应用的标准选择。

:::tip 核心价值
Spring MVC = 松耦合架构 + 灵活配置 + 强大扩展 + 企业级支持
:::

## 1. Spring MVC基础概念

### 1.1 什么是Spring MVC？

Spring MVC是一个基于Java的Web框架，实现了MVC设计模式，用于构建Web应用程序。它提供了完整的Web开发解决方案，包括请求处理、视图渲染、数据绑定等功能。

#### MVC架构模式
```java title="MVC架构示例"
// Model（模型）- 数据和业务逻辑
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    
    // getter和setter方法
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}

// View（视图）- 用户界面
@Controller
public class UserController {
    @GetMapping("/users")
    public String listUsers(Model model) {
        List<User> users = userService.findAll();
        model.addAttribute("users", users);
        return "user/list"; // 返回视图名称
    }
}

// Controller（控制器）- 处理请求和响应
@Controller
@RequestMapping("/users")
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping
    public String listUsers(Model model) {
        List<User> users = userService.findAll();
        model.addAttribute("users", users);
        return "user/list";
    }
}
```

### 1.2 Spring MVC核心组件

| 组件 | 作用 | 实现类 |
|------|------|--------|
| **DispatcherServlet** | 前端控制器，统一处理请求 | `org.springframework.web.servlet.DispatcherServlet` |
| **HandlerMapping** | 处理器映射，根据URL找到Handler | `RequestMappingHandlerMapping` |
| **HandlerAdapter** | 处理器适配器，执行Handler | `RequestMappingHandlerAdapter` |
| **ViewResolver** | 视图解析器，解析视图名称 | `InternalResourceViewResolver` |
| **Handler** | 处理器，执行业务逻辑 | `@Controller`注解的类 |
| **View** | 视图，渲染响应 | JSP、Thymeleaf等 |

:::info 组件协作
Spring MVC通过这些核心组件的协作，实现了请求的统一处理和响应的统一返回，提供了松耦合的Web开发架构。
:::

## 2. Spring MVC请求处理流程

### 2.1 请求处理流程详解

Spring MVC的请求处理流程是一个完整的责任链模式实现：

```java title="请求处理流程"
public class RequestProcessingFlow {
    
    public void processRequest(HttpServletRequest request, HttpServletResponse response) {
        try {
            // 1. 请求进入DispatcherServlet
            DispatcherServlet dispatcher = new DispatcherServlet();
            
            // 2. 获取HandlerMapping
            HandlerMapping handlerMapping = getHandlerMapping();
            
            // 3. 根据请求URL找到对应的Handler
            Object handler = handlerMapping.getHandler(request);
            
            // 4. 获取HandlerAdapter
            HandlerAdapter handlerAdapter = getHandlerAdapter(handler);
            
            // 5. 执行Handler方法
            ModelAndView mv = handlerAdapter.handle(request, response, handler);
            
            // 6. 处理视图
            if (mv != null) {
                processView(request, response, mv);
            }
            
        } catch (Exception e) {
            // 异常处理
            handleException(request, response, e);
        }
    }
    
    private HandlerMapping getHandlerMapping() {
        return new RequestMappingHandlerMapping();
    }
    
    private HandlerAdapter getHandlerAdapter(Object handler) {
        return new RequestMappingHandlerAdapter();
    }
    
    private void processView(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) {
        ViewResolver viewResolver = new InternalResourceViewResolver();
        View view = viewResolver.resolveViewName(mv.getViewName(), Locale.getDefault());
        view.render(mv.getModel(), request, response);
    }
}
```

#### 详细流程说明
1. **请求接收**：客户端发送HTTP请求到DispatcherServlet
2. **Handler映射**：通过HandlerMapping找到对应的Handler
3. **Handler适配**：通过HandlerAdapter适配并执行Handler
4. **业务处理**：Handler执行业务逻辑，返回ModelAndView
5. **视图解析**：通过ViewResolver解析视图名称
6. **视图渲染**：渲染视图并返回响应

### 2.2 核心接口详解

```java title="核心接口定义"
// HandlerMapping接口
public interface HandlerMapping {
    Object getHandler(HttpServletRequest request) throws Exception;
}

// HandlerAdapter接口
public interface HandlerAdapter {
    boolean supports(Object handler);
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
}

// ViewResolver接口
public interface ViewResolver {
    View resolveViewName(String viewName, Locale locale) throws Exception;
}

// View接口
public interface View {
    void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception;
}
```

## 3. 控制器开发

### 3.1 控制器基础

控制器是Spring MVC的核心组件，负责处理HTTP请求并返回响应。

```java title="基础控制器"
@Controller
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // GET请求 - 获取用户列表
    @GetMapping
    public ResponseEntity<List<User>> getUsers() {
        List<User> users = userService.findAll();
        return ResponseEntity.ok(users);
    }
    
    // GET请求 - 获取单个用户
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        if (user != null) {
            return ResponseEntity.ok(user);
        }
        return ResponseEntity.notFound().build();
    }
    
    // POST请求 - 创建用户
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
    }
    
    // PUT请求 - 更新用户
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User user) {
        user.setId(id);
        User updatedUser = userService.update(user);
        return ResponseEntity.ok(updatedUser);
    }
    
    // DELETE请求 - 删除用户
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}
```

### 3.2 请求映射注解

Spring MVC提供了丰富的请求映射注解，支持各种HTTP方法和参数绑定：

```java title="请求映射注解"
@Controller
public class RequestMappingController {
    
    // 1. @RequestMapping - 通用映射
    @RequestMapping(value = "/users", method = RequestMethod.GET)
    public String getUsers() {
        return "user/list";
    }
    
    // 2. @GetMapping - GET请求映射
    @GetMapping("/users/{id}")
    public String getUser(@PathVariable Long id) {
        return "user/detail";
    }
    
    // 3. @PostMapping - POST请求映射
    @PostMapping("/users")
    public String createUser(@ModelAttribute User user) {
        return "redirect:/users";
    }
    
    // 4. @PutMapping - PUT请求映射
    @PutMapping("/users/{id}")
    public String updateUser(@PathVariable Long id, @RequestBody User user) {
        return "user/updated";
    }
    
    // 5. @DeleteMapping - DELETE请求映射
    @DeleteMapping("/users/{id}")
    public String deleteUser(@PathVariable Long id) {
        return "user/deleted";
    }
    
    // 6. @PatchMapping - PATCH请求映射
    @PatchMapping("/users/{id}")
    public String patchUser(@PathVariable Long id, @RequestBody User user) {
        return "user/patched";
    }
}
```

:::tip 注解选择
- 使用具体的HTTP方法注解（@GetMapping、@PostMapping等）比@RequestMapping更清晰
- 对于RESTful API，推荐使用@RestController注解
- 对于传统Web应用，使用@Controller注解
:::

### 3.3 参数绑定注解

Spring MVC提供了多种参数绑定注解，支持各种参数类型的自动绑定：

```java title="参数绑定注解"
@Controller
public class ParameterBindingController {
    
    // 1. @PathVariable - 路径变量
    @GetMapping("/users/{id}/orders/{orderId}")
    public String getUserOrder(@PathVariable Long id, @PathVariable Long orderId) {
        return "user/order";
    }
    
    // 2. @RequestParam - 请求参数
    @GetMapping("/search")
    public String search(@RequestParam String keyword, 
                        @RequestParam(defaultValue = "1") int page,
                        @RequestParam(required = false) String sort) {
        return "search/result";
    }
    
    // 3. @RequestBody - 请求体
    @PostMapping("/api/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
    
    // 4. @ModelAttribute - 模型属性
    @PostMapping("/users")
    public String createUser(@ModelAttribute User user, Model model) {
        userService.save(user);
        model.addAttribute("message", "用户创建成功");
        return "user/success";
    }
    
    // 5. @RequestHeader - 请求头
    @GetMapping("/api/data")
    public ResponseEntity<String> getData(@RequestHeader("Authorization") String auth) {
        return ResponseEntity.ok("数据");
    }
    
    // 6. @CookieValue - Cookie值
    @GetMapping("/preferences")
    public String getPreferences(@CookieValue("theme") String theme) {
        return "preferences";
    }
    
    // 7. @SessionAttribute - 会话属性
    @GetMapping("/profile")
    public String getProfile(@SessionAttribute("user") User user) {
        return "user/profile";
    }
    
    // 8. @RequestPart - 文件上传
    @PostMapping("/upload")
    public String uploadFile(@RequestPart("file") MultipartFile file) {
        return "upload/success";
    }
}
```

## 4. 拦截器机制

### 4.1 拦截器基础

拦截器是Spring MVC的重要特性，允许在请求处理的不同阶段进行拦截和处理。

```java title="拦截器实现"
// 实现HandlerInterceptor接口
public class LoggingInterceptor implements HandlerInterceptor {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingInterceptor.class);
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.info("请求开始: {} {}", request.getMethod(), request.getRequestURI());
        request.setAttribute("startTime", System.currentTimeMillis());
        return true; // 返回true继续执行，返回false中断请求
    }
    
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.info("请求处理完成: {} {}", request.getMethod(), request.getRequestURI());
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        long startTime = (Long) request.getAttribute("startTime");
        long endTime = System.currentTimeMillis();
        logger.info("请求完成: {} {} 耗时: {}ms", request.getMethod(), request.getRequestURI(), endTime - startTime);
    }
}
```

### 4.2 认证拦截器

```java title="认证拦截器"
public class AuthenticationInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String token = request.getHeader("Authorization");
        
        if (token == null || !isValidToken(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return false;
        }
        
        // 设置用户信息到请求属性
        User user = getUserFromToken(token);
        request.setAttribute("currentUser", user);
        
        return true;
    }
    
    private boolean isValidToken(String token) {
        return token != null && token.startsWith("Bearer ");
    }
    
    private User getUserFromToken(String token) {
        // 从token中获取用户信息
        return new User();
    }
}
```

### 4.3 权限拦截器

```java title="权限拦截器"
public class AuthorizationInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        User user = (User) request.getAttribute("currentUser");
        
        if (user == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return false;
        }
        
        // 检查用户权限
        if (!hasPermission(user, request.getRequestURI())) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return false;
        }
        
        return true;
    }
    
    private boolean hasPermission(User user, String uri) {
        return user.getPermissions().contains(uri);
    }
}
```

### 4.4 拦截器配置

```java title="拦截器配置"
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 添加日志拦截器
        registry.addInterceptor(new LoggingInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/static/**", "/error");
        
        // 添加认证拦截器
        registry.addInterceptor(new AuthenticationInterceptor())
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/auth/**");
        
        // 添加权限拦截器
        registry.addInterceptor(new AuthorizationInterceptor())
                .addPathPatterns("/api/admin/**")
                .order(1); // 设置执行顺序
    }
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/");
    }
}
```

## 5. 异常处理机制

### 5.1 全局异常处理

Spring MVC提供了强大的异常处理机制，可以统一处理各种异常。

```java title="全局异常处理器"
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        logger.error("业务异常: {}", e.getMessage());
        
        ErrorResponse error = new ErrorResponse();
        error.setCode("BUSINESS_ERROR");
        error.setMessage(e.getMessage());
        error.setTimestamp(System.currentTimeMillis());
        
        return ResponseEntity.badRequest().body(error);
    }
    
    // 处理验证异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        logger.error("参数验证失败: {}", e.getMessage());
        
        List<String> errors = e.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(FieldError::getDefaultMessage)
                .collect(Collectors.toList());
        
        ErrorResponse error = new ErrorResponse();
        error.setCode("VALIDATION_ERROR");
        error.setMessage("参数验证失败");
        error.setDetails(errors);
        error.setTimestamp(System.currentTimeMillis());
        
        return ResponseEntity.badRequest().body(error);
    }
    
    // 处理文件上传异常
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ErrorResponse> handleFileUploadException(MaxUploadSizeExceededException e) {
        logger.error("文件上传失败: {}", e.getMessage());
        
        ErrorResponse error = new ErrorResponse();
        error.setCode("FILE_UPLOAD_ERROR");
        error.setMessage("文件大小超过限制");
        error.setTimestamp(System.currentTimeMillis());
        
        return ResponseEntity.badRequest().body(error);
    }
    
    // 处理通用异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        logger.error("系统异常: {}", e.getMessage(), e);
        
        ErrorResponse error = new ErrorResponse();
        error.setCode("SYSTEM_ERROR");
        error.setMessage("系统内部错误");
        error.setTimestamp(System.currentTimeMillis());
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

### 5.2 错误响应类

```java title="错误响应类"
public class ErrorResponse {
    private String code;
    private String message;
    private List<String> details;
    private long timestamp;
    
    // getter和setter方法
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public List<String> getDetails() { return details; }
    public void setDetails(List<String> details) { this.details = details; }
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}
```

### 5.3 自定义异常

```java title="自定义异常"
// 业务异常基类
public abstract class BusinessException extends RuntimeException {
    
    private String code;
    
    public BusinessException(String message) {
        super(message);
    }
    
    public BusinessException(String code, String message) {
        super(message);
        this.code = code;
    }
    
    public String getCode() {
        return code;
    }
}

// 具体业务异常
public class UserNotFoundException extends BusinessException {
    
    public UserNotFoundException(Long id) {
        super("USER_NOT_FOUND", "用户不存在: " + id);
    }
}

public class DuplicateUserException extends BusinessException {
    
    public DuplicateUserException(String email) {
        super("DUPLICATE_USER", "用户邮箱已存在: " + email);
    }
}

public class InsufficientPermissionException extends BusinessException {
    
    public InsufficientPermissionException(String operation) {
        super("INSUFFICIENT_PERMISSION", "权限不足: " + operation);
    }
}
```

## 6. 数据绑定与验证

### 6.1 数据绑定

Spring MVC提供了强大的数据绑定功能，支持各种数据类型的自动转换。

```java title="数据绑定示例"
@Controller
public class DataBindingController {
    
    // 基本类型绑定
    @GetMapping("/user/{id}")
    public String getUser(@PathVariable Long id, 
                         @RequestParam String name,
                         @RequestParam(defaultValue = "0") int age) {
        return "user/detail";
    }
    
    // 对象绑定
    @PostMapping("/user")
    public String createUser(@ModelAttribute User user) {
        userService.save(user);
        return "redirect:/users";
    }
    
    // JSON绑定
    @PostMapping("/api/user")
    public ResponseEntity<User> createUserApi(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
    
    // 集合绑定
    @PostMapping("/users/batch")
    public String createUsers(@RequestBody List<User> users) {
        userService.saveAll(users);
        return "redirect:/users";
    }
    
    // 日期绑定
    @GetMapping("/events")
    public String getEvents(@RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date date) {
        return "events/list";
    }
}
```

### 6.2 数据验证

```java title="数据验证示例"
@Controller
public class ValidationController {
    
    @PostMapping("/user")
    public String createUser(@Valid @ModelAttribute User user, BindingResult result) {
        if (result.hasErrors()) {
            return "user/form";
        }
        userService.save(user);
        return "redirect:/users";
    }
    
    @PostMapping("/api/user")
    public ResponseEntity<?> createUserApi(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            List<String> errors = result.getFieldErrors()
                    .stream()
                    .map(FieldError::getDefaultMessage)
                    .collect(Collectors.toList());
            
            ErrorResponse error = new ErrorResponse();
            error.setCode("VALIDATION_ERROR");
            error.setMessage("参数验证失败");
            error.setDetails(errors);
            
            return ResponseEntity.badRequest().body(error);
        }
        
            User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
}

// 验证注解示例
public class User {
    @NotNull(message = "用户ID不能为空")
    private Long id;
    
    @NotBlank(message = "用户名不能为空")
    @Size(min = 2, max = 20, message = "用户名长度必须在2-20之间")
    private String name;
    
    @Email(message = "邮箱格式不正确")
    @NotBlank(message = "邮箱不能为空")
    private String email;
    
    @Min(value = 0, message = "年龄不能小于0")
    @Max(value = 150, message = "年龄不能大于150")
    private Integer age;
    
    // getter和setter方法
}
```

## 7. 文件上传

### 7.1 文件上传配置

```java title="文件上传配置"
@Configuration
public class FileUploadConfig {
    
    @Bean
    public MultipartResolver multipartResolver() {
        CommonsMultipartResolver resolver = new CommonsMultipartResolver();
        resolver.setMaxUploadSize(10 * 1024 * 1024); // 10MB
        resolver.setMaxUploadSizePerFile(5 * 1024 * 1024); // 5MB
        resolver.setDefaultEncoding("UTF-8");
        return resolver;
    }
}
```

### 7.2 文件上传处理

```java title="文件上传控制器"
@Controller
public class FileUploadController {
    
    @PostMapping("/upload")
    public String uploadFile(@RequestParam("file") MultipartFile file, Model model) {
        if (file.isEmpty()) {
            model.addAttribute("error", "请选择文件");
            return "upload/form";
        }
        
        try {
            // 保存文件
            String fileName = saveFile(file);
            model.addAttribute("message", "文件上传成功: " + fileName);
        } catch (Exception e) {
            model.addAttribute("error", "文件上传失败: " + e.getMessage());
        }
        
        return "upload/result";
    }
    
    @PostMapping("/api/upload")
    public ResponseEntity<String> uploadFileApi(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("请选择文件");
        }
        
        try {
            String fileName = saveFile(file);
            return ResponseEntity.ok("文件上传成功: " + fileName);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("文件上传失败: " + e.getMessage());
        }
    }
    
    private String saveFile(MultipartFile file) throws IOException {
        String fileName = System.currentTimeMillis() + "_" + file.getOriginalFilename();
        String uploadDir = "uploads/";
        
        File dir = new File(uploadDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        File dest = new File(uploadDir + fileName);
        file.transferTo(dest);
        
        return fileName;
    }
}
```

## 8. RESTful API设计

### 8.1 RESTful API原则

RESTful API设计遵循以下原则：

| 原则 | 说明 | 示例 |
|------|------|------|
| **资源导向** | 使用名词而非动词 | `/users` 而不是 `/getUsers` |
| **HTTP方法语义** | 使用正确的HTTP方法 | GET、POST、PUT、DELETE |
| **无状态** | 每个请求包含完整信息 | 不依赖会话状态 |
| **统一接口** | 使用标准HTTP状态码 | 200、201、400、404等 |
| **可缓存** | 支持缓存机制 | 使用ETag、Cache-Control |

### 8.2 RESTful API实现

```java title="RESTful API控制器"
@RestController
@RequestMapping("/api/users")
public class UserRestController {
    
    @Autowired
    private UserService userService;
    
    // GET /api/users - 获取用户列表
    @GetMapping
    public ResponseEntity<List<User>> getUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        
        List<User> users = userService.findAll(page, size);
        return ResponseEntity.ok(users);
    }
    
    // GET /api/users/{id} - 获取单个用户
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        if (user == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(user);
    }
    
    // POST /api/users - 创建用户
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED)
                .header("Location", "/api/users/" + savedUser.getId())
                .body(savedUser);
    }
    
    // PUT /api/users/{id} - 更新用户
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @Valid @RequestBody User user) {
        user.setId(id);
        User updatedUser = userService.update(user);
        return ResponseEntity.ok(updatedUser);
    }
    
    // DELETE /api/users/{id} - 删除用户
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
    
    // PATCH /api/users/{id} - 部分更新用户
    @PatchMapping("/{id}")
    public ResponseEntity<User> patchUser(@PathVariable Long id, @RequestBody Map<String, Object> updates) {
        User patchedUser = userService.patch(id, updates);
        return ResponseEntity.ok(patchedUser);
    }
}
```

## 9. 性能优化

### 9.1 异步处理

```java title="异步控制器"
@RestController
public class AsyncController {
    
    @Autowired
    private AsyncTaskService asyncTaskService;
    
    // 异步处理
    @GetMapping("/async/task")
    public CompletableFuture<String> asyncTask() {
        return asyncTaskService.processAsync();
    }
    
    // 异步文件处理
    @PostMapping("/async/upload")
    public CompletableFuture<ResponseEntity<String>> asyncUpload(@RequestParam("file") MultipartFile file) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                String result = processFile(file);
                return ResponseEntity.ok(result);
            } catch (Exception e) {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                        .body("处理失败: " + e.getMessage());
            }
        });
    }
}

// 异步配置
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("Async-");
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

### 9.2 缓存支持

```java title="缓存控制器"
@RestController
@RequestMapping("/api/cache")
public class CacheController {
    
    @Autowired
    private UserService userService;
    
    // 使用缓存
    @Cacheable(value = "users", key = "#id")
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    // 清除缓存
    @CacheEvict(value = "users", key = "#id")
    @DeleteMapping("/users/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
    
    // 更新缓存
    @CachePut(value = "users", key = "#user.id")
    @PutMapping("/users")
    public ResponseEntity<User> updateUser(@RequestBody User user) {
        User updatedUser = userService.update(user);
        return ResponseEntity.ok(updatedUser);
    }
}
```

## 10. 面试题精选

### 10.1 基础概念题

**Q: Spring MVC的请求处理流程是怎样的？**

A: Spring MVC的请求处理流程如下：
1. **请求接收**：客户端发送HTTP请求到DispatcherServlet
2. **Handler映射**：通过HandlerMapping找到对应的Handler
3. **Handler适配**：通过HandlerAdapter适配并执行Handler
4. **业务处理**：Handler执行业务逻辑，返回ModelAndView
5. **视图解析**：通过ViewResolver解析视图名称
6. **视图渲染**：渲染视图并返回响应

**Q: @RequestMapping和@GetMapping有什么区别？**

A: 
- `@RequestMapping`是通用注解，可以指定method属性
- `@GetMapping`是`@RequestMapping(method = RequestMethod.GET)`的简写
- `@GetMapping`更简洁，专门用于GET请求
- `@RequestMapping`更灵活，可以处理多种HTTP方法

### 10.2 实践题

**Q: 如何实现RESTful API？**

A: 实现RESTful API需要：
- 使用`@RestController`注解
- 使用`@GetMapping`、`@PostMapping`等注解
- 返回`ResponseEntity`对象
- 使用`@PathVariable`处理路径参数
- 使用`@RequestBody`处理请求体
- 遵循REST设计原则

**Q: Spring MVC的拦截器有什么作用？**

A: Spring MVC拦截器的作用包括：
- **日志记录**：记录请求处理时间和状态
- **权限验证**：检查用户权限和认证状态
- **性能监控**：监控请求处理性能
- **事务管理**：管理数据库事务
- **跨域处理**：处理跨域请求
- **请求预处理和后处理**：在请求处理前后执行特定逻辑

### 10.3 高级题

**Q: 如何实现全局异常处理？**

A: 实现全局异常处理需要：
- 使用`@ControllerAdvice`注解
- 使用`@ExceptionHandler`处理特定异常
- 返回统一的错误响应格式
- 记录异常日志
- 区分业务异常和系统异常 

**Q: Spring MVC如何支持文件上传？**

A: Spring MVC支持文件上传的方式：
- 配置`MultipartResolver`
- 使用`@RequestParam("file") MultipartFile file`接收文件
- 设置文件大小限制和编码
- 处理文件保存逻辑
- 提供文件上传进度反馈

:::tip Spring MVC学习要点
1. **理解MVC架构**：掌握Model、View、Controller的职责分工
2. **熟悉请求处理流程**：了解从请求到响应的完整过程
3. **掌握注解使用**：熟练使用各种Spring MVC注解
4. **学会异常处理**：实现统一的异常处理机制
5. **了解性能优化**：掌握异步处理和缓存技术
:::

---

通过本章的学习，你应该已经掌握了Spring MVC的核心概念、架构设计和实际应用。Spring MVC是构建企业级Web应用的重要框架，掌握其原理和使用方法对于Java Web开发至关重要。在实际项目中，合理使用Spring MVC的各种特性可以构建出高效、可维护的Web应用。 