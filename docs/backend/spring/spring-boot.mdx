---
sidebar_position: 5
title: "Spring Boot详解"
description: "深入理解Spring Boot自动配置、启动流程与最佳实践"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# Spring Boot 详解

Spring Boot是一个基于Spring框架的快速开发平台，它通过约定优于配置的理念，简化了Spring应用的配置和部署。Spring Boot提供了自动配置、内嵌服务器、生产就绪特性等，大大提高了开发效率。

:::tip 核心价值
Spring Boot = 零配置启动 + 自动装配 + 内嵌服务器 + 生产就绪 + 快速开发
:::

## 1. Spring Boot基础概念

### 1.1 什么是Spring Boot？

Spring Boot是Spring框架的扩展，它简化了Spring应用的初始搭建和开发过程。通过自动配置、起步依赖、内嵌服务器等特性，让开发者能够快速构建生产就绪的Spring应用。

#### Spring Boot的优势
| 优势 | 说明 | 示例 |
|------|------|------|
| **自动配置** | 根据classpath自动配置Spring应用 | 添加JPA依赖自动配置数据源 |
| **起步依赖** | 简化Maven/Gradle配置 | `spring-boot-starter-web` |
| **内嵌服务器** | 无需部署到外部服务器 | Tomcat、Jetty、Undertow |
| **生产就绪** | 提供监控、健康检查等特性 | Actuator、Micrometer |
| **无代码生成** | 无需XML配置，纯Java配置 | 注解驱动开发 |

### 1.2 Spring Boot核心注解

```java title="Spring Boot主启动类"
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// @SpringBootApplication注解的组成
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class)
})
public @interface SpringBootApplication {
    // 配置
}
```

:::info 注解说明
- `@SpringBootConfiguration`：标识这是一个Spring Boot配置类
- `@EnableAutoConfiguration`：启用自动配置机制
- `@ComponentScan`：启用组件扫描，自动发现Spring组件
:::

## 2. 自动配置原理

### 2.1 自动配置机制

Spring Boot的自动配置通过`@EnableAutoConfiguration`注解实现，它会根据classpath中的依赖自动配置Spring应用。

```java title="自动配置示例"
// 数据源自动配置
@Configuration
@ConditionalOnClass({DataSource.class, EmbeddedDatabaseType.class})
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class})
public class DataSourceAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public DataSource dataSource(DataSourceProperties properties) {
        return properties.initializeDataSourceBuilder().build();
    }
}

// Web自动配置
@Configuration
@ConditionalOnWebApplication
@EnableConfigurationProperties(WebMvcProperties.class)
public class WebMvcAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public WebMvcConfigurer webMvcConfigurer() {
        return new WebMvcConfigurer() {
            // 默认配置
        };
    }
}
```

### 2.2 条件注解机制

Spring Boot使用条件注解来控制配置的启用条件：

```java title="条件注解类型"
// 类存在时生效
@ConditionalOnClass(name = "com.mysql.jdbc.Driver")
@ConditionalOnMissingClass("com.mysql.jdbc.Driver")

// Bean存在时生效
@ConditionalOnBean(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)

// 属性匹配时生效
@ConditionalOnProperty(name = "spring.datasource.type", havingValue = "mysql")

// 应用类型判断
@ConditionalOnWebApplication
@ConditionalOnNotWebApplication

// 资源存在时生效
@ConditionalOnResource(resources = "classpath:application.yml")

// 表达式为真时生效
@ConditionalOnExpression("${my.feature.enabled:false}")
```

### 2.3 自定义自动配置

```java title="自定义自动配置"
// 1. 创建配置类
@Configuration
@ConditionalOnClass(MyService.class)
@EnableConfigurationProperties(MyServiceProperties.class)
public class MyServiceAutoConfiguration {
    
    @Autowired
    private MyServiceProperties properties;
    
    @Bean
    @ConditionalOnMissingBean
    public MyService myService() {
        return new MyService(properties.getUrl(), properties.getTimeout());
    }
}

// 2. 创建配置属性类
@ConfigurationProperties(prefix = "my.service")
public class MyServiceProperties {
    
    private String url = "http://localhost:8080";
    private int timeout = 5000;
    
    // getter和setter方法
    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }
    public int getTimeout() { return timeout; }
    public void setTimeout(int timeout) { this.timeout = timeout; }
}

// 3. 创建spring.factories文件
// META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.config.MyServiceAutoConfiguration
```

:::tip 自动配置最佳实践
- 使用条件注解确保配置的灵活性
- 提供合理的默认值
- 支持外部配置覆盖
- 遵循Spring Boot的命名约定
:::

## 3. 配置文件管理

### 3.1 配置文件格式

Spring Boot支持多种配置文件格式，推荐使用YAML格式：

```yaml title="application.yml"
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: password
    driver-class-name: com.mysql.jdbc.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL5Dialect
  
  profiles:
    active: dev

logging:
  level:
    root: INFO
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

my:
  service:
    url: http://localhost:8080
    timeout: 5000
```

```properties title="application.properties"
# 服务器配置
server.port=8080
server.servlet.context-path=/api

# 数据库配置
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

# JPA配置
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect

# 日志配置
logging.level.root=INFO
logging.level.com.example=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# 自定义配置
my.service.url=http://localhost:8080
my.service.timeout=5000
```

### 3.2 多环境配置

```yaml title="多环境配置"
# application.yml
spring:
  profiles:
    active: dev

---
# application-dev.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_dev
    username: dev_user
    password: dev_password

logging:
  level:
    com.example: DEBUG

---
# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-server:3306/test_prod
    username: prod_user
    password: prod_password

logging:
  level:
    com.example: WARN
```

### 3.3 配置属性绑定

```java title="配置属性绑定"
// 1. 使用@Value注解
@Component
public class DatabaseConfig {
    
    @Value("${spring.datasource.url}")
    private String url;
    
    @Value("${spring.datasource.username}")
    private String username;
    
    @Value("${spring.datasource.password}")
    private String password;
    
    @Value("${my.service.timeout:5000}") // 默认值
    private int timeout;
}

// 2. 使用@ConfigurationProperties
@ConfigurationProperties(prefix = "spring.datasource")
@Component
public class DataSourceConfig {
    
    private String url;
    private String username;
    private String password;
    private String driverClassName;
    
    // getter和setter方法
    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    public String getDriverClassName() { return driverClassName; }
    public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; }
}

// 3. 使用@ConfigurationProperties + @EnableConfigurationProperties
@Configuration
@EnableConfigurationProperties(DataSourceConfig.class)
public class DatabaseAutoConfiguration {
    
    @Bean
    public DataSource dataSource(DataSourceConfig config) {
        return DataSourceBuilder.create()
            .url(config.getUrl())
            .username(config.getUsername())
            .password(config.getPassword())
            .driverClassName(config.getDriverClassName())
            .build();
    }
}
```

:::caution 配置文件优先级
Spring Boot配置文件的加载优先级（从高到低）：
1. 命令行参数
2. 环境变量
3. 配置文件（file:./config/ > file:./ > classpath:/config/ > classpath:/）
:::

## 4. Spring Boot启动流程

### 4.1 启动流程详解

Spring Boot的启动流程是一个复杂的过程，主要包括以下步骤：

```java title="SpringApplication启动过程"
public class SpringApplication {
    
    public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
        return run(new Class<?>[]{primarySource}, args);
    }
    
    public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
        return new SpringApplication(primarySources).run(args);
    }
    
    public ConfigurableApplicationContext run(String... args) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        ConfigurableApplicationContext context = null;
        Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
        
        configureHeadlessProperty();
        SpringApplicationRunListeners listeners = getRunListeners(args);
        listeners.starting();
        
        try {
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
            configureIgnoreBeanInfo(environment);
            Banner printedBanner = printBanner(environment);
            context = createApplicationContext();
            exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                    new Class[]{ConfigurableApplicationContext.class}, context);
            prepareContext(context, environment, listeners, applicationArguments, printedBanner);
            refreshContext(context);
            afterRefresh(context, applicationArguments);
            stopWatch.stop();
            if (this.logStartupInfo) {
                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
            }
            listeners.started(context);
            callRunners(context, applicationArguments);
        } catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, listeners);
            throw new IllegalStateException(ex);
        }
        
        try {
            listeners.running(context);
        } catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, null);
            throw new IllegalStateException(ex);
        }
        return context;
    }
}
```

#### 启动流程步骤
1. **创建SpringApplication实例**：设置主类、推断应用类型
2. **准备环境**：加载配置文件、设置Profile
3. **创建ApplicationContext**：根据应用类型创建对应的上下文
4. **刷新上下文**：执行Spring容器的初始化过程
5. **执行Runner**：执行ApplicationRunner和CommandLineRunner
6. **启动完成**：应用启动成功

### 4.2 启动监听器

```java title="启动监听器"
// 自定义启动监听器
@Component
public class CustomApplicationListener implements ApplicationListener<ApplicationEvent> {
    
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof ApplicationStartingEvent) {
            System.out.println("应用启动中...");
        } else if (event instanceof ApplicationEnvironmentPreparedEvent) {
            System.out.println("环境准备完成...");
        } else if (event instanceof ApplicationContextInitializedEvent) {
            System.out.println("上下文初始化完成...");
        } else if (event instanceof ApplicationPreparedEvent) {
            System.out.println("应用准备完成...");
        } else if (event instanceof ApplicationStartedEvent) {
            System.out.println("应用启动完成...");
        } else if (event instanceof ApplicationReadyEvent) {
            System.out.println("应用就绪...");
        } else if (event instanceof ApplicationFailedEvent) {
            System.out.println("应用启动失败...");
        }
    }
}

// 自定义启动运行器
@Component
public class CustomApplicationRunner implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("应用启动后执行...");
        System.out.println("启动参数: " + Arrays.toString(args.getSourceArgs()));
    }
}

@Component
public class CustomCommandLineRunner implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("命令行运行器执行...");
        System.out.println("参数: " + Arrays.toString(args));
    }
}
```

## 5. 起步依赖（Starter）

### 5.1 起步依赖原理

起步依赖是Spring Boot的核心特性之一，它简化了Maven/Gradle的依赖管理：

```xml title="起步依赖示例"
<!-- Web应用起步依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- JPA起步依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- 安全起步依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

### 5.2 常用起步依赖

| 起步依赖 | 说明 | 包含的主要依赖 |
|----------|------|----------------|
| `spring-boot-starter-web` | Web应用开发 | Spring MVC、Tomcat、Jackson |
| `spring-boot-starter-data-jpa` | JPA数据访问 | Hibernate、Spring Data JPA |
| `spring-boot-starter-data-redis` | Redis缓存 | Spring Data Redis、Lettuce |
| `spring-boot-starter-security` | 安全框架 | Spring Security |
| `spring-boot-starter-actuator` | 监控管理 | Micrometer、健康检查 |
| `spring-boot-starter-test` | 测试框架 | JUnit、Mockito、Spring Test |

### 5.3 自定义起步依赖

```xml title="自定义起步依赖"
<!-- 自定义起步依赖的pom.xml -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>${spring-boot.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <!-- 核心依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
    <!-- 自动配置 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-autoconfigure</artifactId>
    </dependency>
    
    <!-- 配置处理器 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

## 6. 监控与管理

### 6.1 Spring Boot Actuator

Actuator是Spring Boot提供的生产就绪特性，用于监控和管理应用：

```xml title="Actuator依赖"
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yaml title="Actuator配置"
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,env,configprops
      base-path: /actuator
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
```

### 6.2 自定义健康检查

```java title="自定义健康检查"
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            // 检查数据库连接
            checkDatabase();
            // 检查外部服务
            checkExternalService();
            
            return Health.up()
                .withDetail("database", "UP")
                .withDetail("external-service", "UP")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
    
    private void checkDatabase() {
        // 数据库健康检查逻辑
    }
    
    private void checkExternalService() {
        // 外部服务健康检查逻辑
    }
}
```

### 6.3 自定义监控端点

```java title="自定义监控端点"
@RestController
@RequestMapping("/monitor")
public class CustomMonitorController {
    
    @Autowired
    private ApplicationContext applicationContext;
    
    @GetMapping("/beans")
    public List<String> getBeans() {
        return Arrays.asList(applicationContext.getBeanDefinitionNames());
    }
    
    @GetMapping("/env")
    public Map<String, String> getEnvironment() {
        Environment env = applicationContext.getEnvironment();
        Map<String, String> envMap = new HashMap<>();
        
        envMap.put("active.profiles", Arrays.toString(env.getActiveProfiles()));
        envMap.put("default.profiles", Arrays.toString(env.getDefaultProfiles()));
        
        return envMap;
    }
    
    @GetMapping("/memory")
    public Map<String, Object> getMemoryInfo() {
        Runtime runtime = Runtime.getRuntime();
        Map<String, Object> memoryInfo = new HashMap<>();
        
        memoryInfo.put("total.memory", runtime.totalMemory());
        memoryInfo.put("free.memory", runtime.freeMemory());
        memoryInfo.put("used.memory", runtime.totalMemory() - runtime.freeMemory());
        memoryInfo.put("max.memory", runtime.maxMemory());
        
        return memoryInfo;
    }
}
```

### 6.4 性能监控

```java title="性能监控切面"
@Aspect
@Component
public class PerformanceMonitorAspect {
    
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitorAspect(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = joinPoint.proceed();
            sample.stop(Timer.builder("http.server.requests")
                .tag("method", methodName)
                .tag("status", "200")
                .register(meterRegistry));
            return result;
        } catch (Exception e) {
            sample.stop(Timer.builder("http.server.requests")
                .tag("method", methodName)
                .tag("status", "500")
                .register(meterRegistry));
            throw e;
        }
    }
}
```

## 7. 部署与打包

### 7.1 内嵌服务器

Spring Boot支持多种内嵌服务器：

```xml title="内嵌服务器配置"
<!-- 使用Tomcat（默认） -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- 使用Jetty -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>

<!-- 使用Undertow -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-undertow</artifactId>
</dependency>
```

### 7.2 打包配置

```xml title="打包插件配置"
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <executable>true</executable>
                <mainClass>com.example.Application</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>
```

```bash title="打包命令"
# 打包为JAR文件
mvn clean package

# 运行JAR文件
java -jar target/myapp-0.0.1-SNAPSHOT.jar

# 指定配置文件
java -jar target/myapp-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod

# 指定端口
java -jar target/myapp-0.0.1-SNAPSHOT.jar --server.port=9090
```

## 8. 最佳实践

### 8.1 配置管理

```yaml title="配置最佳实践"
# 使用环境变量
spring:
  datasource:
    url: ${DATABASE_URL:jdbc:mysql://localhost:3306/test}
    username: ${DATABASE_USERNAME:root}
    password: ${DATABASE_PASSWORD:password}

# 使用配置类
@Configuration
@ConfigurationProperties(prefix = "app")
@Data
public class AppConfig {
    private String name;
    private String version;
    private DatabaseConfig database;
    
    @Data
    public static class DatabaseConfig {
        private String url;
        private String username;
        private String password;
    }
}
```

### 8.2 异常处理

```java title="全局异常处理"
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        ErrorResponse error = new ErrorResponse();
        error.setMessage(e.getMessage());
        error.setTimestamp(System.currentTimeMillis());
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException e) {
        ErrorResponse error = new ErrorResponse();
        error.setMessage("参数验证失败");
        error.setDetails(e.getErrors());
        
        return ResponseEntity.badRequest().body(error);
    }
}
```

### 8.3 日志配置

```yaml title="日志配置"
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework.web: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/application.log
    max-size: 10MB
    max-history: 30
```

## 9. 面试题精选

### 9.1 基础概念题

**Q: Spring Boot的自动配置原理是什么？**

A: Spring Boot的自动配置原理包括：
- 通过`@EnableAutoConfiguration`注解启用自动配置
- 使用条件注解（如`@ConditionalOnClass`）判断是否启用配置
- 通过`spring.factories`文件注册自动配置类
- 根据classpath中的依赖自动配置Spring应用

**Q: Spring Boot的启动流程是怎样的？**

A: Spring Boot的启动流程如下：
1. **创建SpringApplication实例**：设置主类、推断应用类型
2. **准备环境**：加载配置文件、设置Profile
3. **创建ApplicationContext**：根据应用类型创建对应的上下文
4. **刷新上下文**：执行Spring容器的初始化过程
5. **执行Runner**：执行ApplicationRunner和CommandLineRunner
6. **启动完成**：应用启动成功

### 9.2 实践题

**Q: 如何自定义Spring Boot的自动配置？**

A: 自定义自动配置需要：
- 创建配置类并使用`@Configuration`注解
- 使用条件注解控制配置的启用条件
- 创建`spring.factories`文件注册自动配置类
- 使用`@EnableConfigurationProperties`绑定配置属性

**Q: Spring Boot的配置文件优先级是怎样的？**

A: Spring Boot配置文件的加载优先级（从高到低）：
1. 命令行参数
2. 环境变量
3. 配置文件（file:./config/ > file:./ > classpath:/config/ > classpath:/）

### 9.3 高级题

**Q: 如何监控Spring Boot应用？**

A: 监控Spring Boot应用的方式：
- 使用Spring Boot Actuator提供监控端点
- 自定义HealthIndicator进行健康检查
- 使用Micrometer收集应用指标
- 集成Prometheus、Grafana等监控工具
- 自定义监控端点和指标

**Q: Spring Boot如何实现零配置启动？**

A: Spring Boot实现零配置启动的机制：
- 通过起步依赖自动管理依赖版本
- 通过自动配置根据classpath自动配置组件
- 通过内嵌服务器避免外部服务器配置
- 通过约定优于配置提供合理的默认值

:::tip Spring Boot学习要点
1. **理解自动配置原理**：掌握条件注解和spring.factories机制
2. **熟悉启动流程**：了解从启动到运行的全过程
3. **掌握配置管理**：学会多环境配置和属性绑定
4. **学会监控管理**：使用Actuator和自定义监控
5. **了解最佳实践**：遵循Spring Boot的设计理念
:::

---

通过本章的学习，你应该已经掌握了Spring Boot的核心概念、自动配置原理和实际应用。Spring Boot是现代Java应用开发的重要框架，掌握其原理和使用方法对于提高开发效率至关重要。在实际项目中，合理使用Spring Boot的各种特性可以快速构建出高质量的企业级应用。 