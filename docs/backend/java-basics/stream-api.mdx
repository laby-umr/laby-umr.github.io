---
sidebar_position: 2
title: Java Stream APIå®Œå…¨æŒ‡å—
description: æ·±å…¥è§£æJava 8 Stream APIçš„æ ¸å¿ƒæ¦‚å¿µã€æ“ä½œæ–¹æ³•ã€æ€§èƒ½ä¼˜åŒ–ä¸å®æˆ˜åº”ç”¨
authors: [Laby]
tags: [Java, Stream API, å‡½æ•°å¼ç¼–ç¨‹, Lambda, é›†åˆå¤„ç†, å¹¶è¡Œæµ, æ€§èƒ½ä¼˜åŒ–]
last_update:
  date: 2025-08-14
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import TOCInline from '@theme/TOCInline';

# Java Stream APIå®Œå…¨æŒ‡å—

Java 8å¼•å…¥çš„Stream APIæ˜¯Javaå‡½æ•°å¼ç¼–ç¨‹çš„é‡è¦é‡Œç¨‹ç¢‘ï¼Œå®ƒæä¾›äº†ä¸€ç§å£°æ˜å¼çš„æ–¹å¼æ¥å¤„ç†é›†åˆæ•°æ®ã€‚Stream APIä¸ä»…è®©ä»£ç æ›´åŠ ç®€æ´ã€å¯è¯»ï¼Œè¿˜æ”¯æŒå¹¶è¡Œå¤„ç†ï¼Œå¤§å¤§æå‡äº†Javaå¤„ç†æ•°æ®çš„èƒ½åŠ›å’Œå¼€å‘æ•ˆç‡ã€‚

:::info æœ¬æ–‡å†…å®¹æ¦‚è§ˆ
<TOCInline toc={toc} />
:::

:::tip æ ¸å¿ƒä»·å€¼
**Stream API = å£°æ˜å¼ç¼–ç¨‹ + å‡½æ•°å¼é£æ ¼ + å¹¶è¡Œå¤„ç† + æµæ°´çº¿æ“ä½œ**
- ğŸ“ **å£°æ˜å¼ç¼–ç¨‹**ï¼šå…³æ³¨åšä»€ä¹ˆè€Œéæ€ä¹ˆåšï¼Œæé«˜ä»£ç å¯è¯»æ€§
- Î» **å‡½æ•°å¼é£æ ¼**ï¼šä½¿ç”¨å‡½æ•°ç»„åˆå’Œè¡¨è¾¾å¼ï¼Œå‡å°‘å‰¯ä½œç”¨
- âš¡ **å¹¶è¡Œå¤„ç†**ï¼šç®€å•åˆ‡æ¢å¹¶è¡Œæ‰§è¡Œï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸å¤„ç†èƒ½åŠ›
- ğŸ”„ **æµæ°´çº¿æ“ä½œ**ï¼šé“¾å¼APIæ”¯æŒå¤šé˜¶æ®µå¤„ç†ï¼Œç®€åŒ–å¤æ‚æ•°æ®è½¬æ¢
- ğŸ§© **å†…ç½®æ“ä½œ**ï¼šä¸°å¯Œçš„å†…ç½®æ“ä½œç¬¦ï¼Œç®€åŒ–å¸¸è§æ•°æ®å¤„ç†ä»»åŠ¡
:::

## 1. StreamåŸºç¡€æ¦‚å¿µä¸åŸç†

### 1.1 Streamæ ¸å¿ƒæ¦‚å¿µ

Streamä¸æ˜¯æ•°æ®ç»“æ„ï¼Œè€Œæ˜¯æ•°æ®æºçš„è§†å›¾ã€‚å®ƒä¸å­˜å‚¨æ•°æ®ï¼Œè€Œæ˜¯æŒ‰éœ€è®¡ç®—ã€‚Streamæ“ä½œåˆ†ä¸ºä¸­é—´æ“ä½œå’Œç»ˆç«¯æ“ä½œã€‚

```mermaid
flowchart LR
    A["æ•°æ®æº<br/>Collection/Array"] --> B["ä¸­é—´æ“ä½œ1<br/>filter/map"]
    B --> C["ä¸­é—´æ“ä½œ2<br/>sorted/distinct"]
    C --> D["ä¸­é—´æ“ä½œN<br/>limit/skip"]
    D --> E["ç»ˆç«¯æ“ä½œ<br/>collect/reduce"]
    E --> F["ç»“æœ<br/>Collection/Value"]
    
    subgraph "æƒ°æ€§æ±‚å€¼åŒºåŸŸ"
        B
        C
        D
    end
    
    subgraph "ç«‹å³æ‰§è¡Œ"
        E
        F
    end
```

#### Streamç‰¹æ€§å¯¹æ¯”è¡¨

| ç‰¹æ€§ | ä¼ ç»Ÿé›†åˆæ“ä½œ | Stream API | ä¼˜åŠ¿ |
|------|-------------|------------|------|
| **æ‰§è¡Œæ–¹å¼** | ç«‹å³æ‰§è¡Œ | æƒ°æ€§æ±‚å€¼ | æ€§èƒ½ä¼˜åŒ–ï¼Œé¿å…ä¸å¿…è¦è®¡ç®— |
| **æ•°æ®ä¿®æ”¹** | å¯èƒ½ä¿®æ”¹åŸæ•°æ® | ä¸ä¿®æ”¹åŸæ•°æ® | æ•°æ®å®‰å…¨ï¼Œå‡½æ•°å¼ç¼–ç¨‹ |
| **å¹¶è¡Œå¤„ç†** | éœ€è¦æ‰‹åŠ¨å®ç° | å†…ç½®å¹¶è¡Œæ”¯æŒ | ç®€åŒ–å¹¶å‘ç¼–ç¨‹ |
| **ä»£ç é£æ ¼** | å‘½ä»¤å¼ | å£°æ˜å¼ | ä»£ç æ›´ç®€æ´æ˜“è¯» |
| **é“¾å¼è°ƒç”¨** | ä¸æ”¯æŒ | å®Œå…¨æ”¯æŒ | æµç•…çš„APIä½“éªŒ |
| **å†…å­˜ä½¿ç”¨** | å¯èƒ½åˆ›å»ºä¸­é—´é›†åˆ | æŒ‰éœ€å¤„ç† | å†…å­˜æ•ˆç‡æ›´é«˜ |

<Tabs>
<TabItem value="stream-basics" label="StreamåŸºç¡€">

### Streamåˆ›å»ºä¸åŸºæœ¬æ“ä½œ

```java title="Streamåˆ›å»ºæ–¹å¼å®Œæ•´ç¤ºä¾‹"
import java.util.*;
import java.util.stream.*;
import java.nio.file.*;
import java.io.IOException;

public class StreamCreationDemo {
    public static void main(String[] args) throws IOException {
        // 1. ä»é›†åˆåˆ›å»ºStream
        List<String> languages = Arrays.asList("Java", "Python", "JavaScript", "C++", "Go");
        Stream<String> streamFromList = languages.stream();
        System.out.println("ä»Liståˆ›å»º: " + streamFromList.collect(Collectors.toList()));
        
        // 2. ä»æ•°ç»„åˆ›å»ºStream
        String[] array = {"Apple", "Banana", "Cherry", "Date"};
        Stream<String> streamFromArray = Arrays.stream(array);
        System.out.println("ä»æ•°ç»„åˆ›å»º: " + streamFromArray.collect(Collectors.toList()));
        
        // 3. ä½¿ç”¨Stream.of()åˆ›å»º
        Stream<Integer> streamOf = Stream.of(1, 2, 3, 4, 5);
        System.out.println("ä½¿ç”¨of()åˆ›å»º: " + streamOf.collect(Collectors.toList()));
        
        // 4. åˆ›å»ºç©ºStream
        Stream<String> emptyStream = Stream.empty();
        System.out.println("ç©ºStreamå…ƒç´ æ•°é‡: " + emptyStream.count());
        
        // 5. ä½¿ç”¨Stream.generate()åˆ›å»ºæ— é™æµ
        Stream<Double> randomStream = Stream.generate(Math::random).limit(5);
        System.out.println("éšæœºæ•°æµ: " + randomStream.collect(Collectors.toList()));
        
        // 6. ä½¿ç”¨Stream.iterate()åˆ›å»º
        Stream<Integer> iterateStream = Stream.iterate(0, n -> n + 2).limit(10);
        System.out.println("è¿­ä»£æµ(å¶æ•°): " + iterateStream.collect(Collectors.toList()));
        
        // 7. ä»èŒƒå›´åˆ›å»ºIntStream
        IntStream rangeStream = IntStream.range(1, 6);
        System.out.println("èŒƒå›´æµ: " + rangeStream.boxed().collect(Collectors.toList()));
        
        // 8. ä»æ–‡ä»¶åˆ›å»ºStream
        try {
            Stream<String> fileStream = Files.lines(Paths.get("example.txt"));
            // æ³¨æ„ï¼šå®é™…ä½¿ç”¨æ—¶éœ€è¦ç¡®ä¿æ–‡ä»¶å­˜åœ¨
            // System.out.println("æ–‡ä»¶è¡Œæ•°: " + fileStream.count());
        } catch (Exception e) {
            System.out.println("æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡æ–‡ä»¶æµç¤ºä¾‹");
        }
        
        // 9. ä»å­—ç¬¦ä¸²åˆ›å»ºå­—ç¬¦æµ
        IntStream charStream = "Hello World".chars();
        System.out.println("å­—ç¬¦æµ: " + charStream.mapToObj(c -> (char) c).collect(Collectors.toList()));
        
        // 10. å¹¶è¡Œæµåˆ›å»º
        Stream<String> parallelStream = languages.parallelStream();
        System.out.println("å¹¶è¡Œæµå¤„ç†: " + parallelStream.map(String::toUpperCase).collect(Collectors.toList()));
    }
}
```

</TabItem>
<TabItem value="stream-pipeline" label="Streamæµæ°´çº¿">

### Streamæ“ä½œæµæ°´çº¿

```java title="Streamæ“ä½œæµæ°´çº¿è¯¦è§£"
import java.util.*;
import java.util.stream.*;

public class StreamPipelineDemo {
    
    static class Product {
        private String name;
        private String category;
        private double price;
        private int stock;
        private boolean available;
        
        public Product(String name, String category, double price, int stock, boolean available) {
            this.name = name;
            this.category = category;
            this.price = price;
            this.stock = stock;
            this.available = available;
        }
        
        // getters
        public String getName() { return name; }
        public String getCategory() { return category; }
        public double getPrice() { return price; }
        public int getStock() { return stock; }
        public boolean isAvailable() { return available; }
        
        @Override
        public String toString() {
            return String.format("Product{name='%s', category='%s', price=%.2f, stock=%d, available=%s}",
                name, category, price, stock, available);
        }
    }
    
    public static void main(String[] args) {
        // åˆ›å»ºæµ‹è¯•æ•°æ®
        List<Product> products = Arrays.asList(
            new Product("iPhone 14", "Electronics", 999.99, 50, true),
            new Product("MacBook Pro", "Electronics", 2499.99, 20, true),
            new Product("AirPods", "Electronics", 179.99, 100, true),
            new Product("Javaç¼–ç¨‹æ€æƒ³", "Books", 89.99, 30, true),
            new Product("Springå®æˆ˜", "Books", 79.99, 0, false),
            new Product("Nikeè¿åŠ¨é‹", "Sports", 129.99, 80, true),
            new Product("Adidas Tæ¤", "Sports", 49.99, 0, false),
            new Product("å’–å•¡æœº", "Home", 299.99, 15, true)
        );
        
        System.out.println("=== åŸå§‹æ•°æ® ===");
        products.forEach(System.out::println);
        
        // å¤æ‚çš„Streamæµæ°´çº¿æ“ä½œ
        System.out.println("\n=== å¤æ‚æµæ°´çº¿å¤„ç† ===");
        Map<String, List<String>> result = products.stream()
            .filter(product -> product.isAvailable())           // è¿‡æ»¤ï¼šåªè¦å¯ç”¨çš„äº§å“
            .filter(product -> product.getPrice() > 50)         // è¿‡æ»¤ï¼šä»·æ ¼å¤§äº50
            .peek(product -> System.out.println("å¤„ç†ä¸­: " + product.getName())) // è°ƒè¯•ï¼šæŸ¥çœ‹å¤„ç†è¿‡ç¨‹
            .sorted(Comparator.comparing(Product::getPrice).reversed()) // æ’åºï¼šæŒ‰ä»·æ ¼é™åº
            .limit(5)                                           // é™åˆ¶ï¼šåªå–å‰5ä¸ª
            .collect(Collectors.groupingBy(                     // åˆ†ç»„ï¼šæŒ‰ç±»åˆ«åˆ†ç»„
                Product::getCategory,
                Collectors.mapping(Product::getName, Collectors.toList())
            ));
        
        System.out.println("\n=== å¤„ç†ç»“æœ ===");
        result.forEach((category, productNames) -> {
            System.out.println(category + ": " + productNames);
        });
        
        // ç»Ÿè®¡ä¿¡æ¯
        System.out.println("\n=== ç»Ÿè®¡ä¿¡æ¯ ===");
        DoubleSummaryStatistics priceStats = products.stream()
            .filter(Product::isAvailable)
            .mapToDouble(Product::getPrice)
            .summaryStatistics();
        
        System.out.println("ä»·æ ¼ç»Ÿè®¡: " + priceStats);
        System.out.println("å¹³å‡ä»·æ ¼: " + String.format("%.2f", priceStats.getAverage()));
        System.out.println("æœ€é«˜ä»·æ ¼: " + priceStats.getMax());
        System.out.println("æœ€ä½ä»·æ ¼: " + priceStats.getMin());
        System.out.println("æ€»è®¡: " + String.format("%.2f", priceStats.getSum()));
        
        // æŸ¥æ‰¾æ“ä½œ
        System.out.println("\n=== æŸ¥æ‰¾æ“ä½œ ===");
        Optional<Product> mostExpensive = products.stream()
            .filter(Product::isAvailable)
            .max(Comparator.comparing(Product::getPrice));
        
        mostExpensive.ifPresent(product -> 
            System.out.println("æœ€è´µçš„äº§å“: " + product.getName() + " - $" + product.getPrice()));
        
        // æ£€æŸ¥æ“ä½œ
        boolean hasExpensiveProduct = products.stream()
            .anyMatch(product -> product.getPrice() > 2000);
        System.out.println("æ˜¯å¦æœ‰ä»·æ ¼è¶…è¿‡2000çš„äº§å“: " + hasExpensiveProduct);
        
        boolean allAvailable = products.stream()
            .allMatch(Product::isAvailable);
        System.out.println("æ‰€æœ‰äº§å“éƒ½å¯ç”¨: " + allAvailable);
    }
}
```

</TabItem>
<TabItem value="lazy-evaluation" label="æƒ°æ€§æ±‚å€¼">

### æƒ°æ€§æ±‚å€¼æœºåˆ¶

```java title="æƒ°æ€§æ±‚å€¼æ¼”ç¤º"
import java.util.*;
import java.util.stream.*;

public class LazyEvaluationDemo {
    
    // è‡ªå®šä¹‰å‡½æ•°ï¼Œç”¨äºæ¼”ç¤ºä½•æ—¶æ‰§è¡Œ
    public static String processString(String input) {
        System.out.println("å¤„ç†å­—ç¬¦ä¸²: " + input);
        return input.toUpperCase();
    }
    
    public static boolean isLongString(String input) {
        System.out.println("æ£€æŸ¥å­—ç¬¦ä¸²é•¿åº¦: " + input);
        return input.length() > 5;
    }
    
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry", "fig");
        
        System.out.println("=== æ¼”ç¤ºæƒ°æ€§æ±‚å€¼ ===");
        System.out.println("åˆ›å»ºStreamï¼ˆæ³¨æ„ï¼šæ²¡æœ‰ä»»ä½•è¾“å‡ºï¼‰");
        
        Stream<String> stream = words.stream()
            .filter(word -> {
                System.out.println("è¿‡æ»¤: " + word);
                return word.length() > 4;
            })
            .map(word -> {
                System.out.println("æ˜ å°„: " + word);
                return word.toUpperCase();
            });
        
        System.out.println("Streamå·²åˆ›å»ºï¼Œä½†è¿˜æ²¡æœ‰æ‰§è¡Œä»»ä½•æ“ä½œ");
        System.out.println("ç°åœ¨æ‰§è¡Œç»ˆç«¯æ“ä½œ...");
        
        List<String> result = stream.collect(Collectors.toList());
        System.out.println("ç»“æœ: " + result);
        
        System.out.println("\n=== çŸ­è·¯æ“ä½œæ¼”ç¤º ===");
        // çŸ­è·¯æ“ä½œï¼šfindFirstä¼šåœ¨æ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…å…ƒç´ ååœæ­¢å¤„ç†
        Optional<String> firstLong = words.stream()
            .filter(word -> {
                System.out.println("çŸ­è·¯è¿‡æ»¤: " + word);
                return word.length() > 5;
            })
            .findFirst();
        
        System.out.println("ç¬¬ä¸€ä¸ªé•¿å­—ç¬¦ä¸²: " + firstLong.orElse("æœªæ‰¾åˆ°"));
        
        System.out.println("\n=== limitæ“ä½œçš„çŸ­è·¯æ•ˆæœ ===");
        List<String> limitedResult = words.stream()
            .filter(word -> {
                System.out.println("limitè¿‡æ»¤: " + word);
                return word.length() > 3;
            })
            .limit(2)  // åªå–å‰2ä¸ª
            .collect(Collectors.toList());
        
        System.out.println("é™åˆ¶ç»“æœ: " + limitedResult);
        
        System.out.println("\n=== æ— ç»ˆç«¯æ“ä½œçš„Stream ===");
        // è¿™ä¸ªStreamä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œï¼Œå› ä¸ºæ²¡æœ‰ç»ˆç«¯æ“ä½œ
        words.stream()
            .filter(word -> {
                System.out.println("è¿™è¡Œä¸ä¼šæ‰“å°: " + word);
                return true;
            })
            .map(word -> {
                System.out.println("è¿™è¡Œä¹Ÿä¸ä¼šæ‰“å°: " + word);
                return word.toUpperCase();
            });
        
        System.out.println("æ²¡æœ‰ç»ˆç«¯æ“ä½œï¼Œæ‰€ä»¥ä¸Šé¢çš„ä¸­é—´æ“ä½œéƒ½ä¸ä¼šæ‰§è¡Œ");
        
        System.out.println("\n=== æ€§èƒ½å¯¹æ¯”ï¼šä¼ ç»Ÿæ–¹å¼ vs Stream ===");
        
        // ä¼ ç»Ÿæ–¹å¼
        long startTime = System.nanoTime();
        List<String> traditionalResult = new ArrayList<>();
        for (String word : words) {
            if (word.length() > 4) {
                traditionalResult.add(word.toUpperCase());
            }
        }
        long traditionalTime = System.nanoTime() - startTime;
        
        // Streamæ–¹å¼
        startTime = System.nanoTime();
        List<String> streamResult = words.stream()
            .filter(word -> word.length() > 4)
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        long streamTime = System.nanoTime() - startTime;
        
        System.out.println("ä¼ ç»Ÿæ–¹å¼ç»“æœ: " + traditionalResult);
        System.out.println("Streamæ–¹å¼ç»“æœ: " + streamResult);
        System.out.println("ä¼ ç»Ÿæ–¹å¼è€—æ—¶: " + traditionalTime + " çº³ç§’");
        System.out.println("Streamæ–¹å¼è€—æ—¶: " + streamTime + " çº³ç§’");
    }
}
```

</TabItem>
</Tabs>

## 2. Streamä¸­é—´æ“ä½œè¯¦è§£

ä¸­é—´æ“ä½œæ˜¯Streamå¤„ç†çš„æ ¸å¿ƒï¼Œå®ƒä»¬æ˜¯æƒ°æ€§çš„ï¼Œåªæœ‰åœ¨é‡åˆ°ç»ˆç«¯æ“ä½œæ—¶æ‰ä¼šæ‰§è¡Œã€‚

```mermaid
graph TB
    subgraph "Streamä¸­é—´æ“ä½œåˆ†ç±»"
        A["ä¸­é—´æ“ä½œ"] --> B["è¿‡æ»¤æ“ä½œ"]
        A --> C["æ˜ å°„æ“ä½œ"]
        A --> D["æ’åºæ“ä½œ"]
        A --> E["å»é‡æ“ä½œ"]
        A --> F["é™åˆ¶æ“ä½œ"]
        A --> G["è·³è¿‡æ“ä½œ"]
        A --> H["æŸ¥çœ‹æ“ä½œ"]
        
        B --> B1["filter"]
        B --> B2["takeWhile"]
        B --> B3["dropWhile"]
        
        C --> C1["map"]
        C --> C2["flatMap"]
        C --> C3["mapToInt/Long/Double"]
        
        D --> D1["sorted"]
        E --> E1["distinct"]
        F --> F1["limit"]
        G --> G1["skip"]
        H --> H1["peek"]
    end
```

<Tabs>
<TabItem value="filter-operations" label="è¿‡æ»¤æ“ä½œ">

### è¿‡æ»¤æ“ä½œè¯¦è§£

```java title="è¿‡æ»¤æ“ä½œå®Œæ•´ç¤ºä¾‹"
import java.util.*;
import java.util.stream.*;

public class FilterOperationsDemo {
    
    static class Employee {
        private String name;
        private String department;
        private int age;
        private double salary;
        private List<String> skills;
        
        public Employee(String name, String department, int age, double salary, String... skills) {
            this.name = name;
            this.department = department;
            this.age = age;
            this.salary = salary;
            this.skills = Arrays.asList(skills);
        }
        
        // getters
        public String getName() { return name; }
        public String getDepartment() { return department; }
        public int getAge() { return age; }
        public double getSalary() { return salary; }
        public List<String> getSkills() { return skills; }
        
        @Override
        public String toString() {
            return String.format("Employee{name='%s', dept='%s', age=%d, salary=%.0f, skills=%s}",
                name, department, age, salary, skills);
        }
    }
    
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("å¼ ä¸‰", "IT", 28, 8000, "Java", "Spring", "MySQL"),
            new Employee("æå››", "IT", 32, 12000, "Python", "Django", "PostgreSQL"),
            new Employee("ç‹äº”", "HR", 29, 6000, "æ‹›è˜", "åŸ¹è®­"),
            new Employee("èµµå…­", "Finance", 35, 9000, "ä¼šè®¡", "å®¡è®¡"),
            new Employee("é’±ä¸ƒ", "IT", 26, 7000, "JavaScript", "React", "Node.js"),
            new Employee("å­™å…«", "Marketing", 31, 7500, "å¸‚åœºåˆ†æ", "å¹¿å‘Šç­–åˆ’"),
            new Employee("å‘¨ä¹", "IT", 40, 15000, "Java", "æ¶æ„è®¾è®¡", "å›¢é˜Ÿç®¡ç†")
        );
        
        System.out.println("=== åŸå§‹å‘˜å·¥æ•°æ® ===");
        employees.forEach(System.out::println);
        
        // 1. åŸºç¡€è¿‡æ»¤ - filter()
        System.out.println("\n=== ITéƒ¨é—¨å‘˜å·¥ ===");
        List<Employee> itEmployees = employees.stream()
            .filter(emp -> "IT".equals(emp.getDepartment()))
            .collect(Collectors.toList());
        itEmployees.forEach(System.out::println);
        
        // 2. å¤åˆæ¡ä»¶è¿‡æ»¤
        System.out.println("\n=== ITéƒ¨é—¨ä¸”è–ªèµ„>8000çš„å‘˜å·¥ ===");
        List<Employee> highSalaryIT = employees.stream()
            .filter(emp -> "IT".equals(emp.getDepartment()))
            .filter(emp -> emp.getSalary() > 8000)
            .collect(Collectors.toList());
        highSalaryIT.forEach(System.out::println);
        
        // 3. ä½¿ç”¨Predicateç»„åˆ
        System.out.println("\n=== ä½¿ç”¨Predicateç»„åˆæ¡ä»¶ ===");
        Predicate<Employee> isIT = emp -> "IT".equals(emp.getDepartment());
        Predicate<Employee> isHighSalary = emp -> emp.getSalary() > 10000;
        Predicate<Employee> isYoung = emp -> emp.getAge() < 30;
        
        // å¹´è½»çš„é«˜è–ªITå‘˜å·¥
        List<Employee> youngHighSalaryIT = employees.stream()
            .filter(isIT.and(isHighSalary).and(isYoung))
            .collect(Collectors.toList());
        System.out.println("å¹´è½»é«˜è–ªITå‘˜å·¥: " + youngHighSalaryIT);
        
        // ITæˆ–é«˜è–ªå‘˜å·¥
        List<Employee> itOrHighSalary = employees.stream()
            .filter(isIT.or(isHighSalary))
            .collect(Collectors.toList());
        System.out.println("ITæˆ–é«˜è–ªå‘˜å·¥æ•°é‡: " + itOrHighSalary.size());
        
        // 4. åŸºäºé›†åˆå±æ€§è¿‡æ»¤
        System.out.println("\n=== æŒæ¡JavaæŠ€èƒ½çš„å‘˜å·¥ ===");
        List<Employee> javaEmployees = employees.stream()
            .filter(emp -> emp.getSkills().contains("Java"))
            .collect(Collectors.toList());
        javaEmployees.forEach(System.out::println);
        
        // 5. ç©ºå€¼è¿‡æ»¤
        List<String> namesWithNulls = Arrays.asList("Alice", null, "Bob", "", "Charlie", null);
        System.out.println("\n=== è¿‡æ»¤ç©ºå€¼å’Œç©ºå­—ç¬¦ä¸² ===");
        List<String> validNames = namesWithNulls.stream()
            .filter(Objects::nonNull)
            .filter(name -> !name.trim().isEmpty())
            .collect(Collectors.toList());
        System.out.println("æœ‰æ•ˆå§“å: " + validNames);
        
        // 6. èŒƒå›´è¿‡æ»¤
        System.out.println("\n=== å¹´é¾„åœ¨25-35ä¹‹é—´çš„å‘˜å·¥ ===");
        List<Employee> ageRangeEmployees = employees.stream()
            .filter(emp -> emp.getAge() >= 25 && emp.getAge() <= 35)
            .collect(Collectors.toList());
        ageRangeEmployees.forEach(emp -> 
            System.out.println(emp.getName() + " - å¹´é¾„: " + emp.getAge()));
        
        // 7. è‡ªå®šä¹‰å¤æ‚è¿‡æ»¤é€»è¾‘
        System.out.println("\n=== èµ„æ·±å‘˜å·¥ï¼ˆå¹´é¾„>30ä¸”è–ªèµ„>å¹³å‡è–ªèµ„ï¼‰ ===");
        double avgSalary = employees.stream()
            .mapToDouble(Employee::getSalary)
            .average()
            .orElse(0.0);
        
        System.out.println("å¹³å‡è–ªèµ„: " + String.format("%.2f", avgSalary));
        
        List<Employee> seniorEmployees = employees.stream()
            .filter(emp -> emp.getAge() > 30 && emp.getSalary() > avgSalary)
            .collect(Collectors.toList());
        seniorEmployees.forEach(System.out::println);
    }
}
```

</TabItem>
<TabItem value="map-operations" label="æ˜ å°„æ“ä½œ">

### æ˜ å°„æ“ä½œè¯¦è§£

```java title="æ˜ å°„æ“ä½œå®Œæ•´ç¤ºä¾‹"
import java.util.*;
import java.util.stream.*;

public class MapOperationsDemo {
    
    static class Order {
        private String orderId;
        private String customerId;
        private List<OrderItem> items;
        private double totalAmount;
        
        public Order(String orderId, String customerId, double totalAmount, OrderItem... items) {
            this.orderId = orderId;
            this.customerId = customerId;
            this.totalAmount = totalAmount;
            this.items = Arrays.asList(items);
        }
        
        // getters
        public String getOrderId() { return orderId; }
        public String getCustomerId() { return customerId; }
        public List<OrderItem> getItems() { return items; }
        public double getTotalAmount() { return totalAmount; }
        
        @Override
        public String toString() {
            return String.format("Order{id='%s', customer='%s', total=%.2f, items=%d}",
                orderId, customerId, totalAmount, items.size());
        }
    }
    
    static class OrderItem {
        private String productName;
        private int quantity;
        private double price;
        
        public OrderItem(String productName, int quantity, double price) {
            this.productName = productName;
            this.quantity = quantity;
            this.price = price;
        }
        
        // getters
        public String getProductName() { return productName; }
        public int getQuantity() { return quantity; }
        public double getPrice() { return price; }
        
        @Override
        public String toString() {
            return String.format("OrderItem{product='%s', qty=%d, price=%.2f}",
                productName, quantity, price);
        }
    }
    
    public static void main(String[] args) {
        // åˆ›å»ºæµ‹è¯•æ•°æ®
        List<Order> orders = Arrays.asList(
            new Order("ORD001", "CUST001", 299.99,
                new OrderItem("ç¬”è®°æœ¬ç”µè„‘", 1, 199.99),
                new OrderItem("é¼ æ ‡", 2, 50.00)),
            new Order("ORD002", "CUST002", 89.98,
                new OrderItem("é”®ç›˜", 1, 79.99),
                new OrderItem("é¼ æ ‡å«", 1, 9.99)),
            new Order("ORD003", "CUST001", 1299.99,
                new OrderItem("æ˜¾ç¤ºå™¨", 1, 899.99),
                new OrderItem("éŸ³å“", 1, 400.00))
        );
        
        System.out.println("=== åŸå§‹è®¢å•æ•°æ® ===");
        orders.forEach(System.out::println);
        
        // 1. åŸºç¡€æ˜ å°„ - map()
        System.out.println("\n=== æå–è®¢å•ID ===");
        List<String> orderIds = orders.stream()
            .map(Order::getOrderId)
            .collect(Collectors.toList());
        System.out.println("è®¢å•IDåˆ—è¡¨: " + orderIds);
        
        // 2. æ˜ å°„åˆ°ä¸åŒç±»å‹
        System.out.println("\n=== è®¢å•æ€»é‡‘é¢åˆ—è¡¨ ===");
        List<Double> totalAmounts = orders.stream()
            .map(Order::getTotalAmount)
            .collect(Collectors.toList());
        System.out.println("æ€»é‡‘é¢åˆ—è¡¨: " + totalAmounts);
        
        // 3. å¤æ‚å¯¹è±¡æ˜ å°„
        System.out.println("\n=== åˆ›å»ºè®¢å•æ‘˜è¦ ===");
        List<String> orderSummaries = orders.stream()
            .map(order -> String.format("è®¢å•%s: å®¢æˆ·%s, é‡‘é¢%.2f, å•†å“%dä»¶",
                order.getOrderId(),
                order.getCustomerId(),
                order.getTotalAmount(),
                order.getItems().size()))
            .collect(Collectors.toList());
        orderSummaries.forEach(System.out::println);
        
        // 4. flatMap - æ‰å¹³åŒ–æ“ä½œ
        System.out.println("\n=== æ‰€æœ‰è®¢å•é¡¹ï¼ˆä½¿ç”¨flatMapï¼‰ ===");
        List<OrderItem> allItems = orders.stream()
            .flatMap(order -> order.getItems().stream())
            .collect(Collectors.toList());
        allItems.forEach(System.out::println);
        
        // 5. flatMapå¤æ‚ç¤ºä¾‹ - æå–æ‰€æœ‰äº§å“åç§°
        System.out.println("\n=== æ‰€æœ‰äº§å“åç§°ï¼ˆå»é‡ï¼‰ ===");
        List<String> allProductNames = orders.stream()
            .flatMap(order -> order.getItems().stream())
            .map(OrderItem::getProductName)
            .distinct()
            .collect(Collectors.toList());
        System.out.println("æ‰€æœ‰äº§å“: " + allProductNames);
        
        // 6. mapToInt/mapToDouble - æ˜ å°„åˆ°åŸºæœ¬ç±»å‹
        System.out.println("\n=== æ•°å€¼ç»Ÿè®¡ ===");
        IntSummaryStatistics itemStats = orders.stream()
            .flatMap(order -> order.getItems().stream())
            .mapToInt(OrderItem::getQuantity)
            .summaryStatistics();
        
        System.out.println("å•†å“æ•°é‡ç»Ÿè®¡: " + itemStats);
        System.out.println("æ€»å•†å“æ•°é‡: " + itemStats.getSum());
        System.out.println("å¹³å‡æ•°é‡: " + itemStats.getAverage());
        
        DoubleSummaryStatistics priceStats = orders.stream()
            .mapToDouble(Order::getTotalAmount)
            .summaryStatistics();
        
        System.out.println("è®¢å•é‡‘é¢ç»Ÿè®¡: " + priceStats);
        System.out.println("æ€»é‡‘é¢: " + String.format("%.2f", priceStats.getSum()));
        System.out.println("å¹³å‡é‡‘é¢: " + String.format("%.2f", priceStats.getAverage()));
        
        // 7. é“¾å¼æ˜ å°„æ“ä½œ
        System.out.println("\n=== é“¾å¼æ˜ å°„ï¼šå®¢æˆ·è®¢å•ç»Ÿè®¡ ===");
        Map<String, Double> customerTotals = orders.stream()
            .collect(Collectors.groupingBy(
                Order::getCustomerId,
                Collectors.summingDouble(Order::getTotalAmount)
            ));
        
        List<String> customerSummaries = customerTotals.entrySet().stream()
            .map(entry -> String.format("å®¢æˆ·%s: æ€»æ¶ˆè´¹%.2f", entry.getKey(), entry.getValue()))
            .sorted()
            .collect(Collectors.toList());
        
        customerSummaries.forEach(System.out::println);
        
        // 8. æ¡ä»¶æ˜ å°„
        System.out.println("\n=== æ¡ä»¶æ˜ å°„ï¼šè®¢å•ç­‰çº§ ===");
        List<String> orderLevels = orders.stream()
            .map(order -> {
                String level;
                if (order.getTotalAmount() > 1000) {
                    level = "VIP";
                } else if (order.getTotalAmount() > 200) {
                    level = "é«˜çº§";
                } else {
                    level = "æ™®é€š";
                }
                return order.getOrderId() + " - " + level;
            })
            .collect(Collectors.toList());
        
        orderLevels.forEach(System.out::println);
        
        // 9. æ˜ å°„åˆ°Optional
        System.out.println("\n=== å®‰å…¨æ˜ å°„ç¤ºä¾‹ ===");
        List<String> safeCustomerIds = orders.stream()
            .map(order -> Optional.ofNullable(order.getCustomerId())
                .filter(id -> !id.isEmpty())
                .orElse("UNKNOWN"))
            .collect(Collectors.toList());
        
        System.out.println("å®‰å…¨çš„å®¢æˆ·ID: " + safeCustomerIds);
        
        // 10. è‡ªå®šä¹‰æ˜ å°„å‡½æ•°
        System.out.println("\n=== è‡ªå®šä¹‰æ˜ å°„å‡½æ•° ===");
        Function<Order, String> orderFormatter = order -> 
            String.format("[%s] %s (%.2få…ƒ)", 
                order.getOrderId(), 
                order.getCustomerId(), 
                order.getTotalAmount());
        
        List<String> formattedOrders = orders.stream()
            .map(orderFormatter)
            .collect(Collectors.toList());
        
        formattedOrders.forEach(System.out::println);
    }
}
```

</TabItem>
<TabItem value="sort-distinct" label="æ’åºå»é‡">

### æ’åºå’Œå»é‡æ“ä½œ

```java title="æ’åºå»é‡æ“ä½œå®Œæ•´ç¤ºä¾‹"
import java.util.*;
import java.util.stream.*;

public class SortDistinctDemo {
    
    static class Student {
        private String name;
        private int age;
        private String major;
        private double gpa;
        private List<String> courses;
        
        public Student(String name, int age, String major, double gpa, String... courses) {
            this.name = name;
            this.age = age;
            this.major = major;
            this.gpa = gpa;
            this.courses = Arrays.asList(courses);
        }
        
        // getters
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getMajor() { return major; }
        public double getGpa() { return gpa; }
        public List<String> getCourses() { return courses; }
        
        @Override
        public String toString() {
            return String.format("Student{name='%s', age=%d, major='%s', gpa=%.2f}",
                name, age, major, gpa);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Student student = (Student) obj;
            return Objects.equals(name, student.name) && Objects.equals(major, student.major);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, major);
        }
    }
    
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("å¼ ä¸‰", 20, "è®¡ç®—æœºç§‘å­¦", 3.8, "æ•°æ®ç»“æ„", "ç®—æ³•", "æ•°æ®åº“"),
            new Student("æå››", 22, "è½¯ä»¶å·¥ç¨‹", 3.6, "è½¯ä»¶æ¶æ„", "è®¾è®¡æ¨¡å¼"),
            new Student("ç‹äº”", 19, "è®¡ç®—æœºç§‘å­¦", 3.9, "æ“ä½œç³»ç»Ÿ", "ç½‘ç»œç¼–ç¨‹"),
            new Student("èµµå…­", 21, "ä¿¡æ¯ç®¡ç†", 3.4, "ä¿¡æ¯ç³»ç»Ÿ", "æ•°æ®åˆ†æ"),
            new Student("é’±ä¸ƒ", 20, "è½¯ä»¶å·¥ç¨‹", 3.7, "é¡¹ç›®ç®¡ç†", "è½¯ä»¶æµ‹è¯•"),
            new Student("å¼ ä¸‰", 20, "è®¡ç®—æœºç§‘å­¦", 3.8, "æ•°æ®ç»“æ„", "ç®—æ³•"), // é‡å¤æ•°æ®
            new Student("å­™å…«", 23, "è®¡ç®—æœºç§‘å­¦", 3.5, "äººå·¥æ™ºèƒ½", "æœºå™¨å­¦ä¹ "),
            new Student("å‘¨ä¹", 22, "ä¿¡æ¯ç®¡ç†", 3.2, "æ•°æ®æŒ–æ˜", "å•†ä¸šæ™ºèƒ½")
        );
        
        System.out.println("=== åŸå§‹å­¦ç”Ÿæ•°æ® ===");
        students.forEach(System.out::println);
        
        // 1. åŸºç¡€æ’åº - æŒ‰å¹´é¾„æ’åº
        System.out.println("\n=== æŒ‰å¹´é¾„å‡åºæ’åº ===");
        List<Student> sortedByAge = students.stream()
            .sorted(Comparator.comparing(Student::getAge))
            .collect(Collectors.toList());
        sortedByAge.forEach(System.out::println);
        
        // 2. é™åºæ’åº - æŒ‰GPAé™åº
        System.out.println("\n=== æŒ‰GPAé™åºæ’åº ===");
        List<Student> sortedByGpaDesc = students.stream()
            .sorted(Comparator.comparing(Student::getGpa).reversed())
            .collect(Collectors.toList());
        sortedByGpaDesc.forEach(System.out::println);
        
        // 3. å¤šå­—æ®µæ’åº
        System.out.println("\n=== å¤šå­—æ®µæ’åºï¼šä¸“ä¸šå‡åºï¼ŒGPAé™åº ===");
        List<Student> multiFieldSorted = students.stream()
            .sorted(Comparator.comparing(Student::getMajor)
                .thenComparing(Student::getGpa, Comparator.reverseOrder()))
            .collect(Collectors.toList());
        multiFieldSorted.forEach(System.out::println);
        
        // 4. è‡ªå®šä¹‰æ’åºé€»è¾‘
        System.out.println("\n=== è‡ªå®šä¹‰æ’åºï¼šå¹´é¾„åˆ†ç»„æ’åº ===");
        List<Student> customSorted = students.stream()
            .sorted((s1, s2) -> {
                // å…ˆæŒ‰å¹´é¾„åˆ†ç»„ï¼š20å²ä»¥ä¸‹ã€20-22å²ã€22å²ä»¥ä¸Š
                int ageGroup1 = s1.getAge() < 20 ? 0 : (s1.getAge() <= 22 ? 1 : 2);
                int ageGroup2 = s2.getAge() < 20 ? 0 : (s2.getAge() <= 22 ? 1 : 2);
                
                if (ageGroup1 != ageGroup2) {
                    return Integer.compare(ageGroup1, ageGroup2);
                }
                
                // åŒä¸€å¹´é¾„ç»„å†…æŒ‰GPAé™åº
                return Double.compare(s2.getGpa(), s1.getGpa());
            })
            .collect(Collectors.toList());
        
        customSorted.forEach(student -> 
            System.out.println(String.format("å¹´é¾„ç»„: %s, %s", 
                getAgeGroup(student.getAge()), student)));
        
        // 5. å»é‡æ“ä½œ - distinct()
        System.out.println("\n=== å»é‡æ“ä½œ ===");
        List<Student> distinctStudents = students.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println("å»é‡å‰æ•°é‡: " + students.size());
        System.out.println("å»é‡åæ•°é‡: " + distinctStudents.size());
        distinctStudents.forEach(System.out::println);
        
        // 6. åŸºäºç‰¹å®šå­—æ®µå»é‡
        System.out.println("\n=== åŸºäºä¸“ä¸šå»é‡ï¼ˆä¿ç•™GPAæœ€é«˜çš„ï¼‰ ===");
        Map<String, Student> bestByMajor = students.stream()
            .collect(Collectors.toMap(
                Student::getMajor,
                student -> student,
                (existing, replacement) -> 
                    existing.getGpa() > replacement.getGpa() ? existing : replacement
            ));
        
        bestByMajor.values().forEach(System.out::println);
        
        // 7. å¤æ‚å»é‡ï¼šåŸºäºå¤šä¸ªå­—æ®µ
        System.out.println("\n=== åŸºäºå§“åå’Œå¹´é¾„å»é‡ ===");
        List<Student> distinctByNameAge = students.stream()
            .collect(Collectors.toMap(
                student -> student.getName() + "-" + student.getAge(),
                student -> student,
                (existing, replacement) -> existing
            ))
            .values()
            .stream()
            .sorted(Comparator.comparing(Student::getName))
            .collect(Collectors.toList());
        
        distinctByNameAge.forEach(System.out::println);
        
        // 8. æ’åº + å»é‡ç»„åˆ
        System.out.println("\n=== æ’åºåå»é‡ï¼šæŒ‰ä¸“ä¸šåˆ†ç»„ï¼Œæ¯ç»„å–GPAæœ€é«˜çš„2å ===");
        Map<String, List<Student>> topStudentsByMajor = students.stream()
            .distinct()
            .sorted(Comparator.comparing(Student::getGpa).reversed())
            .collect(Collectors.groupingBy(Student::getMajor))
            .entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> entry.getValue().stream().limit(2).collect(Collectors.toList())
            ));
        
        topStudentsByMajor.forEach((major, topStudents) -> {
            System.out.println(major + "ä¸“ä¸šå‰2å:");
            topStudents.forEach(student -> System.out.println("  " + student));
        });
        
        // 9. å­—ç¬¦ä¸²å»é‡å’Œæ’åº
        System.out.println("\n=== æ‰€æœ‰è¯¾ç¨‹å»é‡æ’åº ===");
        List<String> allCourses = students.stream()
            .flatMap(student -> student.getCourses().stream())
            .distinct()
            .sorted()
            .collect(Collectors.toList());
        
        System.out.println("æ‰€æœ‰è¯¾ç¨‹: " + allCourses);
        
        // 10. æ€§èƒ½å¯¹æ¯”ï¼šæ’åº vs å»é‡é¡ºåº
        System.out.println("\n=== æ€§èƒ½æµ‹è¯•ï¼šå…ˆæ’åºåå»é‡ vs å…ˆå»é‡åæ’åº ===");
        
        // åˆ›å»ºå¤§é‡é‡å¤æ•°æ®è¿›è¡Œæµ‹è¯•
        List<Student> largeDataset = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            largeDataset.addAll(students);
        }
        
        // å…ˆæ’åºåå»é‡
        long startTime = System.nanoTime();
        List<Student> sortThenDistinct = largeDataset.stream()
            .sorted(Comparator.comparing(Student::getGpa))
            .distinct()
            .collect(Collectors.toList());
        long sortFirstTime = System.nanoTime() - startTime;
        
        // å…ˆå»é‡åæ’åº
        startTime = System.nanoTime();
        List<Student> distinctThenSort = largeDataset.stream()
            .distinct()
            .sorted(Comparator.comparing(Student::getGpa))
            .collect(Collectors.toList());
        long distinctFirstTime = System.nanoTime() - startTime;
        
        System.out.println("æ•°æ®é‡: " + largeDataset.size());
        System.out.println("å…ˆæ’åºåå»é‡è€—æ—¶: " + sortFirstTime / 1_000_000 + " ms");
        System.out.println("å…ˆå»é‡åæ’åºè€—æ—¶: " + distinctFirstTime / 1_000_000 + " ms");
        System.out.println("ç»“æœæ•°é‡ç›¸åŒ: " + (sortThenDistinct.size() == distinctThenSort.size()));
    }
    
    private static String getAgeGroup(int age) {
        if (age < 20) return "19å²ä»¥ä¸‹";
        if (age <= 22) return "20-22å²";
        return "22å²ä»¥ä¸Š";
    }
}
```

</TabItem>
</Tabs>

## 3. Streamç»ˆç«¯æ“ä½œè¯¦è§£

ç»ˆç«¯æ“ä½œä¼šè§¦å‘æµçš„å¤„ç†å¹¶äº§ç”Ÿç»“æœã€‚ä¸€æ—¦æ‰§è¡Œäº†ç»ˆç«¯æ“ä½œï¼Œæµå°±è¢«æ¶ˆè´¹äº†ï¼Œä¸èƒ½å†æ¬¡ä½¿ç”¨ã€‚

```mermaid
flowchart TB
    A["Streamç»ˆç«¯æ“ä½œ"] --> B["æ”¶é›†æ“ä½œ"]
    A --> C["å½’çº¦æ“ä½œ"]
    A --> D["æŸ¥æ‰¾æ“ä½œ"]
    A --> E["åŒ¹é…æ“ä½œ"]
    A --> F["ç»Ÿè®¡æ“ä½œ"]
    A --> G["éå†æ“ä½œ"]
    
    B --> B1["collect"]
    B --> B2["toArray"]
    
    C --> C1["reduce"]
    C --> C2["min/max"]
    
    D --> D1["findFirst"]
    D --> D2["findAny"]
    
    E --> E1["allMatch"]
    E --> E2["anyMatch"]
    E --> E3["noneMatch"]
    
    F --> F1["count"]
    F --> F2["summaryStatistics"]
    
    G --> G1["forEach"]
    G --> G2["forEachOrdered"]
```
 4. å¹¶è¡Œæµä¸æ€§èƒ½ä¼˜åŒ–

å¹¶è¡Œæµæ˜¯Stream APIçš„é‡è¦ç‰¹æ€§ï¼Œå¯ä»¥å……åˆ†åˆ©ç”¨å¤šæ ¸å¤„ç†å™¨çš„ä¼˜åŠ¿ã€‚

```mermaid
graph TB
    subgraph "å¹¶è¡Œæµå¤„ç†æµç¨‹"
        A["æ•°æ®æº"] --> B["Fork/Joinæ¡†æ¶"]
        B --> C["ä»»åŠ¡åˆ†å‰²"]
        C --> D["å¹¶è¡Œå¤„ç†"]
        D --> E["ç»“æœåˆå¹¶"]
        E --> F["æœ€ç»ˆç»“æœ"]
        
        C --> C1["çº¿ç¨‹1"]
        C --> C2["çº¿ç¨‹2"]
        C --> C3["çº¿ç¨‹N"]
        
        C1 --> D
        C2 --> D
        C3 --> D
    end
```

:::warning å¹¶è¡Œæµä½¿ç”¨æ³¨æ„äº‹é¡¹
1. **æ•°æ®é‡è¦è¶³å¤Ÿå¤§**ï¼šå°æ•°æ®é›†ä½¿ç”¨å¹¶è¡Œæµå¯èƒ½åè€Œé™ä½æ€§èƒ½
2. **é¿å…æœ‰çŠ¶æ€æ“ä½œ**ï¼šå¦‚sortedã€distinctç­‰æ“ä½œä¼šå½±å“å¹¶è¡Œæ€§èƒ½
3. **çº¿ç¨‹å®‰å…¨**ï¼šç¡®ä¿Lambdaè¡¨è¾¾å¼ä¸­çš„æ“ä½œæ˜¯çº¿ç¨‹å®‰å…¨çš„
4. **I/Oå¯†é›†å‹ä»»åŠ¡**ï¼šä¸é€‚åˆä½¿ç”¨å¹¶è¡Œæµï¼Œåº”è¯¥ä½¿ç”¨å¼‚æ­¥å¤„ç†
:::

<Tabs>
<TabItem value="parallel-basics" label="å¹¶è¡ŒæµåŸºç¡€">

### å¹¶è¡ŒæµåŸºç¡€æ“ä½œ

```java title="å¹¶è¡ŒæµåŸºç¡€ç¤ºä¾‹"
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class ParallelStreamBasics {
    
    public static void main(String[] args) {
        // åˆ›å»ºå¤§é‡æµ‹è¯•æ•°æ®
        List<Integer> numbers = IntStream.rangeClosed(1, 1_000_000)
            .boxed()
            .collect(Collectors.toList());
        
        System.out.println("æ•°æ®é‡: " + numbers.size());
        System.out.println("å¯ç”¨å¤„ç†å™¨æ•°é‡: " + Runtime.getRuntime().availableProcessors());
        
        // 1. ä¸²è¡Œæµ vs å¹¶è¡Œæµæ€§èƒ½å¯¹æ¯”
        System.out.println("\n=== æ€§èƒ½å¯¹æ¯”ï¼šè®¡ç®—å¹³æ–¹å’Œ ===");
        
        // ä¸²è¡Œæµ
        long startTime = System.currentTimeMillis();
        long serialSum = numbers.stream()
            .mapToLong(n -> (long) n * n)
            .sum();
        long serialTime = System.currentTimeMillis() - startTime;
        
        // å¹¶è¡Œæµ
        startTime = System.currentTimeMillis();
        long parallelSum = numbers.parallelStream()
            .mapToLong(n -> (long) n * n)
            .sum();
        long parallelTime = System.currentTimeMillis() - startTime;
        
        System.out.println("ä¸²è¡Œç»“æœ: " + serialSum + ", è€—æ—¶: " + serialTime + "ms");
        System.out.println("å¹¶è¡Œç»“æœ: " + parallelSum + ", è€—æ—¶: " + parallelTime + "ms");
        System.out.println("æ€§èƒ½æå‡: " + String.format("%.2fx", (double) serialTime / parallelTime));
        
        // 2. å¹¶è¡Œæµåˆ›å»ºæ–¹å¼
        System.out.println("\n=== å¹¶è¡Œæµåˆ›å»ºæ–¹å¼ ===");
        
        // æ–¹å¼1: ä»é›†åˆåˆ›å»ºå¹¶è¡Œæµ
        Stream<Integer> parallelStream1 = numbers.parallelStream();
        
        // æ–¹å¼2: å°†ä¸²è¡Œæµè½¬æ¢ä¸ºå¹¶è¡Œæµ
        Stream<Integer> parallelStream2 = numbers.stream().parallel();
        
        // æ–¹å¼3: ç›´æ¥åˆ›å»ºå¹¶è¡Œæµ
        IntStream parallelIntStream = IntStream.range(1, 1000).parallel();
        
        System.out.println("å¹¶è¡Œæµ1æ˜¯å¦å¹¶è¡Œ: " + parallelStream1.isParallel());
        System.out.println("å¹¶è¡Œæµ2æ˜¯å¦å¹¶è¡Œ: " + parallelStream2.isParallel());
        System.out.println("å¹¶è¡ŒIntStreamæ˜¯å¦å¹¶è¡Œ: " + parallelIntStream.isParallel());
        
        // 3. å¹¶è¡Œæµè½¬ä¸²è¡Œæµ
        Stream<Integer> sequentialStream = numbers.parallelStream().sequential();
        System.out.println("è½¬æ¢åæ˜¯å¦å¹¶è¡Œ: " + sequentialStream.isParallel());
        
        // 4. å¤æ‚è®¡ç®—çš„å¹¶è¡Œå¤„ç†
        System.out.println("\n=== å¤æ‚è®¡ç®—å¹¶è¡Œå¤„ç† ===");
        
        // æ¨¡æ‹Ÿå¤æ‚è®¡ç®—å‡½æ•°
        Function<Integer, Double> complexCalculation = n -> {
            double result = 0;
            for (int i = 1; i <= 1000; i++) {
                result += Math.sin(n * i) * Math.cos(n * i);
            }
            return result;
        };
        
        List<Integer> smallDataset = IntStream.rangeClosed(1, 1000)
            .boxed()
            .collect(Collectors.toList());
        
        // ä¸²è¡Œå¤æ‚è®¡ç®—
        startTime = System.currentTimeMillis();
        double serialComplexSum = smallDataset.stream()
            .mapToDouble(complexCalculation::apply)
            .sum();
        long serialComplexTime = System.currentTimeMillis() - startTime;
        
        // å¹¶è¡Œå¤æ‚è®¡ç®—
        startTime = System.currentTimeMillis();
        double parallelComplexSum = smallDataset.parallelStream()
            .mapToDouble(complexCalculation::apply)
            .sum();
        long parallelComplexTime = System.currentTimeMillis() - startTime;
        
        System.out.println("ä¸²è¡Œå¤æ‚è®¡ç®—: " + String.format("%.2f", serialComplexSum) + 
                          ", è€—æ—¶: " + serialComplexTime + "ms");
        System.out.println("å¹¶è¡Œå¤æ‚è®¡ç®—: " + String.format("%.2f", parallelComplexSum) + 
                          ", è€—æ—¶: " + parallelComplexTime + "ms");
        System.out.println("å¤æ‚è®¡ç®—æ€§èƒ½æå‡: " + 
                          String.format("%.2fx", (double) serialComplexTime / parallelComplexTime));
    }
}
```

</TabItem>
<TabItem value="parallel-performance" label="æ€§èƒ½ä¼˜åŒ–">

### å¹¶è¡Œæµæ€§èƒ½ä¼˜åŒ–

```java title="å¹¶è¡Œæµæ€§èƒ½ä¼˜åŒ–å®è·µ"
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class ParallelStreamOptimization {
    
    // è‡ªå®šä¹‰ForkJoinPool
    private static final ForkJoinPool customThreadPool = new ForkJoinPool(8);
    
    public static void main(String[] args) {
        // 1. æ•°æ®é‡å¯¹å¹¶è¡Œæ€§èƒ½çš„å½±å“
        System.out.println("=== æ•°æ®é‡å¯¹å¹¶è¡Œæ€§èƒ½çš„å½±å“ ===");
        testDataSizeImpact();
        
        // 2. æ“ä½œç±»å‹å¯¹å¹¶è¡Œæ€§èƒ½çš„å½±å“
        System.out.println("\n=== æ“ä½œç±»å‹å¯¹å¹¶è¡Œæ€§èƒ½çš„å½±å“ ===");
        testOperationTypeImpact();
        
        // 3. è‡ªå®šä¹‰çº¿ç¨‹æ± 
        System.out.println("\n=== è‡ªå®šä¹‰çº¿ç¨‹æ±  ===");
        testCustomThreadPool();
        
        // 4. å¹¶è¡Œæµçš„é™·é˜±
        System.out.println("\n=== å¹¶è¡Œæµçš„é™·é˜± ===");
        demonstrateParallelPitfalls();
        
        // æ¸…ç†èµ„æº
        customThreadPool.shutdown();
    }
    
    private static void testDataSizeImpact() {
        int[] dataSizes = {1_000, 10_000, 100_000, 1_000_000};
        
        for (int size : dataSizes) {
            List<Integer> data = IntStream.rangeClosed(1, size)
                .boxed()
                .collect(Collectors.toList());
            
            // ä¸²è¡Œå¤„ç†
            long startTime = System.nanoTime();
            long serialSum = data.stream()
                .mapToLong(n -> (long) n * n)
                .sum();
            long serialTime = System.nanoTime() - startTime;
            
            // å¹¶è¡Œå¤„ç†
            startTime = System.nanoTime();
            long parallelSum = data.parallelStream()
                .mapToLong(n -> (long) n * n)
                .sum();
            long parallelTime = System.nanoTime() - startTime;
            
            double speedup = (double) serialTime / parallelTime;
            
            System.out.printf("æ•°æ®é‡: %,d, ä¸²è¡Œ: %dms, å¹¶è¡Œ: %dms, åŠ é€Ÿæ¯”: %.2fx%n",
                size, serialTime / 1_000_000, parallelTime / 1_000_000, speedup);
        }
    }
    
    private static void testOperationTypeImpact() {
        List<Integer> data = IntStream.rangeClosed(1, 100_000)
            .boxed()
            .collect(Collectors.toList());
        
        // æµ‹è¯•ä¸åŒç±»å‹çš„æ“ä½œ
        Map<String, Runnable> operations = new LinkedHashMap<>();
        
        // CPUå¯†é›†å‹æ“ä½œ
        operations.put("CPUå¯†é›†å‹", () -> {
            long serialTime = measureTime(() -> 
                data.stream().mapToDouble(n -> Math.sin(n) * Math.cos(n)).sum());
            long parallelTime = measureTime(() -> 
                data.parallelStream().mapToDouble(n -> Math.sin(n) * Math.cos(n)).sum());
            
            System.out.printf("  ä¸²è¡Œ: %dms, å¹¶è¡Œ: %dms, åŠ é€Ÿæ¯”: %.2fx%n",
                serialTime, parallelTime, (double) serialTime / parallelTime);
        });
        
        // ç®€å•æ“ä½œ
        operations.put("ç®€å•æ“ä½œ", () -> {
            long serialTime = measureTime(() -> 
                data.stream().mapToLong(n -> n * 2L).sum());
            long parallelTime = measureTime(() -> 
                data.parallelStream().mapToLong(n -> n * 2L).sum());
            
            System.out.printf("  ä¸²è¡Œ: %dms, å¹¶è¡Œ: %dms, åŠ é€Ÿæ¯”: %.2fx%n",
                serialTime, parallelTime, (double) serialTime / parallelTime);
        });
        
        // æœ‰çŠ¶æ€æ“ä½œ
        operations.put("æœ‰çŠ¶æ€æ“ä½œ", () -> {
            long serialTime = measureTime(() -> 
                data.stream().sorted().limit(1000).count());
            long parallelTime = measureTime(() -> 
                data.parallelStream().sorted().limit(1000).count());
            
            System.out.printf("  ä¸²è¡Œ: %dms, å¹¶è¡Œ: %dms, åŠ é€Ÿæ¯”: %.2fx%n",
                serialTime, parallelTime, (double) serialTime / parallelTime);
        });
        
        operations.forEach((name, operation) -> {
            System.out.println(name + ":");
            operation.run();
        });
    }
    
    private static void testCustomThreadPool() {
        List<Integer> data = IntStream.rangeClosed(1, 100_000)
            .boxed()
            .collect(Collectors.toList());
        
        // é»˜è®¤ForkJoinPool
        long defaultTime = measureTime(() -> 
            data.parallelStream()
                .mapToDouble(n -> Math.sin(n) * Math.cos(n))
                .sum());
        
        // è‡ªå®šä¹‰ForkJoinPool
        long customTime = measureTime(() -> {
            try {
                return customThreadPool.submit(() ->
                    data.parallelStream()
                        .mapToDouble(n -> Math.sin(n) * Math.cos(n))
                        .sum()
                ).get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
        
        System.out.println("é»˜è®¤çº¿ç¨‹æ±  (å¹¶è¡Œåº¦: " + 
            ForkJoinPool.commonPool().getParallelism() + "): " + defaultTime + "ms");
        System.out.println("è‡ªå®šä¹‰çº¿ç¨‹æ±  (å¹¶è¡Œåº¦: " + 
            customThreadPool.getParallelism() + "): " + customTime + "ms");
    }
    
    private static void demonstrateParallelPitfalls() {
        List<Integer> data = IntStream.rangeClosed(1, 10_000)
            .boxed()
            .collect(Collectors.toList());
        
        // é™·é˜±1: çº¿ç¨‹å®‰å…¨é—®é¢˜
        System.out.println("é™·é˜±1: çº¿ç¨‹å®‰å…¨é—®é¢˜");
        List<Integer> unsafeList = new ArrayList<>(); // éçº¿ç¨‹å®‰å…¨
        List<Integer> safeList = Collections.synchronizedList(new ArrayList<>()); // çº¿ç¨‹å®‰å…¨
        
        // ä¸å®‰å…¨çš„å¹¶è¡Œæ“ä½œ
        data.parallelStream()
            .filter(n -> n % 2 == 0)
            .forEach(unsafeList::add); // å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±æˆ–å¼‚å¸¸
        
        // å®‰å…¨çš„å¹¶è¡Œæ“ä½œ
        data.parallelStream()
            .filter(n -> n % 2 == 0)
            .forEach(safeList::add);
        
        System.out.println("ä¸å®‰å…¨åˆ—è¡¨å¤§å°: " + unsafeList.size() + " (å¯èƒ½ä¸æ­£ç¡®)");
        System.out.println("å®‰å…¨åˆ—è¡¨å¤§å°: " + safeList.size());
        System.out.println("é¢„æœŸå¤§å°: " + data.stream().mapToInt(n -> n % 2 == 0 ? 1 : 0).sum());
        
        // é™·é˜±2: è£…ç®±/æ‹†ç®±å¼€é”€
        System.out.println("\né™·é˜±2: è£…ç®±/æ‹†ç®±å¼€é”€");
        
        // ä½¿ç”¨åŒ…è£…ç±»å‹ï¼ˆæœ‰è£…ç®±å¼€é”€ï¼‰
        long boxedTime = measureTime(() -> 
            data.parallelStream()
                .map(n -> n * n)
                .reduce(0, Integer::sum));
        
        // ä½¿ç”¨åŸºæœ¬ç±»å‹ï¼ˆæ— è£…ç®±å¼€é”€ï¼‰
        long primitiveTime = measureTime(() -> 
            data.parallelStream()
                .mapToInt(n -> n * n)
                .sum());
        
        System.out.println("åŒ…è£…ç±»å‹è€—æ—¶: " + boxedTime + "ms");
        System.out.println("åŸºæœ¬ç±»å‹è€—æ—¶: " + primitiveTime + "ms");
        System.out.println("æ€§èƒ½å·®å¼‚: " + String.format("%.2fx", (double) boxedTime / primitiveTime));
        
        // é™·é˜±3: é”™è¯¯çš„å½’çº¦æ“ä½œ
        System.out.println("\né™·é˜±3: é”™è¯¯çš„å½’çº¦æ“ä½œ");
        
        // é”™è¯¯çš„å½’çº¦ï¼ˆéç»“åˆå¾‹ï¼‰
        String wrongResult = data.parallelStream()
            .limit(10)
            .map(String::valueOf)
            .reduce("", (a, b) -> a + "-" + b); // ç»“æœä¸ç¡®å®š
        
        // æ­£ç¡®çš„å½’çº¦
        String correctResult = data.parallelStream()
            .limit(10)
            .map(String::valueOf)
            .collect(Collectors.joining("-"));
        
        System.out.println("é”™è¯¯å½’çº¦ç»“æœ: " + wrongResult);
        System.out.println("æ­£ç¡®å½’çº¦ç»“æœ: " + correctResult);
    }
    
    private static long measureTime(Runnable operation) {
        long startTime = System.currentTimeMillis();
        operation.run();
        return System.currentTimeMillis() - startTime;
    }
    
    private static long measureTime(Supplier<Object> operation) {
        long startTime = System.currentTimeMillis();
        operation.get();
        return System.currentTimeMillis() - startTime;
    }
}
```

</TabItem>
</Tabs>

## 5. Streamæœ€ä½³å®è·µä¸è®¾è®¡æ¨¡å¼

æŒæ¡Streamçš„æœ€ä½³å®è·µå’Œå¸¸è§è®¾è®¡æ¨¡å¼ï¼Œèƒ½å¤Ÿå†™å‡ºæ›´ä¼˜é›…ã€é«˜æ•ˆçš„ä»£ç ã€‚

:::tip æœ€ä½³å®è·µåŸåˆ™
1. **ä¼˜å…ˆä½¿ç”¨Stream API**ï¼šç›¸æ¯”ä¼ ç»Ÿå¾ªç¯ï¼ŒStreamæ›´ç®€æ´æ˜“è¯»
2. **åˆç†é€‰æ‹©å¹¶è¡Œæµ**ï¼šåªåœ¨æ•°æ®é‡å¤§ä¸”CPUå¯†é›†æ—¶ä½¿ç”¨
3. **é¿å…å‰¯ä½œç”¨**ï¼šLambdaè¡¨è¾¾å¼åº”è¯¥æ˜¯çº¯å‡½æ•°
4. **ä½¿ç”¨æ–¹æ³•å¼•ç”¨**ï¼šæé«˜ä»£ç å¯è¯»æ€§
5. **é“¾å¼è°ƒç”¨è¦é€‚åº¦**ï¼šè¿‡é•¿çš„é“¾å¼è°ƒç”¨å½±å“å¯è¯»æ€§
:::

é€šè¿‡æŒæ¡Stream APIçš„è¿™äº›æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µï¼Œä½ å¯ä»¥ç¼–å†™å‡ºæ›´åŠ ç®€æ´ã€é«˜æ•ˆã€æ˜“ç»´æŠ¤çš„Javaä»£ç ï¼Œå……åˆ†å‘æŒ¥å‡½æ•°å¼ç¼–ç¨‹çš„ä¼˜åŠ¿ã€‚

## 6. é¢è¯•é¢˜ç²¾é€‰

### 6.1 ä»€ä¹ˆæ˜¯Stream APIï¼Ÿå®ƒæœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ

**ç­”æ¡ˆï¼š** Stream APIæ˜¯Java 8å¼•å…¥çš„å¤„ç†é›†åˆçš„APIï¼Œå®ƒå…è®¸ä»¥å£°æ˜å¼æ–¹å¼å¤„ç†æ•°æ®é›†åˆï¼Œæ”¯æŒå‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ã€‚

Stream APIçš„ä¸»è¦ä¼˜åŠ¿ï¼š
1. **å£°æ˜å¼ç¼–ç¨‹**ï¼šå…³æ³¨"åšä»€ä¹ˆ"è€Œé"æ€ä¹ˆåš"ï¼Œä»£ç æ›´åŠ ç®€æ´ã€å¯è¯»
2. **å‡½æ•°å¼é£æ ¼**ï¼šæ”¯æŒLambdaè¡¨è¾¾å¼å’Œæ–¹æ³•å¼•ç”¨ï¼Œå‡å°‘æ ·æ¿ä»£ç 
3. **å¹¶è¡Œå¤„ç†**ï¼šè½»æ¾åˆ‡æ¢å¹¶è¡Œ/ä¸²è¡Œæ‰§è¡Œï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸å¤„ç†èƒ½åŠ›
4. **æƒ°æ€§æ±‚å€¼**ï¼šä¸­é—´æ“ä½œå»¶è¿Ÿæ‰§è¡Œï¼Œåªæœ‰åœ¨ç»ˆç«¯æ“ä½œæ—¶æ‰ä¼šæ‰§è¡Œï¼Œæé«˜æ€§èƒ½
5. **é“¾å¼æ“ä½œ**ï¼šæ”¯æŒå¤šæ­¥éª¤æµæ°´çº¿å¤„ç†ï¼ŒAPIè®¾è®¡æµç•…
6. **å†…ç½®ä¸°å¯Œæ“ä½œ**ï¼šæä¾›filterã€mapã€reduceç­‰å¤šç§æ•°æ®å¤„ç†æ“ä½œ
7. **æ— å‰¯ä½œç”¨**ï¼šä¸ä¿®æ”¹æ•°æ®æºï¼Œç¬¦åˆå‡½æ•°å¼ç¼–ç¨‹åŸåˆ™

### 6.2 Streamçš„ä¸­é—´æ“ä½œå’Œç»ˆç«¯æ“ä½œæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿå¸¸ç”¨çš„æ“ä½œæœ‰å“ªäº›ï¼Ÿ

**ç­”æ¡ˆï¼š** 
- **ä¸­é—´æ“ä½œ(Intermediate Operations)**ï¼šè¿”å›ä¸€ä¸ªæ–°çš„Streamï¼Œå¯ä»¥é“¾å¼è°ƒç”¨å¤šä¸ªä¸­é—´æ“ä½œï¼Œä¸ä¼šç«‹å³æ‰§è¡Œ
- **ç»ˆç«¯æ“ä½œ(Terminal Operations)**ï¼šè§¦å‘å®é™…è®¡ç®—ï¼Œè¿”å›ä¸€ä¸ªéStreamçš„ç»“æœï¼Œæ‰§è¡ŒåStreamä¸èƒ½å†è¢«ä½¿ç”¨

**å¸¸ç”¨ä¸­é—´æ“ä½œï¼š**
- `filter(Predicate)`: è¿‡æ»¤å…ƒç´ 
- `map(Function)`: è½¬æ¢å…ƒç´ 
- `flatMap(Function)`: æ‰å¹³åŒ–åµŒå¥—é›†åˆ
- `distinct()`: å»é™¤é‡å¤
- `sorted()`: æ’åº
- `peek(Consumer)`: æŸ¥çœ‹å…ƒç´ (è°ƒè¯•)
- `limit(n)`: é™åˆ¶å…ƒç´ æ•°é‡
- `skip(n)`: è·³è¿‡å…ƒç´ 

**å¸¸ç”¨ç»ˆç«¯æ“ä½œï¼š**
- `collect(Collector)`: æ”¶é›†ç»“æœåˆ°å®¹å™¨
- `forEach(Consumer)`: éå†æ¯ä¸ªå…ƒç´ 
- `reduce(BinaryOperator)`: å½’çº¦æ“ä½œ
- `count()`: è®¡æ•°
- `anyMatch(Predicate)`: æ˜¯å¦å­˜åœ¨åŒ¹é…å…ƒç´ 
- `allMatch(Predicate)`: æ˜¯å¦å…¨éƒ¨åŒ¹é…
- `noneMatch(Predicate)`: æ˜¯å¦å…¨éƒ¨ä¸åŒ¹é…
- `findFirst()/findAny()`: æŸ¥æ‰¾å…ƒç´ 
- `min()/max()`: æŸ¥æ‰¾æœ€å°/æœ€å¤§å€¼

```java
// ä¸­é—´æ“ä½œç¤ºä¾‹
List<String> result = names.stream()  // åˆ›å»ºStream
    .filter(name -> name.length() > 5)  // ä¸­é—´æ“ä½œ1
    .map(String::toUpperCase)  // ä¸­é—´æ“ä½œ2
    .sorted()  // ä¸­é—´æ“ä½œ3
    .collect(Collectors.toList());  // ç»ˆç«¯æ“ä½œ
```

### 6.3 Streamä¸Collectionçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ

**ç­”æ¡ˆï¼š** Streamä¸Collectionçš„ä¸»è¦åŒºåˆ«ï¼š

| ç‰¹æ€§ | Stream | Collection |
|------|--------|------------|
| **ç›®çš„** | å¤„ç†æ•°æ® | å­˜å‚¨æ•°æ® |
| **æ•°æ®å­˜å‚¨** | ä¸å­˜å‚¨æ•°æ® | å­˜å‚¨æ•°æ® |
| **æ‰§è¡Œæ–¹å¼** | æƒ°æ€§è®¡ç®— | ç«‹å³è®¡ç®— |
| **æ¶ˆè´¹æ€§** | åªèƒ½éå†ä¸€æ¬¡ | å¯ä»¥å¤šæ¬¡éå† |
| **æ•°æ®ä¿®æ”¹** | ä¸ä¿®æ”¹æ•°æ®æº | å¯ä»¥ä¿®æ”¹æ•°æ® |
| **å¹¶è¡Œå¤„ç†** | å†…ç½®æ”¯æŒå¹¶è¡Œ | éœ€æ‰‹åŠ¨å®ç°å¹¶è¡Œ |
| **æ— é™å¤§å°** | å¯ä»¥è¡¨ç¤ºæ— é™åºåˆ— | æ€»æ˜¯æœ‰é™å¤§å° |

### 6.4 å¦‚ä½•æ­£ç¡®ä½¿ç”¨å¹¶è¡Œæµ(parallelStream)ï¼Ÿä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥é¿å…ä½¿ç”¨ï¼Ÿ

**ç­”æ¡ˆï¼š** 

**æ­£ç¡®ä½¿ç”¨å¹¶è¡Œæµçš„åŸåˆ™ï¼š**
1. **æ•°æ®é‡è¶³å¤Ÿå¤§**ï¼šå¯¹äºå°æ•°æ®é›†ï¼Œå¹¶è¡Œå¤„ç†çš„å¼€é”€å¯èƒ½è¶…è¿‡æ”¶ç›Š
2. **æ“ä½œè¶³å¤Ÿé‡**ï¼šCPUå¯†é›†å‹æ“ä½œæ›´é€‚åˆå¹¶è¡Œå¤„ç†
3. **æ•°æ®ç»“æ„æ˜“æ‹†åˆ†**ï¼šArrayListã€æ•°ç»„åˆ†è§£é«˜æ•ˆï¼ŒLinkedListåˆ†è§£æ•ˆç‡ä½
4. **é¿å…å…±äº«å¯å˜çŠ¶æ€**ï¼šå¹¶è¡Œæ“ä½œä¸­é¿å…ä¿®æ”¹å…±äº«å˜é‡
5. **åˆç†è®¾ç½®çº¿ç¨‹æ± å¤§å°**ï¼šæ ¹æ®CPUæ ¸å¿ƒæ•°å’Œä»»åŠ¡ç‰¹æ€§è°ƒæ•´å¹¶è¡Œåº¦

```java
// å¹¶è¡Œæµç¤ºä¾‹
long sum = IntStream.rangeClosed(1, 10_000_000)
    .parallel()  // åˆ‡æ¢åˆ°å¹¶è¡Œæ¨¡å¼
    .filter(n -> n % 2 == 0)
    .mapToLong(n -> n * n)
    .sum();

// è‡ªå®šä¹‰å¹¶è¡Œåº¦
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "8");
```

**é¿å…ä½¿ç”¨å¹¶è¡Œæµçš„åœºæ™¯ï¼š**
1. **I/Oç»‘å®šæ“ä½œ**ï¼šå¦‚æ–‡ä»¶è¯»å†™ã€ç½‘ç»œæ“ä½œ
2. **é¡ºåºæ•æ„Ÿæ“ä½œ**ï¼šç»“æœä¾èµ–äºå…ƒç´ å¤„ç†é¡ºåº
3. **å¾ˆå°çš„æ•°æ®é‡**ï¼šå¹¶è¡Œå¼€é”€å¯èƒ½å¤§äºæ”¶ç›Š(é€šå¸¸ä½äº1ä¸‡å…ƒç´ )
4. **ä¸å¯åˆ†å‰²çš„æ•°æ®æº**ï¼šå¦‚LinkedListç­‰éš¾ä»¥æœ‰æ•ˆåˆ†å‰²çš„ç»“æ„
5. **ä½¿ç”¨éçº¿ç¨‹å®‰å…¨çš„æ“ä½œæˆ–æ”¶é›†å™¨**ï¼šå¦‚æ™®é€šArrayList::add

### 6.5 è¯·è§£é‡ŠStreamä¸­çš„Collectoræ”¶é›†å™¨ï¼Œå¹¶åˆ—ä¸¾å‡ ä¸ªå¸¸ç”¨çš„æ”¶é›†å™¨ã€‚

**ç­”æ¡ˆï¼š** Collectoræ˜¯ä¸€ç§ç»ˆç«¯æ“ä½œï¼Œç”¨äºå°†Streamä¸­çš„å…ƒç´ ç´¯ç§¯åˆ°ç»“æœå®¹å™¨ä¸­ï¼Œå¦‚Listã€Mapç­‰ã€‚Collectorsç±»æä¾›äº†å¤šç§é¢„å®šä¹‰çš„æ”¶é›†å™¨ã€‚

**å¸¸ç”¨æ”¶é›†å™¨ï¼š**

1. **è½¬æ¢ä¸ºé›†åˆ**ï¼š
```java
// è½¬ä¸ºList
List<String> list = stream.collect(Collectors.toList());
// è½¬ä¸ºSet
Set<String> set = stream.collect(Collectors.toSet());
// è½¬ä¸ºç‰¹å®šé›†åˆ
TreeSet<String> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));
```

2. **å­—ç¬¦ä¸²è¿æ¥**ï¼š
```java
// ç®€å•è¿æ¥
String joined = stream.collect(Collectors.joining());
// å¸¦åˆ†éš”ç¬¦
String joined = stream.collect(Collectors.joining(", "));
// å¸¦å‰ç¼€å’Œåç¼€
String joined = stream.collect(Collectors.joining(", ", "[", "]"));
```

3. **åˆ†ç»„å’Œåˆ†åŒº**ï¼š
```java
// æŒ‰å±æ€§åˆ†ç»„
Map<Department, List<Employee>> byDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));
// å¤šçº§åˆ†ç»„
Map<Department, Map<EmployeeType, List<Employee>>> byDeptAndType = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment,
             Collectors.groupingBy(Employee::getType)));
// åˆ†åŒº(ç‰¹æ®Šåˆ†ç»„)
Map<Boolean, List<Employee>> partitioned = employees.stream()
    .collect(Collectors.partitioningBy(emp -> emp.getSalary() > 50000));
```

4. **ç»Ÿè®¡å’Œæ±‡æ€»**ï¼š
```java
// æ±‚å’Œ
int total = stream.collect(Collectors.summingInt(User::getAge));
// å¹³å‡å€¼
double avg = stream.collect(Collectors.averagingInt(User::getAge));
// æ±‡æ€»ç»Ÿè®¡
IntSummaryStatistics stats = stream.collect(Collectors.summarizingInt(User::getAge));
```

5. **å½’çº¦å’Œæ˜ å°„**ï¼š
```java
// å½’çº¦(ç±»ä¼¼reduce)
Optional<User> oldest = users.stream()
    .collect(Collectors.reducing((u1, u2) -> u1.getAge() > u2.getAge() ? u1 : u2));
// æ˜ å°„åæ”¶é›†
Map<Integer, String> idToName = users.stream()
    .collect(Collectors.toMap(User::getId, User::getName));
```

**è‡ªå®šä¹‰æ”¶é›†å™¨**ï¼šå¯ä»¥é€šè¿‡å®ç°Collectoræ¥å£æˆ–ä½¿ç”¨Collector.of()æ–¹æ³•åˆ›å»ºè‡ªå®šä¹‰æ”¶é›†å™¨ï¼Œæ»¡è¶³ç‰¹æ®Šéœ€æ±‚ã€‚