---
sidebar_position: 8
title: "JavaåŸå­ç±»è¯¦è§£"
description: "å…¨é¢ä»‹ç»JavaåŸå­ç±»ã€CASæœºåˆ¶ã€åŸå­æ“ä½œä¸æœ€ä½³å®è·µ"
authors: [Laby]
last_update:
  date: 2025-01-07
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TOCInline from '@theme/TOCInline';

# Java åŸå­ç±»è¯¦è§£

åŸå­ç±»æ˜¯Javaå¹¶å‘åŒ…ä¸­æä¾›çš„ä¸€ç»„çº¿ç¨‹å®‰å…¨çš„å·¥å…·ç±»ï¼Œå®ƒä»¬åŸºäºCASï¼ˆCompare-And-Swapï¼‰æ“ä½œå®ç°ï¼Œæ— éœ€ä½¿ç”¨synchronizedå…³é”®å­—ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»JavaåŸå­ç±»çš„åŸç†ã€ä½¿ç”¨æ–¹æ³•å’Œæœ€ä½³å®è·µã€‚

:::info æœ¬æ–‡å†…å®¹æ¦‚è§ˆ
<TOCInline toc={toc} />
:::

:::tip æ ¸å¿ƒä»·å€¼
**åŸå­ç±» = æ— é”å¹¶å‘ + é«˜æ€§èƒ½ + çº¿ç¨‹å®‰å…¨æ€§ + ç®€æ´API + å†…å­˜å¯è§æ€§**
- ğŸ”„ **æ— é”æ“ä½œ**ï¼šåŸºäºCASæœºåˆ¶ï¼Œé¿å…ä¼ ç»Ÿé”å¸¦æ¥çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€
- ğŸš€ **é«˜æ€§èƒ½**ï¼šåœ¨ä½ç«äº‰ç¯å¢ƒä¸‹æ€§èƒ½ä¼˜äºä¼ ç»ŸåŒæ­¥æ–¹å¼
- ğŸ›¡ï¸ **çº¿ç¨‹å®‰å…¨**ï¼šä¿è¯æ“ä½œçš„åŸå­æ€§ï¼Œé¿å…å¹¶å‘é—®é¢˜
- ğŸ“Š **ç²¾ç»†æ§åˆ¶**ï¼šæ”¯æŒå¤æ‚çš„åŸå­æ€§æ¡ä»¶æ›´æ–°æ“ä½œ
- ğŸ” **å†…å­˜å¯è§æ€§**ï¼šä¿è¯å¤šçº¿ç¨‹é—´çš„æ•°æ®ä¸€è‡´æ€§
:::

## 1. åŸå­ç±»æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯åŸå­ç±»ï¼Ÿ

```mermaid
graph TD
    A[åŸå­ç±»] --> B[åŸºäºCASæ“ä½œ]
    A --> C[çº¿ç¨‹å®‰å…¨]
    A --> D[æ— é”ç®—æ³•]
    B --> E[æ¯”è¾ƒå¹¶äº¤æ¢]
    B --> F[æ— éœ€synchronized]
    C --> G[åŸå­æ€§ä¿è¯]
    C --> H[å†…å­˜å¯è§æ€§]
    D --> I[é¿å…çº¿ç¨‹é˜»å¡]
    D --> J[æé«˜å¹¶å‘æ€§èƒ½]
```

:::tip æ ¸å¿ƒæ¦‚å¿µ
åŸå­ç±»æ˜¯åŸºäºCASï¼ˆCompare-And-Swapï¼‰æ“ä½œå®ç°çš„çº¿ç¨‹å®‰å…¨å·¥å…·ç±»ï¼Œå®ƒä»¬æä¾›åŸå­æ€§çš„è¯»å†™æ“ä½œï¼Œæ— éœ€ä½¿ç”¨ä¼ ç»Ÿçš„åŒæ­¥æœºåˆ¶ï¼Œå…·æœ‰é«˜æ€§èƒ½ã€æ— é˜»å¡çš„ç‰¹ç‚¹ã€‚
:::

### 1.2 CASæœºåˆ¶åŸç†

<div className="card">
<div className="card__header">
<h4>CAS (Compare-And-Swap) å·¥ä½œåŸç†</h4>
</div>
<div className="card__body">

CASæ˜¯ä¸€ç§æ— é”ç®—æ³•ï¼Œå…¶æ ¸å¿ƒæ˜¯ä¸€æ¡CPUåŸå­æŒ‡ä»¤ï¼Œæ‰§è¡Œè¿‡ç¨‹å¦‚ä¸‹ï¼š

1. **æ¯”è¾ƒ(Compare)**ï¼šè¯»å–å†…å­˜ä¸­å½“å‰å€¼å¹¶ä¸æœŸæœ›å€¼æ¯”è¾ƒ
2. **äº¤æ¢(Swap)**ï¼šå¦‚æœå½“å‰å€¼ç­‰äºæœŸæœ›å€¼ï¼Œåˆ™å°†å€¼æ›´æ–°ä¸ºæ–°å€¼ï¼›å¦åˆ™ä¸æ›´æ–°
3. **è¿”å›ç»“æœ**ï¼šè¿”å›æ¯”è¾ƒç»“æœï¼Œè¡¨æ˜æ“ä½œæ˜¯å¦æˆåŠŸ

CASæ“ä½œåŒ…å«ä¸‰ä¸ªå‚æ•°ï¼š
- **å†…å­˜ä½ç½®V (Variable)**ï¼šè¦æ›´æ–°çš„å˜é‡
- **æœŸæœ›å€¼A (Expected)**ï¼šé¢„æœŸå½“å‰å€¼
- **æ–°å€¼B (New)**ï¼šè¦è®¾ç½®çš„æ–°å€¼

CASæ“ä½œä¿è¯äº†åŸå­æ€§ï¼šè¦ä¹ˆå®Œå…¨æˆåŠŸï¼Œè¦ä¹ˆå®Œå…¨å¤±è´¥ï¼Œä¸ä¼šå‡ºç°ä¸­é—´çŠ¶æ€ã€‚

</div>
</div>

<Tabs>
  <TabItem value="cas_code" label="CASæ¨¡æ‹Ÿå®ç°" default>
  ```java
  public boolean compareAndSet(AtomicInteger value, int expect, int update) {
      // è¿™ä¸ªæ–¹æ³•æ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿï¼Œå®é™…ä¸ŠCASæ˜¯ç”±CPUåŸå­æŒ‡ä»¤å®ç°çš„
      // 1. è¯»å–å½“å‰å€¼
      int current = value.get();
      
      // 2. æ¯”è¾ƒå½“å‰å€¼ä¸æœŸæœ›å€¼
      if (current == expect) {
          // 3. å¦‚æœç›¸ç­‰ï¼Œåˆ™æ›´æ–°ä¸ºæ–°å€¼
          value.set(update);
          return true;
      } else {
          // 4. å¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™æ›´æ–°å¤±è´¥
          return false;
      }
  }
  
  // ä½¿ç”¨CASå®ç°è‡ªæ—‹é”
  public void incrementUsingCAS(AtomicInteger value) {
      int oldValue;
      do {
          // è¯»å–å½“å‰å€¼
          oldValue = value.get();
          // å°è¯•CASæ“ä½œï¼Œç›´åˆ°æˆåŠŸ
      } while (!value.compareAndSet(oldValue, oldValue + 1));
  }
  ```
  </TabItem>
  <TabItem value="cas_diagram" label="CASæ‰§è¡Œæµç¨‹">
  ```mermaid
  sequenceDiagram
      participant çº¿ç¨‹
      participant CPU
      participant å†…å­˜
      
      çº¿ç¨‹->>å†…å­˜: 1. è¯»å–å½“å‰å€¼(V)
      å†…å­˜-->>çº¿ç¨‹: è¿”å›å½“å‰å€¼
      çº¿ç¨‹->>çº¿ç¨‹: 2. è®¡ç®—æ–°å€¼
      çº¿ç¨‹->>CPU: 3. å‘å‡ºCASæŒ‡ä»¤(V, A, B)
      
      alt å½“å‰å€¼ç­‰äºæœŸæœ›å€¼
          CPU->>å†…å­˜: 4a. æ›´æ–°å€¼ä¸ºæ–°å€¼B
          å†…å­˜-->>CPU: æ›´æ–°æˆåŠŸ
          CPU-->>çº¿ç¨‹: è¿”å›æˆåŠŸ(true)
      else å½“å‰å€¼ä¸ç­‰äºæœŸæœ›å€¼
          CPU->>å†…å­˜: 4b. ä¸æ›´æ–°
          å†…å­˜-->>CPU: ä¸å˜
          CPU-->>çº¿ç¨‹: è¿”å›å¤±è´¥(false)
      end
      
      Note over çº¿ç¨‹: 5. æ ¹æ®CASç»“æœ<br/>å†³å®šåç»­æ“ä½œ
  ```
  </TabItem>
  <TabItem value="cas_benefits" label="CASä¼˜åŠ¿">
  <div className="card">
  <div className="card__body">
  <ul>
  <li><strong>é¿å…é”å¼€é”€</strong>ï¼šä¸éœ€è¦è·å–å’Œé‡Šæ”¾é”ï¼Œå‡å°‘çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢</li>
  <li><strong>é«˜æ€§èƒ½</strong>ï¼šåœ¨ä½ç«äº‰ç¯å¢ƒä¸‹ï¼Œæ€§èƒ½æ˜¾è‘—ä¼˜äºä¼ ç»Ÿé”æœºåˆ¶</li>
  <li><strong>æ— é˜»å¡</strong>ï¼šçº¿ç¨‹å¯ä»¥ç«‹å³çŸ¥é“æ›´æ–°æ˜¯å¦æˆåŠŸï¼Œè€Œä¸æ˜¯è¢«é˜»å¡ç­‰å¾…</li>
  <li><strong>é¿å…æ­»é”</strong>ï¼šä¸ä½¿ç”¨é”ï¼Œå› æ­¤ä¸ä¼šå‡ºç°æ­»é”é—®é¢˜</li>
  <li><strong>é€‚åˆè¯»å¤šå†™å°‘</strong>ï¼šåœ¨è¯»æ“ä½œè¿œå¤šäºå†™æ“ä½œçš„åœºæ™¯ä¸‹ç‰¹åˆ«é«˜æ•ˆ</li>
  </ul>
  </div>
  </div>
  </TabItem>
  <TabItem value="cas_limitations" label="CASå±€é™æ€§">
  <div className="card">
  <div className="card__body">
  <ol>
  <li><strong>ABAé—®é¢˜</strong>ï¼šå€¼ä»Aå˜ä¸ºBåˆå˜å›Aï¼ŒCASæ— æ³•æ£€æµ‹åˆ°è¿™ç§å˜åŒ–</li>
  <li><strong>åªèƒ½ä¿è¯å•ä¸ªå˜é‡æ“ä½œçš„åŸå­æ€§</strong>ï¼šä¸æ”¯æŒå¤šä¸ªå˜é‡çš„åŸå­æ€§æ›´æ–°</li>
  <li><strong>è‡ªæ—‹æ¶ˆè€—CPU</strong>ï¼šCASå¤±è´¥æ—¶é€šå¸¸ä¼šè‡ªæ—‹é‡è¯•ï¼Œå¯èƒ½æ¶ˆè€—è¾ƒå¤šCPUèµ„æº</li>
  <li><strong>é«˜ç«äº‰ä¸‹æ€§èƒ½ä¸‹é™</strong>ï¼šå½“å¤šä¸ªçº¿ç¨‹é¢‘ç¹äº‰ç”¨åŒä¸€å˜é‡æ—¶ï¼ŒCASå¤±è´¥ç‡é«˜</li>
  </ol>
  </div>
  </div>
  </TabItem>
</Tabs>

### 1.3 åŸå­ç±»åˆ†ç±»

<div className="card">
<div className="card__header">
<h4>JavaåŸå­ç±»å®¶æ—</h4>
</div>
<div className="card__body">

```mermaid
classDiagram
    class AtomicClasses {
        <<interface>>
    }
    
    class BasicType {
        AtomicInteger
        AtomicLong
        AtomicBoolean
    }
    
    class ReferenceType {
        AtomicReference~V~
        AtomicStampedReference~V~
        AtomicMarkableReference~V~
    }
    
    class ArrayType {
        AtomicIntegerArray
        AtomicLongArray
        AtomicReferenceArray~V~
    }
    
    class FieldUpdaters {
        AtomicIntegerFieldUpdater~T~
        AtomicLongFieldUpdater~T~
        AtomicReferenceFieldUpdater~T,V~
    }
    
    class AdvancedAtomic {
        LongAdder
        LongAccumulator
        DoubleAdder
        DoubleAccumulator
    }
    
    AtomicClasses <|-- BasicType
    AtomicClasses <|-- ReferenceType
    AtomicClasses <|-- ArrayType
    AtomicClasses <|-- FieldUpdaters
    AtomicClasses <|-- AdvancedAtomic
```

</div>
</div>

<Tabs>
  <TabItem value="basic" label="åŸºæœ¬ç±»å‹åŸå­ç±»" default>
  <div className="card">
  <div className="card__body">
  
  **åŒ…å«ç±»ï¼š**
  - **AtomicInteger**ï¼šåŸå­æ•´å‹ï¼Œæä¾›å¯¹intå€¼çš„åŸå­æ“ä½œ
  - **AtomicLong**ï¼šåŸå­é•¿æ•´å‹ï¼Œæä¾›å¯¹longå€¼çš„åŸå­æ“ä½œ
  - **AtomicBoolean**ï¼šåŸå­å¸ƒå°”å‹ï¼Œæä¾›å¯¹booleanå€¼çš„åŸå­æ“ä½œ
  
  **å¸¸ç”¨åœºæ™¯ï¼š**
  - è®¡æ•°å™¨
  - ç”Ÿæˆåºåˆ—å·
  - æ ‡å¿—ä½æ§åˆ¶
  - çŠ¶æ€åˆ‡æ¢
  
  </div>
  </div>
  </TabItem>
  <TabItem value="reference" label="å¼•ç”¨ç±»å‹åŸå­ç±»">
  <div className="card">
  <div className="card__body">
  
  **åŒ…å«ç±»ï¼š**
  - **AtomicReference** `<V>`ï¼šåŸå­æ›´æ–°ä¸€ä¸ªå¯¹è±¡å¼•ç”¨
  - **AtomicStampedReference** `<V>`ï¼šå¸¦æœ‰ç‰ˆæœ¬å·çš„åŸå­å¼•ç”¨ï¼Œè§£å†³ABAé—®é¢˜
  - **AtomicMarkableReference** `<V>`ï¼šå¸¦æœ‰æ ‡è®°çš„åŸå­å¼•ç”¨ï¼Œç”¨äºæ ‡è®°å¼•ç”¨æ˜¯å¦è¢«æ›´æ–°è¿‡
  
  **å¸¸ç”¨åœºæ™¯ï¼š**
  - åŸå­æ›´æ–°å¯¹è±¡
  - è§£å†³CASä¸­çš„ABAé—®é¢˜
  - çŠ¶æ€æ ‡è®°å’Œç‰ˆæœ¬æ§åˆ¶
  
  </div>
  </div>
  </TabItem>
  <TabItem value="array" label="æ•°ç»„ç±»å‹åŸå­ç±»">
  <div className="card">
  <div className="card__body">
  
  **åŒ…å«ç±»ï¼š**
  - **AtomicIntegerArray**ï¼šåŸå­æ•´å‹æ•°ç»„ï¼Œå¯¹int[]æ•°ç»„å…ƒç´ æä¾›åŸå­æ“ä½œ
  - **AtomicLongArray**ï¼šåŸå­é•¿æ•´å‹æ•°ç»„ï¼Œå¯¹long[]æ•°ç»„å…ƒç´ æä¾›åŸå­æ“ä½œ
  - **AtomicReferenceArray**ï¼šåŸå­å¼•ç”¨æ•°ç»„ï¼Œå¯¹å¯¹è±¡æ•°ç»„å…ƒç´ æä¾›åŸå­æ“ä½œ
  
  **å¸¸ç”¨åœºæ™¯ï¼š**
  - å¹¶å‘è®¡æ•°å™¨æ•°ç»„
  - çŠ¶æ€æ•°ç»„
  - é«˜å¹¶å‘ç¯å¢ƒä¸‹çš„æ•°ç»„æ›´æ–°
  
  </div>
  </div>
  </TabItem>
  <TabItem value="updater" label="å­—æ®µæ›´æ–°å™¨">
  <div className="card">
  <div className="card__body">
  
  **åŒ…å«ç±»ï¼š**
  - **AtomicIntegerFieldUpdater**ï¼šåŸå­æ›´æ–°å¯¹è±¡ä¸­intç±»å‹çš„å­—æ®µ
  - **AtomicLongFieldUpdater**ï¼šåŸå­æ›´æ–°å¯¹è±¡ä¸­longç±»å‹çš„å­—æ®µ
  - **AtomicReferenceFieldUpdater**ï¼šåŸå­æ›´æ–°å¯¹è±¡ä¸­å¼•ç”¨ç±»å‹çš„å­—æ®µ
  
  **å¸¸ç”¨åœºæ™¯ï¼š**
  - é¿å…åˆ›å»ºé¢å¤–çš„åŸå­ç±»å®ä¾‹
  - ä¸ºå·²æœ‰ç±»æ·»åŠ åŸå­æ€§æ“ä½œ
  - å‡å°‘å†…å­˜å ç”¨
  
  **é™åˆ¶æ¡ä»¶ï¼š**
  - å­—æ®µå¿…é¡»æ˜¯volatileä¿®é¥°
  - å­—æ®µå¿…é¡»æ˜¯å¯¹æ›´æ–°å™¨å¯è®¿é—®çš„
  - ç±»ä¸èƒ½è¢«åŠ è½½å™¨éšè—
  
  </div>
  </div>
  </TabItem>
</Tabs>

## 2. åŸºæœ¬ç±»å‹åŸå­ç±»

### 2.1 AtomicInteger

<div className="card">
<div className="card__header">
<h4>AtomicIntegeræ ¸å¿ƒAPI</h4>
</div>
<div className="card__body">

| æ–¹æ³• | æè¿° | ç­‰ä»·åŒæ­¥ä»£ç  |
|------|------|-------------|
| **get()** | è·å–å½“å‰å€¼ | `return value;` |
| **set(int)** | è®¾ç½®æ–°å€¼ | `value = newValue;` |
| **getAndSet(int)** | è®¾ç½®æ–°å€¼å¹¶è¿”å›æ—§å€¼ | `int old = value; value = newValue; return old;` |
| **compareAndSet(int, int)** | æ¯”è¾ƒå¹¶è®¾ç½® | `if(value==expect){value=update; return true;} else return false;` |
| **getAndIncrement()** | é€’å¢å¹¶è¿”å›æ—§å€¼ | `int old = value; value++; return old;` |
| **getAndDecrement()** | é€’å‡å¹¶è¿”å›æ—§å€¼ | `int old = value; value--; return old;` |
| **incrementAndGet()** | é€’å¢å¹¶è¿”å›æ–°å€¼ | `return ++value;` |
| **decrementAndGet()** | é€’å‡å¹¶è¿”å›æ–°å€¼ | `return --value;` |
| **getAndAdd(int)** | åŠ ä¸ŠæŒ‡å®šå€¼å¹¶è¿”å›æ—§å€¼ | `int old = value; value += delta; return old;` |
| **addAndGet(int)** | åŠ ä¸ŠæŒ‡å®šå€¼å¹¶è¿”å›æ–°å€¼ | `value += delta; return value;` |
| **updateAndGet(IntUnaryOp)** | åº”ç”¨å‡½æ•°å¹¶è¿”å›æ–°å€¼ | `value = updateFunction(value); return value;` |
| **getAndUpdate(IntUnaryOp)** | åº”ç”¨å‡½æ•°å¹¶è¿”å›æ—§å€¼ | `int old = value; value = updateFunction(value); return old;` |

</div>
</div>

<Tabs>
  <TabItem value="basic_ops" label="åŸºæœ¬æ“ä½œ" default>
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  
  // åˆ›å»ºAtomicInteger
  AtomicInteger counter = new AtomicInteger(); // é»˜è®¤å€¼ä¸º0
  AtomicInteger initializedCounter = new AtomicInteger(100); // åˆå§‹å€¼ä¸º100
  
  // è·å–å½“å‰å€¼
  int current = counter.get(); // 0
  
  // è®¾ç½®å€¼
  counter.set(50);
  System.out.println(counter.get()); // 50
  
  // åŸå­é€’å¢/é€’å‡
  int prev = counter.getAndIncrement(); // è¿”å›50ï¼Œcounterå˜ä¸º51
  int next = counter.incrementAndGet(); // counterå˜ä¸º52ï¼Œè¿”å›52
  
  int prev2 = counter.getAndDecrement(); // è¿”å›52ï¼Œcounterå˜ä¸º51
  int next2 = counter.decrementAndGet(); // counterå˜ä¸º50ï¼Œè¿”å›50
  
  // åŸå­åŠ æ³•/å‡æ³•
  int beforeAdd = counter.getAndAdd(15); // è¿”å›50ï¼Œcounterå˜ä¸º65
  int afterAdd = counter.addAndGet(10); // counterå˜ä¸º75ï¼Œè¿”å›75
  
  // æ¯”è¾ƒå¹¶è®¾ç½®
  boolean success = counter.compareAndSet(75, 100); // å¦‚æœå½“å‰å€¼æ˜¯75ï¼Œåˆ™è®¾ä¸º100
  System.out.println(success + ", å½“å‰å€¼: " + counter.get()); // true, å½“å‰å€¼: 100
  ```
  </TabItem>
  <TabItem value="advanced_ops" label="é«˜çº§æ“ä½œ">
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.function.IntUnaryOperator;
  
  AtomicInteger value = new AtomicInteger(10);
  
  // ä½¿ç”¨å‡½æ•°å¼æ¥å£æ›´æ–°
  // ç›¸å½“äºï¼švalue = value * 2
  int doubled = value.updateAndGet(x -> x * 2); 
  System.out.println(doubled); // 20
  
  // ç›¸å½“äºï¼šoldValue = value; value = value + 5; return oldValue;
  int oldValue = value.getAndUpdate(x -> x + 5); 
  System.out.println("æ—§å€¼: " + oldValue + ", æ–°å€¼: " + value.get()); // æ—§å€¼: 20, æ–°å€¼: 25
  
  // ç´¯ç§¯æ“ä½œ
  // ç›¸å½“äºï¼švalue = value + 3 * 2
  int result = value.accumulateAndGet(3, (x, y) -> x + y * 2);
  System.out.println(result); // 31 (25 + 3*2)
  
  // è‡ªå®šä¹‰å‡½æ•°
  IntUnaryOperator powerOfTwo = x -> x * x;
  int squared = value.updateAndGet(powerOfTwo);
  System.out.println(squared); // 961 (31^2)
  ```
  </TabItem>
  <TabItem value="counter_example" label="è®¡æ•°å™¨ç¤ºä¾‹">
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  import java.util.concurrent.TimeUnit;
  
  public class AtomicCounter {
      private final AtomicInteger count = new AtomicInteger(0);
      
      // çº¿ç¨‹å®‰å…¨çš„å¢åŠ æ–¹æ³•
      public void increment() {
          count.incrementAndGet();
      }
      
      // çº¿ç¨‹å®‰å…¨çš„è·å–æ–¹æ³•
      public int getCount() {
          return count.get();
      }
      
      public static void main(String[] args) throws InterruptedException {
          final AtomicCounter counter = new AtomicCounter();
          ExecutorService executor = Executors.newFixedThreadPool(10);
          
          // åˆ›å»º100ä¸ªä»»åŠ¡ï¼Œæ¯ä¸ªä»»åŠ¡å¢åŠ è®¡æ•°å™¨1000æ¬¡
          for (int i = 0; i < 100; i++) {
              executor.submit(() -> {
                  for (int j = 0; j < 1000; j++) {
                      counter.increment();
                  }
              });
          }
          
          // å…³é—­çº¿ç¨‹æ± å¹¶ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
          executor.shutdown();
          executor.awaitTermination(10, TimeUnit.SECONDS);
          
          // è¾“å‡ºæœ€ç»ˆè®¡æ•°ï¼Œåº”è¯¥ä¸º100,000
          System.out.println("Final count: " + counter.getCount());
      }
  }
  ```
  </TabItem>
  <TabItem value="cas_spin" label="è‡ªæ—‹CAS">
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  
  public class CASExample {
      private final AtomicInteger value = new AtomicInteger(0);
      
      // ä½¿ç”¨CASæ‰‹åŠ¨å®ç°è‡ªæ—‹é€’å¢
      public void incrementWithCAS() {
          int oldValue;
          int newValue;
          do {
              // è¯»å–å½“å‰å€¼
              oldValue = value.get();
              newValue = oldValue + 1;
              // å°è¯•CASæ“ä½œï¼Œå¤±è´¥åˆ™é‡è¯•
          } while (!value.compareAndSet(oldValue, newValue));
      }
      
      // æ¡ä»¶æ›´æ–° - åªæœ‰å½“å€¼ä¸ºå¶æ•°æ—¶æ‰é€’å¢
      public boolean incrementIfEven() {
          while (true) {
              int current = value.get();
              if (current % 2 != 0) {
                  return false; // ä¸æ˜¯å¶æ•°ï¼Œæ”¾å¼ƒæ“ä½œ
              }
              
              int next = current + 1;
              if (value.compareAndSet(current, next)) {
                  return true; // CASæˆåŠŸ
              }
              // CASå¤±è´¥ï¼Œé‡è¯•
          }
      }
  }
  ```
  </TabItem>
</Tabs>

### 2.2 AtomicLong

<div className="card">
<div className="card__header">
<h4>AtomicLongç‰¹æ€§</h4>
</div>
<div className="card__body">

**æ ¸å¿ƒç‰¹ç‚¹ï¼š**
- æä¾›å¯¹longç±»å‹å˜é‡çš„åŸå­æ“ä½œ
- 64ä½åŸå­æ“ä½œï¼Œè§£å†³åœ¨32ä½ç³»ç»Ÿä¸Šlong/doubleæ“ä½œéåŸå­æ€§é—®é¢˜
- JDK 8åå†…éƒ¨ä¼˜åŒ–ä½¿ç”¨äº†CPUçš„CASæŒ‡ä»¤
- é«˜å¹¶å‘åœºæ™¯å¯è€ƒè™‘ä½¿ç”¨LongAdderæ›¿ä»£ä»¥æé«˜æ€§èƒ½

**åº”ç”¨åœºæ™¯ï¼š**
- å…¨å±€åºåˆ—å·ç”Ÿæˆ
- å¤§æ•°é‡è®¡æ•°
- é«˜ç²¾åº¦ç»Ÿè®¡
- IDç”Ÿæˆå™¨

</div>
</div>

<Tabs>
  <TabItem value="basic_long" label="åŸºæœ¬ç”¨æ³•" default>
  ```java
  import java.util.concurrent.atomic.AtomicLong;
  
  // åˆ›å»ºAtomicLong
  AtomicLong counter = new AtomicLong(0); // åˆå§‹å€¼ä¸º0
  AtomicLong idGenerator = new AtomicLong(1000); // åˆå§‹å€¼ä¸º1000
  
  // åŸºæœ¬æ“ä½œ
  long currentValue = counter.get(); // è·å–å½“å‰å€¼
  counter.set(100); // è®¾ç½®æ–°å€¼
  
  // åŸå­å¢å‡
  long oldValue = counter.getAndIncrement(); // è¿”å›0, counterå˜ä¸º1
  long newValue = counter.incrementAndGet(); // counterå˜ä¸º2, è¿”å›2
  
  // åŸå­æ›´æ–°
  oldValue = counter.getAndAdd(10); // è¿”å›2, counterå˜ä¸º12
  newValue = counter.addAndGet(8);  // counterå˜ä¸º20, è¿”å›20
  
  // CASæ“ä½œ
  boolean updated = counter.compareAndSet(20, 30); // true, counterå˜ä¸º30
  ```
  </TabItem>
  <TabItem value="id_generator" label="IDç”Ÿæˆå™¨">
  ```java
  import java.util.concurrent.atomic.AtomicLong;
  
  /**
   * ç®€å•çš„åˆ†å¸ƒå¼IDç”Ÿæˆå™¨
   * - æ”¯æŒå¤šçº¿ç¨‹å®‰å…¨åœ°ç”Ÿæˆå”¯ä¸€ID
   * - å¯æŒ‡å®šèµ·å§‹å€¼å’Œæ­¥é•¿
   */
  public class AtomicIdGenerator {
      private final AtomicLong sequenceNumber;
      private final String nodePrefix;
      private final int step;
      
      /**
       * åˆ›å»ºIDç”Ÿæˆå™¨
       * @param nodeId èŠ‚ç‚¹ID (0-99)
       * @param startValue èµ·å§‹å€¼
       * @param step æ­¥é•¿
       */
      public AtomicIdGenerator(int nodeId, long startValue, int step) {
          // ä¿è¯èŠ‚ç‚¹IDä¸º2ä½æ•°å­—
          this.nodePrefix = String.format("%02d", nodeId % 100);
          this.sequenceNumber = new AtomicLong(startValue);
          this.step = step;
      }
      
      /**
       * ç”Ÿæˆä¸‹ä¸€ä¸ªID
       * æ ¼å¼: èŠ‚ç‚¹å‰ç¼€ + å½“å‰æ—¶é—´æˆ³ + åºåˆ—å·
       */
      public String nextId() {
          long timestamp = System.currentTimeMillis();
          long sequence = sequenceNumber.getAndAdd(step);
          return nodePrefix + timestamp + sequence;
      }
      
      /**
       * æ‰¹é‡ç”ŸæˆID
       */
      public String[] batchIds(int batchSize) {
          String[] ids = new String[batchSize];
          for (int i = 0; i < batchSize; i++) {
              ids[i] = nextId();
          }
          return ids;
      }
      
      /**
       * è·å–å½“å‰åºåˆ—å·
       */
      public long getCurrentSequence() {
          return sequenceNumber.get();
      }
      
      /**
       * é‡ç½®åºåˆ—å·
       */
      public void reset(long newValue) {
          sequenceNumber.set(newValue);
      }
  }
  
  // ä½¿ç”¨ç¤ºä¾‹
  AtomicIdGenerator idGen = new AtomicIdGenerator(1, 1000, 1);
  String id1 = idGen.nextId();
  String id2 = idGen.nextId();
  System.out.println("ID1: " + id1);
  System.out.println("ID2: " + id2);
  ```
  </TabItem>
  <TabItem value="perf_monitor" label="æ€§èƒ½ç›‘æ§">
  ```java
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.TimeUnit;
  
  /**
   * é«˜æ€§èƒ½ç»Ÿè®¡ç›‘æ§ç±»
   */
  public class PerformanceMonitor {
      private final AtomicLong requestCount = new AtomicLong(0);
      private final AtomicLong errorCount = new AtomicLong(0);
      private final AtomicLong totalResponseTime = new AtomicLong(0);
      private final AtomicLong minResponseTime = new AtomicLong(Long.MAX_VALUE);
      private final AtomicLong maxResponseTime = new AtomicLong(0);
      private final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());
      
      /**
       * è®°å½•è¯·æ±‚
       */
      public void recordRequest(long responseTimeMs, boolean isSuccess) {
          requestCount.incrementAndGet();
          totalResponseTime.addAndGet(responseTimeMs);
          
          // æ›´æ–°æœ€å°å“åº”æ—¶é—´ (CASè‡ªæ—‹æ–¹å¼)
          while (true) {
              long currentMin = minResponseTime.get();
              if (responseTimeMs >= currentMin) break; // å½“å‰å€¼ä¸æ˜¯æœ€å°å€¼
              if (minResponseTime.compareAndSet(currentMin, responseTimeMs)) break;
          }
          
          // æ›´æ–°æœ€å¤§å“åº”æ—¶é—´
          while (true) {
              long currentMax = maxResponseTime.get();
              if (responseTimeMs <= currentMax) break; // å½“å‰å€¼ä¸æ˜¯æœ€å¤§å€¼
              if (maxResponseTime.compareAndSet(currentMax, responseTimeMs)) break;
          }
          
          if (!isSuccess) {
              errorCount.incrementAndGet();
          }
      }
      
      /**
       * è·å–ç›‘æ§æŠ¥å‘Š
       */
      public MonitorReport getReport() {
          long requests = requestCount.get();
          long errors = errorCount.get();
          long totalTime = totalResponseTime.get();
          long minTime = minResponseTime.get();
          long maxTime = maxResponseTime.get();
          long uptime = System.currentTimeMillis() - startTime.get();
          
          return new MonitorReport(
              requests,
              errors,
              requests > 0 ? totalTime / requests : 0,
              minTime == Long.MAX_VALUE ? 0 : minTime,
              maxTime,
              uptime
          );
      }
      
      /**
       * é‡ç½®ç»Ÿè®¡æ•°æ®
       */
      public void reset() {
          requestCount.set(0);
          errorCount.set(0);
          totalResponseTime.set(0);
          minResponseTime.set(Long.MAX_VALUE);
          maxResponseTime.set(0);
          startTime.set(System.currentTimeMillis());
      }
      
      public static class MonitorReport {
          public final long totalRequests;
          public final long errorRequests;
          public final long avgResponseTime;
          public final long minResponseTime;
          public final long maxResponseTime;
          public final long uptime;
          
          public MonitorReport(
                  long totalRequests, long errorRequests, 
                  long avgResponseTime, long minResponseTime, 
                  long maxResponseTime, long uptime) {
              this.totalRequests = totalRequests;
              this.errorRequests = errorRequests;
              this.avgResponseTime = avgResponseTime;
              this.minResponseTime = minResponseTime;
              this.maxResponseTime = maxResponseTime;
              this.uptime = uptime;
          }
          
          @Override
          public String toString() {
              return String.format(
                  "è¯·æ±‚æ€»æ•°: %d, é”™è¯¯: %d (%.2f%%), å¹³å‡å“åº”æ—¶é—´: %dms, " +
                  "æœ€å°: %dms, æœ€å¤§: %dms, è¿è¡Œæ—¶é—´: %ds",
                  totalRequests,
                  errorRequests,
                  totalRequests > 0 ? (errorRequests * 100.0 / totalRequests) : 0.0,
                  avgResponseTime,
                  minResponseTime,
                  maxResponseTime,
                  TimeUnit.MILLISECONDS.toSeconds(uptime)
              );
          }
      }
  }
  ```
  </TabItem>
</Tabs>

### 2.3 AtomicBoolean

<div className="card">
<div className="card__header">
<h4>AtomicBooleanç‰¹æ€§ä¸åº”ç”¨</h4>
</div>
<div className="card__body">

**ä¸»è¦ç‰¹ç‚¹ï¼š**
- åŸå­æ€§åœ°æ›´æ–°booleanç±»å‹å€¼
- é€‚åˆçŠ¶æ€æ ‡å¿—å’Œå¼€å…³æ§åˆ¶åœºæ™¯
- çº¿ç¨‹å®‰å…¨çš„åˆå§‹åŒ–æ ‡è®°
- åŸå­å¼€å…³æ“ä½œ

**å¸¸ç”¨æ–¹æ³•ï¼š**
- `get()`: è·å–å½“å‰å€¼
- `set(boolean)`: è®¾ç½®æ–°å€¼
- `getAndSet(boolean)`: è®¾ç½®æ–°å€¼å¹¶è¿”å›æ—§å€¼
- `compareAndSet(boolean, boolean)`: æ¯”è¾ƒå¹¶è®¾ç½®

**å…¸å‹åº”ç”¨åœºæ™¯ï¼š**
- ä¸€æ¬¡æ€§æ“ä½œæ ‡å¿—
- æœåŠ¡å¼€å…³æ§åˆ¶
- çº¿ç¨‹å®‰å…¨çš„åˆå§‹åŒ–
- çŠ¶æ€æ ‡è®°

</div>
</div>

<Tabs>
  <TabItem value="basic_boolean" label="åŸºæœ¬ä½¿ç”¨" default>
  ```java
  import java.util.concurrent.atomic.AtomicBoolean;
  
  // åˆ›å»ºAtomicBooleanï¼Œé»˜è®¤false
  AtomicBoolean flag = new AtomicBoolean();
  
  // åˆ›å»ºå¸¦åˆå§‹å€¼çš„AtomicBoolean
  AtomicBoolean enabledFlag = new AtomicBoolean(true);
  
  // è·å–å½“å‰å€¼
  boolean isEnabled = enabledFlag.get(); // true
  
  // è®¾ç½®æ–°å€¼
  enabledFlag.set(false);
  
  // åŸå­åœ°è·å–æ—§å€¼å¹¶è®¾ç½®æ–°å€¼
  boolean oldValue = enabledFlag.getAndSet(true);
  System.out.println("æ—§å€¼: " + oldValue + ", æ–°å€¼: " + enabledFlag.get());
  // è¾“å‡º: æ—§å€¼: false, æ–°å€¼: true
  
  // CASæ“ä½œ
  boolean wasUpdated = enabledFlag.compareAndSet(true, false);
  System.out.println("æ›´æ–°æˆåŠŸ: " + wasUpdated + ", å½“å‰å€¼: " + enabledFlag.get());
  // è¾“å‡º: æ›´æ–°æˆåŠŸ: true, å½“å‰å€¼: false
  ```
  </TabItem>
  <TabItem value="onetime_action" label="ä¸€æ¬¡æ€§æ“ä½œ">
  ```java
  import java.util.concurrent.atomic.AtomicBoolean;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  /**
   * ä½¿ç”¨AtomicBooleanç¡®ä¿æŸæ“ä½œåªæ‰§è¡Œä¸€æ¬¡
   */
  public class OneTimeAction {
      private final AtomicBoolean initialized = new AtomicBoolean(false);
      
      /**
       * ç¡®ä¿åªåˆå§‹åŒ–ä¸€æ¬¡
       */
      public void initialize() {
          // compareAndSetæ–¹æ³•åŸå­æ€§åœ°æ£€æŸ¥å’Œæ›´æ–°å€¼ï¼Œç¡®ä¿åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ‰§è¡Œåˆå§‹åŒ–
          if (initialized.compareAndSet(false, true)) {
              try {
                  System.out.println("æ‰§è¡Œåˆå§‹åŒ–æ“ä½œ - ç”±çº¿ç¨‹ " + 
                      Thread.currentThread().getName());
                  
                  // æ¨¡æ‹Ÿè€—æ—¶çš„åˆå§‹åŒ–æ“ä½œ
                  Thread.sleep(1000);
                  
                  System.out.println("åˆå§‹åŒ–å®Œæˆ");
              } catch (InterruptedException e) {
                  // å¦‚æœåˆå§‹åŒ–å¤±è´¥ï¼Œé‡ç½®æ ‡å¿—
                  initialized.set(false);
                  Thread.currentThread().interrupt();
              }
          } else {
              System.out.println("å·²åˆå§‹åŒ– - çº¿ç¨‹ " + 
                  Thread.currentThread().getName() + " è·³è¿‡");
          }
      }
      
      /**
       * æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
       */
      public boolean isInitialized() {
          return initialized.get();
      }
      
      /**
       * é‡ç½®åˆå§‹åŒ–çŠ¶æ€
       */
      public void reset() {
          initialized.set(false);
      }
      
      public static void main(String[] args) {
          final OneTimeAction action = new OneTimeAction();
          ExecutorService executor = Executors.newFixedThreadPool(5);
          
          // å¤šä¸ªçº¿ç¨‹åŒæ—¶å°è¯•åˆå§‹åŒ–
          for (int i = 0; i < 10; i++) {
              executor.submit(action::initialize);
          }
          
          executor.shutdown();
      }
  }
  ```
  </TabItem>
  <TabItem value="circuit_breaker" label="ç†”æ–­å™¨å®ç°">
  ```java
  import java.util.concurrent.atomic.AtomicBoolean;
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
  
  /**
   * ç®€å•çš„ç†”æ–­å™¨å®ç°
   */
  public class CircuitBreaker {
      private final AtomicBoolean open = new AtomicBoolean(false);
      private final AtomicInteger failureCount = new AtomicInteger(0);
      private final AtomicLong lastFailureTime = new AtomicLong(0);
      
      private final int failureThreshold;
      private final long resetTimeoutMs;
      
      public CircuitBreaker(int failureThreshold, long resetTimeoutMs) {
          this.failureThreshold = failureThreshold;
          this.resetTimeoutMs = resetTimeoutMs;
      }
      
      /**
       * æ£€æŸ¥ç†”æ–­å™¨æ˜¯å¦æ‰“å¼€
       */
      public boolean isOpen() {
          // å·²ç»æ‰“å¼€çš„æƒ…å†µä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥å°è¯•å…³é—­
          if (open.get()) {
              // è¶…è¿‡é‡ç½®æ—¶é—´åå…è®¸å°è¯•æ¢å¤
              long currentTime = System.currentTimeMillis();
              if (currentTime - lastFailureTime.get() > resetTimeoutMs) {
                  // é‡ç½®ä¸ºå…³é—­çŠ¶æ€(åŠå¼€çŠ¶æ€)
                  open.compareAndSet(true, false);
                  return false;
              }
              return true;
          }
          return false;
      }
      
      /**
       * è®°å½•æˆåŠŸ
       */
      public void recordSuccess() {
          // æˆåŠŸåé‡ç½®å¤±è´¥è®¡æ•°
          failureCount.set(0);
          // å¦‚æœå¤„äºåŠå¼€çŠ¶æ€ï¼Œç¡®ä¿å…³é—­ç†”æ–­å™¨
          open.set(false);
      }
      
      /**
       * è®°å½•å¤±è´¥
       */
      public void recordFailure() {
          // è®°å½•æœ€åå¤±è´¥æ—¶é—´
          lastFailureTime.set(System.currentTimeMillis());
          
          // å¢åŠ å¤±è´¥è®¡æ•°
          int currentFailures = failureCount.incrementAndGet();
          
          // å¦‚æœè¾¾åˆ°é˜ˆå€¼ï¼Œæ‰“å¼€ç†”æ–­å™¨
          if (currentFailures >= failureThreshold) {
              open.set(true);
          }
      }
      
      /**
       * æ‰§è¡Œå—ä¿æŠ¤çš„ä»£ç 
       */
      public <T> T execute(Supplier<T> supplier, T fallback) {
          if (isOpen()) {
              // ç†”æ–­å™¨æ‰“å¼€ï¼Œç›´æ¥è¿”å›é™çº§ç»“æœ
              return fallback;
          }
          
          try {
              // å°è¯•æ‰§è¡Œæ“ä½œ
              T result = supplier.get();
              recordSuccess();
              return result;
          } catch (Exception e) {
              recordFailure();
              return fallback;
          }
      }
      
      // ç®€å•çš„Supplieræ¥å£
      public interface Supplier<T> {
          T get() throws Exception;
      }
  }
  ```
  </TabItem>
</Tabs>

## 3. å¼•ç”¨ç±»å‹åŸå­ç±»

<div className="card">
<div className="card__header">
<h4>å¼•ç”¨ç±»å‹åŸå­ç±»æ¦‚è¿°</h4>
</div>
<div className="card__body">

å¼•ç”¨ç±»å‹åŸå­ç±»ç”¨äºåŸå­æ€§åœ°æ›´æ–°å¯¹è±¡å¼•ç”¨ï¼Œä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªç±»ï¼š

- **AtomicReference**ï¼šåŸå­æ›´æ–°ä¸€ä¸ªå¯¹è±¡å¼•ç”¨
- **AtomicStampedReference**ï¼šå¸¦æœ‰ç‰ˆæœ¬å·çš„åŸå­å¼•ç”¨ï¼Œè§£å†³ABAé—®é¢˜
- **AtomicMarkableReference**ï¼šå¸¦æœ‰æ ‡è®°çš„åŸå­å¼•ç”¨ï¼Œç”¨äºæ ‡è®°å¼•ç”¨æ˜¯å¦è¢«æ›´æ–°è¿‡

è¿™äº›ç±»ä½¿å¾—åœ¨ä¸ä½¿ç”¨é”çš„æƒ…å†µä¸‹ï¼Œå®‰å…¨åœ°æ›´æ–°å¯¹è±¡å¼•ç”¨æˆä¸ºå¯èƒ½ï¼Œç‰¹åˆ«é€‚åˆäºå®ç°æ— é”æ•°æ®ç»“æ„å’Œç®—æ³•ã€‚

</div>
</div>

### 3.1 AtomicReference

```mermaid
sequenceDiagram
    participant Thread1 as çº¿ç¨‹1
    participant AtomicRef as AtomicReference
    participant Thread2 as çº¿ç¨‹2
    
    Note over AtomicRef: åˆå§‹å€¼: Object A
    
    Thread1->>AtomicRef: get() è·å–å½“å‰å€¼
    AtomicRef-->>Thread1: è¿”å› Object A
    Thread1->>Thread1: è®¡ç®—æ–°å€¼ Object B
    
    Thread2->>AtomicRef: get() è·å–å½“å‰å€¼
    AtomicRef-->>Thread2: è¿”å› Object A
    Thread2->>AtomicRef: CAS(Aâ†’B)
    AtomicRef-->>Thread2: æˆåŠŸï¼Œè¿”å›true
    Note over AtomicRef: å½“å‰å€¼: Object B
    
    Thread2->>AtomicRef: get() è·å–å½“å‰å€¼
    AtomicRef-->>Thread2: è¿”å› Object B
    Thread2->>AtomicRef: CAS(Bâ†’C)
    AtomicRef-->>Thread2: å¤±è´¥ï¼Œè¿”å›false
    Note over Thread2: éœ€è¦é‡è¯•æˆ–å¤„ç†å¤±è´¥
```

<Tabs>
  <TabItem value="atomic_ref_basic" label="åŸºæœ¬ç”¨æ³•" default>
  ```java
  import java.util.concurrent.atomic.AtomicReference;
  
  // åˆ›å»ºå¸¦åˆå§‹å€¼çš„AtomicReference
  AtomicReference<String> atomicString = new AtomicReference<>("åˆå§‹å€¼");
  
  // åˆ›å»ºç©ºçš„AtomicReference
  AtomicReference<User> atomicUser = new AtomicReference<>();
  
  // è·å–å¼•ç”¨
  String value = atomicString.get();
  System.out.println("å½“å‰å€¼: " + value); // å½“å‰å€¼: åˆå§‹å€¼
  
  // è®¾ç½®æ–°å€¼
  atomicString.set("æ–°å€¼");
  System.out.println("æ›´æ–°å: " + atomicString.get()); // æ›´æ–°å: æ–°å€¼
  
  // åŸå­æ–¹å¼è·å–å¹¶è®¾ç½®
  String oldValue = atomicString.getAndSet("æ›´æ–°çš„å€¼");
  System.out.println("æ—§å€¼: " + oldValue + ", å½“å‰å€¼: " + atomicString.get());
  // è¾“å‡º: æ—§å€¼: æ–°å€¼, å½“å‰å€¼: æ›´æ–°çš„å€¼
  
  // æ¯”è¾ƒå¹¶è®¾ç½®
  boolean wasUpdated = atomicString.compareAndSet("æ›´æ–°çš„å€¼", "æœ€ç»ˆå€¼");
  System.out.println("æ›´æ–°æ˜¯å¦æˆåŠŸ: " + wasUpdated + ", å½“å‰å€¼: " + atomicString.get());
  // è¾“å‡º: æ›´æ–°æ˜¯å¦æˆåŠŸ: true, å½“å‰å€¼: æœ€ç»ˆå€¼
  
  // ä½¿ç”¨å‡½æ•°æ›´æ–°
  atomicString.updateAndGet(current -> current + " - é™„åŠ å†…å®¹");
  System.out.println("å‡½æ•°æ›´æ–°å: " + atomicString.get());
  // è¾“å‡º: å‡½æ•°æ›´æ–°å: æœ€ç»ˆå€¼ - é™„åŠ å†…å®¹
  ```
  </TabItem>
  <TabItem value="atomic_ref_object" label="å¯¹è±¡å¼•ç”¨">
  ```java
  import java.util.concurrent.atomic.AtomicReference;
  
  class User {
      private final String name;
      private final int age;
      
      public User(String name, int age) {
          this.name = name;
          this.age = age;
      }
      
      public User withAge(int newAge) {
          return new User(this.name, newAge);
      }
      
      @Override
      public String toString() {
          return "User{name='" + name + "', age=" + age + "}";
      }
  }
  
  // åˆ›å»ºä¸€ä¸ªç”¨æˆ·çš„åŸå­å¼•ç”¨
  AtomicReference<User> userRef = new AtomicReference<>(new User("å¼ ä¸‰", 20));
  
  // æ‰“å°å½“å‰ç”¨æˆ·
  System.out.println("å½“å‰ç”¨æˆ·: " + userRef.get());
  
  // åŸå­åœ°æ›´æ–°ç”¨æˆ·å¹´é¾„ - ä½¿ç”¨CASæ“ä½œ
  User user;
  User newUser;
  do {
      user = userRef.get();
      newUser = user.withAge(user.age + 1);
  } while (!userRef.compareAndSet(user, newUser));
  
  System.out.println("æ›´æ–°åç”¨æˆ·: " + userRef.get());
  
  // ä½¿ç”¨å‡½æ•°å¼æ›´æ–°
  userRef.updateAndGet(u -> u.withAge(u.age + 5));
  System.out.println("å‡½æ•°æ›´æ–°å: " + userRef.get());
  ```
  </TabItem>
  <TabItem value="atomic_ref_state" label="çŠ¶æ€ç®¡ç†">
  ```java
  import java.util.concurrent.atomic.AtomicReference;
  import java.util.concurrent.TimeUnit;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  /**
   * ä½¿ç”¨AtomicReferenceå®ç°çŠ¶æ€æœº
   */
  public class StateMachine {
      // å®šä¹‰å¯èƒ½çš„çŠ¶æ€
      public enum State {
          INITIALIZING, RUNNING, PAUSED, SHUTTING_DOWN, TERMINATED
      }
      
      private final AtomicReference<State> state = 
          new AtomicReference<>(State.INITIALIZING);
      
      /**
       * å°è¯•è½¬æ¢çŠ¶æ€
       * @param from æœŸæœ›çš„å½“å‰çŠ¶æ€
       * @param to ç›®æ ‡çŠ¶æ€
       * @return æ˜¯å¦è½¬æ¢æˆåŠŸ
       */
      public boolean transitionState(State from, State to) {
          return state.compareAndSet(from, to);
      }
      
      /**
       * è·å–å½“å‰çŠ¶æ€
       */
      public State getState() {
          return state.get();
      }
      
      public static void main(String[] args) throws InterruptedException {
          StateMachine machine = new StateMachine();
          ExecutorService executor = Executors.newFixedThreadPool(2);
          
          // ä»»åŠ¡1: åˆå§‹åŒ–åè¿è¡Œ
          executor.submit(() -> {
              if (machine.transitionState(State.INITIALIZING, State.RUNNING)) {
                  System.out.println("æˆåŠŸå¯åŠ¨!");
              } else {
                  System.out.println("å¯åŠ¨å¤±è´¥!");
              }
          });
          
          // ç»™ä»»åŠ¡1ä¸€ç‚¹æ—¶é—´æ‰§è¡Œ
          TimeUnit.MILLISECONDS.sleep(100);
          
          // ä»»åŠ¡2: å°è¯•æš‚åœ
          executor.submit(() -> {
              if (machine.transitionState(State.RUNNING, State.PAUSED)) {
                  System.out.println("æˆåŠŸæš‚åœ!");
              } else {
                  System.out.println("æš‚åœå¤±è´¥!");
              }
          });
          
          executor.shutdown();
      }
  }
  ```
  </TabItem>
</Tabs>

### 3.2 AtomicStampedReference

<div className="card">
<div className="card__header">
<h4>ABA é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ</h4>
</div>
<div className="card__body">

**ABAé—®é¢˜æ˜¯æŒ‡ï¼š**
- çº¿ç¨‹1è¯»å–å…±äº«å˜é‡çš„å€¼ä¸ºA
- çº¿ç¨‹2å°†å…±äº«å˜é‡çš„å€¼ä¿®æ”¹ä¸ºBï¼Œç„¶ååˆä¿®æ”¹å›A
- çº¿ç¨‹1è¿›è¡ŒCASæ“ä½œï¼Œå‘ç°å…±äº«å˜é‡çš„å€¼ä»ä¸ºAï¼Œè®¤ä¸ºæ²¡æœ‰è¢«ä¿®æ”¹è¿‡ï¼Œä½†å®é™…ä¸Šå·²ç»ç»å†äº† Aâ†’Bâ†’A çš„å˜åŒ–

**AtomicStampedReferenceé€šè¿‡æ·»åŠ ç‰ˆæœ¬å·è§£å†³ABAé—®é¢˜ï¼š**
- æ¯æ¬¡æ›´æ–°å¼•ç”¨çš„åŒæ—¶æ›´æ–°ç‰ˆæœ¬å·
- CASæ“ä½œåŒæ—¶æ£€æŸ¥å¼•ç”¨å’Œç‰ˆæœ¬å·
- å³ä½¿å¼•ç”¨å€¼ç›¸åŒï¼Œè‹¥ç‰ˆæœ¬å·ä¸åŒï¼ŒCASæ“ä½œä¹Ÿä¼šå¤±è´¥

</div>
</div>

```mermaid
sequenceDiagram
    participant Thread1 as çº¿ç¨‹1
    participant ASR as AtomicStampedReference
    participant Thread2 as çº¿ç¨‹2
    
    Note over ASR: åˆå§‹å€¼: A, ç‰ˆæœ¬: 1
    
    Thread1->>ASR: è¯»å–å½“å‰å€¼å’Œç‰ˆæœ¬å·
    ASR-->>Thread1: è¿”å› A, ç‰ˆæœ¬1
    Thread1->>Thread1: æš‚åœä¸€æ®µæ—¶é—´
    
    Thread2->>ASR: è¯»å–å½“å‰å€¼å’Œç‰ˆæœ¬å·
    ASR-->>Thread2: è¿”å› A, ç‰ˆæœ¬1
    Thread2->>ASR: CAS(Aâ†’B, ç‰ˆæœ¬1â†’2)
    ASR-->>Thread2: æˆåŠŸï¼Œè¿”å›true
    Note over ASR: å½“å‰å€¼: B, ç‰ˆæœ¬: 2
    
    Thread2->>ASR: è¯»å–å½“å‰å€¼å’Œç‰ˆæœ¬å·
    ASR-->>Thread2: è¿”å› B, ç‰ˆæœ¬2
    Thread2->>ASR: CAS(Bâ†’A, ç‰ˆæœ¬2â†’3)
    ASR-->>Thread2: æˆåŠŸï¼Œè¿”å›true
    Note over ASR: å½“å‰å€¼: A, ç‰ˆæœ¬: 3
    
    Thread1->>ASR: CAS(Aâ†’C, ç‰ˆæœ¬1â†’2)
    ASR-->>Thread1: å¤±è´¥ï¼Œç‰ˆæœ¬å·ä¸åŒ¹é…
    Note over Thread1: ç‰ˆæœ¬å·ä¸åŒ¹é…ï¼Œæ£€æµ‹åˆ°ABAé—®é¢˜
```

<Tabs>
  <TabItem value="atomic_stamped_basic" label="åŸºæœ¬ç”¨æ³•" default>
  ```java
  import java.util.concurrent.atomic.AtomicStampedReference;
  
  // åˆ›å»ºAtomicStampedReferenceï¼Œåˆå§‹å¼•ç”¨ä¸º"A"ï¼Œåˆå§‹ç‰ˆæœ¬å·ä¸º1
  AtomicStampedReference<String> asr = 
      new AtomicStampedReference<>("A", 1);
  
  // è¯»å–å½“å‰å¼•ç”¨å’Œç‰ˆæœ¬å·
  int[] stampHolder = new int[1];
  String value = asr.get(stampHolder);
  int stamp = stampHolder[0];
  
  System.out.println("åˆå§‹å€¼: " + value + ", ç‰ˆæœ¬å·: " + stamp);
  
  // æ›´æ–°å¼•ç”¨å’Œç‰ˆæœ¬å·
  boolean success = asr.compareAndSet("A", "B", stamp, stamp + 1);
  System.out.println("æ›´æ–°ç»“æœ: " + success);
  
  // å†æ¬¡è·å–æ–°çš„å¼•ç”¨å’Œç‰ˆæœ¬å·
  value = asr.get(stampHolder);
  stamp = stampHolder[0];
  System.out.println("æ›´æ–°åå€¼: " + value + ", ç‰ˆæœ¬å·: " + stamp);
  
  // å°è¯•ä½¿ç”¨è¿‡æœŸç‰ˆæœ¬å·æ›´æ–°ï¼Œå°†ä¼šå¤±è´¥
  boolean outdatedSuccess = asr.compareAndSet("B", "C", 1, 2);
  System.out.println("ä½¿ç”¨æ—§ç‰ˆæœ¬å·æ›´æ–°ç»“æœ: " + outdatedSuccess);
  
  // ä½¿ç”¨å½“å‰ç‰ˆæœ¬å·æ›´æ–°ï¼Œå°†ä¼šæˆåŠŸ
  boolean currentSuccess = asr.compareAndSet("B", "C", stamp, stamp + 1);
  System.out.println("ä½¿ç”¨å½“å‰ç‰ˆæœ¬å·æ›´æ–°ç»“æœ: " + currentSuccess);
  System.out.println("æœ€ç»ˆå€¼: " + asr.getReference() + ", ç‰ˆæœ¬å·: " + asr.getStamp());
  ```
  </TabItem>
  <TabItem value="aba_solution" label="ABAé—®é¢˜è§£å†³ç¤ºä¾‹">
  ```java
  import java.util.concurrent.atomic.AtomicStampedReference;
  import java.util.concurrent.TimeUnit;
  
  /**
   * ä½¿ç”¨AtomicStampedReferenceè§£å†³ABAé—®é¢˜çš„ç¤ºä¾‹
   */
  public class ABAProblemSolution {
      private static final AtomicStampedReference<Integer> atomicStampedRef = 
          new AtomicStampedReference<>(100, 0);
  
      public static void main(String[] args) throws InterruptedException {
          System.out.println("===== ABAé—®é¢˜è§£å†³ç¤ºä¾‹ =====");
          
          // è·å–åˆå§‹çš„ç‰ˆæœ¬å·
          int initialStamp = atomicStampedRef.getStamp();
          Integer initialRef = atomicStampedRef.getReference();
          System.out.println("åˆå§‹å€¼: " + initialRef + ", åˆå§‹ç‰ˆæœ¬: " + initialStamp);
          
          // çº¿ç¨‹1 - æ¨¡æ‹Ÿè§£å†³ABAé—®é¢˜
          Thread t1 = new Thread(() -> {
              System.out.println("çº¿ç¨‹1ï¼šè¯»å–åˆå§‹å€¼å’Œç‰ˆæœ¬å·");
              int stamp = atomicStampedRef.getStamp();
              Integer ref = atomicStampedRef.getReference();
              
              try {
                  // çº¿ç¨‹1æš‚åœ1ç§’ï¼Œè®©çº¿ç¨‹2å®ŒæˆABAæ“ä½œ
                  TimeUnit.SECONDS.sleep(1);
              } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
              }
              
              System.out.println("çº¿ç¨‹1ï¼šå°è¯•æ›´æ–° 100 -> 101, ç‰ˆæœ¬:" + stamp + " -> " + (stamp + 1));
              boolean success = atomicStampedRef.compareAndSet(
                  100, 101, stamp, stamp + 1);
              
              System.out.println("çº¿ç¨‹1ï¼šCAS " + (success ? "æˆåŠŸ" : "å¤±è´¥") + 
                  ", å½“å‰å€¼: " + atomicStampedRef.getReference() + 
                  ", å½“å‰ç‰ˆæœ¬: " + atomicStampedRef.getStamp());
          });
          
          // çº¿ç¨‹2 - æ¨¡æ‹Ÿé€ æˆABAé—®é¢˜çš„æ“ä½œ
          Thread t2 = new Thread(() -> {
              try {
                  // è®©çº¿ç¨‹1å…ˆè¿è¡Œå¹¶è¯»å–å€¼
                  TimeUnit.MILLISECONDS.sleep(100);
              } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
              }
              
              int stamp = atomicStampedRef.getStamp();
              System.out.println("çº¿ç¨‹2ï¼šå½“å‰ç‰ˆæœ¬ " + stamp);
              
              // 100 -> 200 -> 100ï¼Œåˆ¶é€ ABA
              System.out.println("çº¿ç¨‹2ï¼š100 -> 200");
              atomicStampedRef.compareAndSet(100, 200, stamp, stamp + 1);
              
              System.out.println("çº¿ç¨‹2ï¼šå½“å‰ç‰ˆæœ¬ " + atomicStampedRef.getStamp());
              
              // å†æ”¹å›100
              System.out.println("çº¿ç¨‹2ï¼š200 -> 100");
              atomicStampedRef.compareAndSet(200, 100, 
                  atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + 1);
              
              System.out.println("çº¿ç¨‹2ï¼šå½“å‰ç‰ˆæœ¬ " + atomicStampedRef.getStamp());
          });
          
          t1.start();
          t2.start();
          
          t1.join();
          t2.join();
          
          System.out.println("æœ€ç»ˆå€¼: " + atomicStampedRef.getReference() + 
              ", æœ€ç»ˆç‰ˆæœ¬: " + atomicStampedRef.getStamp());
      }
  }
  ```
  </TabItem>
  <TabItem value="version_control" label="ç‰ˆæœ¬æ§åˆ¶">
  ```java
  import java.util.concurrent.atomic.AtomicStampedReference;
  import java.util.concurrent.ConcurrentHashMap;
  
  /**
   * ä½¿ç”¨AtomicStampedReferenceå®ç°ç®€å•çš„ç‰ˆæœ¬æ§åˆ¶ç¼“å­˜
   */
  public class VersionedCache<K, V> {
      private static class VersionedValue<V> {
          final V value;
          final long timestamp;
          
          VersionedValue(V value, long timestamp) {
              this.value = value;
              this.timestamp = timestamp;
          }
          
          @Override
          public String toString() {
              return value + " (v" + timestamp + ")";
          }
      }
      
      private final ConcurrentHashMap<K, AtomicStampedReference<VersionedValue<V>>> cache = 
          new ConcurrentHashMap<>();
      
      /**
       * è·å–ç¼“å­˜å€¼ï¼Œè¿”å›å€¼å’Œç‰ˆæœ¬å·
       */
      public V get(K key, int[] versionHolder) {
          AtomicStampedReference<VersionedValue<V>> ref = cache.get(key);
          if (ref == null) {
              versionHolder[0] = 0;
              return null;
          }
          
          VersionedValue<V> versionedValue = ref.get(versionHolder);
          return versionedValue != null ? versionedValue.value : null;
      }
      
      /**
       * æ›´æ–°ç¼“å­˜ï¼Œä»…å½“ç‰ˆæœ¬å·åŒ¹é…æ—¶
       * @return æ˜¯å¦æ›´æ–°æˆåŠŸ
       */
      public boolean put(K key, V value, int expectedVersion) {
          long timestamp = System.currentTimeMillis();
          VersionedValue<V> newVersionedValue = new VersionedValue<>(value, timestamp);
          
          AtomicStampedReference<VersionedValue<V>> ref = cache.get(key);
          if (ref == null) {
              if (expectedVersion != 0) {
                  return false;  // æœŸæœ›æœ‰ç‰ˆæœ¬å·ï¼Œä½†å®é™…ä¸å­˜åœ¨
              }
              // é¦–æ¬¡åˆ›å»ºï¼Œç‰ˆæœ¬ä¸º1
              ref = new AtomicStampedReference<>(newVersionedValue, 1);
              AtomicStampedReference<VersionedValue<V>> existing = 
                  cache.putIfAbsent(key, ref);
              return existing == null;
          }
          
          // æ›´æ–°ç°æœ‰å€¼ï¼Œç‰ˆæœ¬å·åŠ 1
          return ref.compareAndSet(
              ref.getReference(), newVersionedValue, expectedVersion, expectedVersion + 1);
      }
      
      /**
       * åˆ é™¤ç¼“å­˜
       * @return æ˜¯å¦åˆ é™¤æˆåŠŸ
       */
      public boolean remove(K key, int expectedVersion) {
          AtomicStampedReference<VersionedValue<V>> ref = cache.get(key);
          if (ref == null) {
              return false;
          }
          
          int[] stampHolder = new int[1];
          ref.get(stampHolder);
          
          if (stampHolder[0] != expectedVersion) {
              return false;  // ç‰ˆæœ¬ä¸åŒ¹é…
          }
          
          return cache.remove(key, ref);
      }
      
      /**
       * è·å–å½“å‰é”®å€¼æ•°é‡
       */
      public int size() {
          return cache.size();
      }
  }
  ```
  </TabItem>
</Tabs>

### 3.3 AtomicMarkableReference

<div className="card">
<div className="card__header">
<h4>AtomicMarkableReferenceä¸AtomicStampedReferenceçš„å¯¹æ¯”</h4>
</div>
<div className="card__body">

| ç‰¹æ€§ | AtomicMarkableReference | AtomicStampedReference |
|------|------------------------|----------------------|
| æ ‡è®°ç±»å‹ | å¸ƒå°”å€¼ï¼ˆæ ‡è®°/æœªæ ‡è®°ï¼‰ | æ•´æ•°ï¼ˆç‰ˆæœ¬å·ï¼‰ |
| å†…å­˜å ç”¨ | è¾ƒå° | è¾ƒå¤§ |
| é€‚ç”¨åœºæ™¯ | åªéœ€è¦æ ‡è®°å¯¹è±¡æ˜¯å¦è¢«ä¿®æ”¹è¿‡ | éœ€è¦å®Œæ•´çš„ç‰ˆæœ¬å†å² |
| è§£å†³ABA | éƒ¨åˆ†è§£å†³ï¼ˆåªèƒ½æ£€æµ‹åˆ°æ˜¯å¦æœ‰è¿‡ä¿®æ”¹ï¼‰ | å®Œå…¨è§£å†³ï¼ˆé€šè¿‡ç‰ˆæœ¬å·åŒºåˆ†ï¼‰ |
| APIå¤æ‚åº¦ | è¾ƒç®€å• | è¾ƒå¤æ‚ |

</div>
</div>

<Tabs>
  <TabItem value="markable_basic" label="åŸºæœ¬ç”¨æ³•" default>
  ```java
  import java.util.concurrent.atomic.AtomicMarkableReference;
  
  // åˆ›å»ºAtomicMarkableReferenceï¼Œåˆå§‹å¼•ç”¨ä¸º"æ•°æ®"ï¼Œåˆå§‹æ ‡è®°ä¸ºfalse
  AtomicMarkableReference<String> amr = 
      new AtomicMarkableReference<>("æ•°æ®", false);
  
  // è·å–å½“å‰å€¼å’Œæ ‡è®°
  boolean[] markHolder = new boolean[1];
  String value = amr.get(markHolder);
  boolean mark = markHolder[0];
  
  System.out.println("åˆå§‹å€¼: " + value + ", æ ‡è®°: " + mark);
  
  // æ›´æ–°å¼•ç”¨å¹¶è®¾ç½®æ ‡è®°
  boolean success = amr.compareAndSet("æ•°æ®", "æ–°æ•°æ®", false, true);
  System.out.println("æ›´æ–°ç»“æœ: " + success);
  
  // å†æ¬¡è·å–å€¼å’Œæ ‡è®°
  value = amr.get(markHolder);
  mark = markHolder[0];
  System.out.println("æ›´æ–°åå€¼: " + value + ", æ ‡è®°: " + mark);
  
  // ä»…æ›´æ–°æ ‡è®°ï¼Œä¸æ›´æ–°å¼•ç”¨
  success = amr.attemptMark("æ–°æ•°æ®", false);
  System.out.println("ä»…æ›´æ–°æ ‡è®°ç»“æœ: " + success);
  System.out.println("æ ‡è®°æ›´æ–°å: " + amr.isMarked());
  ```
  </TabItem>
  <TabItem value="logical_deletion" label="é€»è¾‘åˆ é™¤">
  ```java
  import java.util.concurrent.atomic.AtomicMarkableReference;
  
  /**
   * ä½¿ç”¨AtomicMarkableReferenceå®ç°é“¾è¡¨èŠ‚ç‚¹çš„é€»è¾‘åˆ é™¤
   */
  public class LogicalDeletionExample {
      static class Node {
          String item;
          Node next;
          
          public Node(String item) {
              this.item = item;
          }
          
          @Override
          public String toString() {
              return item;
          }
      }
      
      /**
       * é“¾è¡¨èŠ‚ç‚¹çš„åŒ…è£…ï¼Œå¸¦æœ‰é€»è¾‘åˆ é™¤æ ‡è®°
       */
      static class MarkedNode {
          private final AtomicMarkableReference<Node> reference;
          
          public MarkedNode(Node node) {
              this.reference = new AtomicMarkableReference<>(node, false);
          }
          
          /**
           * è·å–èŠ‚ç‚¹ï¼ˆå¦‚æœæœªè¢«é€»è¾‘åˆ é™¤ï¼‰
           */
          public Node get() {
              boolean[] marked = new boolean[1];
              Node node = reference.get(marked);
              return marked[0] ? null : node;  // å¦‚æœå·²æ ‡è®°åˆ é™¤ï¼Œè¿”å›null
          }
          
          /**
           * é€»è¾‘åˆ é™¤èŠ‚ç‚¹
           */
          public boolean delete() {
              boolean[] marked = new boolean[1];
              Node node = reference.get(marked);
              
              if (marked[0]) {
                  return false;  // å·²ç»è¢«åˆ é™¤
              }
              
              // æ ‡è®°ä¸ºå·²åˆ é™¤
              return reference.compareAndSet(node, node, false, true);
          }
          
          /**
           * æ£€æŸ¥æ˜¯å¦å·²åˆ é™¤
           */
          public boolean isDeleted() {
              return reference.isMarked();
          }
          
          /**
           * æ¢å¤åˆ é™¤çš„èŠ‚ç‚¹ï¼ˆå–æ¶ˆåˆ é™¤æ ‡è®°ï¼‰
           */
          public boolean undelete() {
              boolean[] marked = new boolean[1];
              Node node = reference.get(marked);
              
              if (!marked[0]) {
                  return false;  // æ²¡æœ‰è¢«åˆ é™¤ï¼Œæ— éœ€æ¢å¤
              }
              
              // å–æ¶ˆåˆ é™¤æ ‡è®°
              return reference.compareAndSet(node, node, true, false);
          }
          
          /**
           * æ›´æ–°èŠ‚ç‚¹ï¼ˆå¦‚æœæœªè¢«åˆ é™¤ï¼‰
           */
          public boolean updateIfNotDeleted(Node newNode) {
              boolean[] marked = new boolean[1];
              Node oldNode = reference.get(marked);
              
              if (marked[0]) {
                  return false;  // å·²è¢«åˆ é™¤ï¼Œä¸èƒ½æ›´æ–°
              }
              
              return reference.compareAndSet(oldNode, newNode, false, false);
          }
      }
      
      public static void main(String[] args) {
          Node node = new Node("èŠ‚ç‚¹1");
          MarkedNode markedNode = new MarkedNode(node);
          
          System.out.println("åˆå§‹èŠ‚ç‚¹: " + markedNode.get());
          System.out.println("å·²åˆ é™¤? " + markedNode.isDeleted());
          
          // é€»è¾‘åˆ é™¤èŠ‚ç‚¹
          boolean deleted = markedNode.delete();
          System.out.println("åˆ é™¤æˆåŠŸ? " + deleted);
          System.out.println("å·²åˆ é™¤? " + markedNode.isDeleted());
          System.out.println("è·å–èŠ‚ç‚¹: " + markedNode.get());
          
          // å°è¯•æ›´æ–°å·²åˆ é™¤çš„èŠ‚ç‚¹
          boolean updated = markedNode.updateIfNotDeleted(new Node("èŠ‚ç‚¹2"));
          System.out.println("æ›´æ–°æˆåŠŸ? " + updated);
          
          // æ¢å¤èŠ‚ç‚¹
          boolean undeleted = markedNode.undelete();
          System.out.println("æ¢å¤æˆåŠŸ? " + undeleted);
          System.out.println("å·²åˆ é™¤? " + markedNode.isDeleted());
          System.out.println("è·å–èŠ‚ç‚¹: " + markedNode.get());
          
          // æ›´æ–°å·²æ¢å¤çš„èŠ‚ç‚¹
          updated = markedNode.updateIfNotDeleted(new Node("èŠ‚ç‚¹2"));
          System.out.println("æ›´æ–°æˆåŠŸ? " + updated);
          System.out.println("æ›´æ–°åèŠ‚ç‚¹: " + markedNode.get());
      }
  }
  ```
  </TabItem>
</Tabs>

## 4. æ•°ç»„åŸå­ç±»

<div className="card">
<div className="card__header">
<h4>æ•°ç»„åŸå­ç±»æ¦‚è¿°</h4>
</div>
<div className="card__body">

æ•°ç»„åŸå­ç±»æä¾›å¯¹æ•°ç»„å…ƒç´ çš„åŸå­æ“ä½œï¼Œä¸»è¦åŒ…æ‹¬ï¼š

- **AtomicIntegerArray**ï¼šåŸå­æ›´æ–°æ•´å‹æ•°ç»„é‡Œçš„å…ƒç´ 
- **AtomicLongArray**ï¼šåŸå­æ›´æ–°é•¿æ•´å‹æ•°ç»„é‡Œçš„å…ƒç´ 
- **AtomicReferenceArray**ï¼šåŸå­æ›´æ–°å¼•ç”¨ç±»å‹æ•°ç»„é‡Œçš„å…ƒç´ 

æ•°ç»„åŸå­ç±»ä¿è¯å¯¹æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ çš„æ“ä½œéƒ½æ˜¯åŸå­æ€§çš„ï¼Œä½†ä¸ä¿è¯å¯¹æ•´ä¸ªæ•°ç»„çš„æ“ä½œæ˜¯åŸå­æ€§çš„ã€‚

</div>
</div>

### 4.1 AtomicIntegerArray

```mermaid
sequenceDiagram
    participant Thread1 as çº¿ç¨‹1
    participant AtomicIntArray as AtomicIntegerArray
    participant Thread2 as çº¿ç¨‹2
    
    Note over AtomicIntArray: åˆå§‹å€¼: [0, 0, 0, 0, 0]
    
    Thread1->>AtomicIntArray: get(0) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread1: è¿”å› 0
    Thread1->>Thread1: è®¡ç®—æ–°å€¼ 10
    
    Thread2->>AtomicIntArray: get(1) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread2: è¿”å› 0
    Thread2->>AtomicIntArray: compareAndSet(0, 10, 0, 1)
    AtomicIntArray-->>Thread2: æˆåŠŸï¼Œè¿”å›true
    Note over AtomicIntArray: å½“å‰å€¼: [10, 10, 0, 0, 0]
    
    Thread2->>AtomicIntArray: get(1) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread2: è¿”å› 10
    Thread2->>AtomicIntArray: compareAndSet(10, 20, 1, 2)
    AtomicIntArray-->>Thread2: æˆåŠŸï¼Œè¿”å›true
    Note over AtomicIntArray: å½“å‰å€¼: [10, 20, 0, 0, 0]
    
    Thread1->>AtomicIntArray: get(0) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread1: è¿”å› 10
    Thread1->>AtomicIntArray: incrementAndGet(0)
    AtomicIntArray-->>Thread1: è¿”å› 11
    Note over AtomicIntArray: å½“å‰å€¼: [11, 20, 0, 0, 0]
    
    Thread2->>AtomicIntArray: get(1) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread2: è¿”å› 20
    Thread2->>AtomicIntArray: getAndDecrement(1)
    AtomicIntArray-->>Thread2: è¿”å› 20
    Note over AtomicIntArray: å½“å‰å€¼: [11, 19, 0, 0, 0]
    
    Thread1->>AtomicIntArray: get(0) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread1: è¿”å› 11
    Thread1->>AtomicIntArray: addAndGet(0, 10)
    AtomicIntArray-->>Thread1: è¿”å› 21
    Note over AtomicIntArray: å½“å‰å€¼: [21, 19, 0, 0, 0]
    
    Thread2->>AtomicIntArray: get(0) è·å–å…ƒç´ 
    AtomicIntArray-->>Thread2: è¿”å› 21
    Thread2->>AtomicIntArray: getAndAdd(0, 10)
    AtomicIntArray-->>Thread2: è¿”å› 21
    Note over AtomicIntArray: å½“å‰å€¼: [21, 19, 0, 0, 0]
  ```

<Tabs>
  <TabItem value="atomic_int_array_basic" label="åŸºæœ¬æ“ä½œ" default>
  ```java
  import java.util.concurrent.atomic.AtomicIntegerArray;
  
  // åˆ›å»ºAtomicIntegerArray
  AtomicIntegerArray array = new AtomicIntegerArray(5); // é»˜è®¤å€¼ä¸º0
  AtomicIntegerArray initializedArray = new AtomicIntegerArray(new int[]{1, 2, 3, 4, 5}); // åˆå§‹å€¼
  
  // è·å–å…ƒç´ 
  int value = array.get(0); // 0
  System.out.println("array[0]: " + value);
  
  // è®¾ç½®å…ƒç´ 
  array.set(0, 10);
  System.out.println("array[0] after set: " + array.get(0)); // 10
  
  // åŸå­é€’å¢/é€’å‡
  int prev = array.getAndIncrement(1); // è¿”å›2, array[1]å˜ä¸º3
  int next = array.incrementAndGet(1); // array[1]å˜ä¸º4, è¿”å›4
  
  prev = array.getAndDecrement(1); // è¿”å›4, array[1]å˜ä¸º3
  next = array.decrementAndGet(1); // array[1]å˜ä¸º2, è¿”å›2
  
  // åŸå­åŠ æ³•/å‡æ³•
  prev = array.getAndAdd(2, 15); // è¿”å›3, array[2]å˜ä¸º18
  next = array.addAndGet(2, 10); // array[2]å˜ä¸º28, è¿”å›28
  
  // æ¯”è¾ƒå¹¶è®¾ç½®
  boolean success = array.compareAndSet(2, 28, 30); // å¦‚æœå½“å‰å€¼æ˜¯28ï¼Œåˆ™è®¾ä¸º30
  System.out.println("CASæˆåŠŸ: " + success + ", array[2]: " + array.get(2)); // true, array[2]: 30
  ```
  </TabItem>
  <TabItem value="atomic_int_array_batch" label="æ‰¹é‡æ“ä½œ">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerArray;
  
  // åˆ›å»ºAtomicIntegerArray
  AtomicIntegerArray array = new AtomicIntegerArray(5);
  
  // æ‰¹é‡é€’å¢
  array.getAndAdd(0, 10); // array[0]å˜ä¸º10
  array.getAndAdd(1, 20); // array[1]å˜ä¸º20
  array.getAndAdd(2, 30); // array[2]å˜ä¸º30
  
  // æ‰¹é‡é€’å‡
  array.getAndDecrement(3); // array[3]å˜ä¸º-1
  array.getAndDecrement(4); // array[4]å˜ä¸º-2
  
  // æ‰¹é‡åŠ æ³•
  array.addAndGet(0, 5); // array[0]å˜ä¸º15
  array.addAndGet(1, 10); // array[1]å˜ä¸º30
  array.addAndGet(2, 15); // array[2]å˜ä¸º45
  
  // æ‰¹é‡æ¯”è¾ƒå¹¶è®¾ç½®
  boolean[] successFlags = new boolean[5];
  successFlags[0] = array.compareAndSet(0, 15, 20); // false
  successFlags[1] = array.compareAndSet(1, 30, 35); // true
  successFlags[2] = array.compareAndSet(2, 45, 50); // true
  successFlags[3] = array.compareAndSet(3, -1, 0); // true
  successFlags[4] = array.compareAndSet(4, -2, -3); // true
  
  System.out.println("æ‰¹é‡æ“ä½œåæ•°ç»„: " + array);
  for (int i = 0; i < successFlags.length; i++) {
      System.out.println("array[" + i + "] CASæˆåŠŸ: " + successFlags[i]);
  }
  ```
  </TabItem>
  <TabItem value="atomic_int_array_example" label="è®¡æ•°å™¨æ•°ç»„ç¤ºä¾‹">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerArray;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  import java.util.concurrent.TimeUnit;
  
  /**
   * ä½¿ç”¨AtomicIntegerArrayå®ç°å¹¶å‘è®¡æ•°å™¨æ•°ç»„
   */
  public class AtomicCounterArray {
      private final AtomicIntegerArray counters;
      
      public AtomicCounterArray(int size) {
          this.counters = new AtomicIntegerArray(size);
      }
      
      /**
       * é€’å¢æŒ‡å®šç´¢å¼•çš„è®¡æ•°å™¨
       */
      public void increment(int index) {
          counters.incrementAndGet(index);
      }
      
      /**
       * è·å–æŒ‡å®šç´¢å¼•çš„è®¡æ•°å™¨å€¼
       */
      public int get(int index) {
          return counters.get(index);
      }
      
      /**
       * æ‰¹é‡é€’å¢å¤šä¸ªè®¡æ•°å™¨
       */
      public void batchIncrement(int[] indices, int increment) {
          for (int i : indices) {
              counters.addAndGet(i, increment);
          }
      }
      
      /**
       * æ‰¹é‡è·å–å¤šä¸ªè®¡æ•°å™¨å€¼
       */
      public int[] getBatch(int[] indices) {
          int[] values = new int[indices.length];
          for (int i = 0; i < indices.length; i++) {
              values[i] = counters.get(indices[i]);
          }
          return values;
      }
      
      /**
       * é‡ç½®æŒ‡å®šç´¢å¼•çš„è®¡æ•°å™¨
       */
      public void reset(int index) {
          counters.set(index, 0);
      }
      
      /**
       * æ‰¹é‡é‡ç½®å¤šä¸ªè®¡æ•°å™¨
       */
      public void resetBatch(int[] indices) {
          for (int i : indices) {
              counters.set(i, 0);
          }
      }
      
      public static void main(String[] args) throws InterruptedException {
          final AtomicCounterArray counterArray = new AtomicCounterArray(10);
          ExecutorService executor = Executors.newFixedThreadPool(10);
          
          // åˆ›å»º10ä¸ªä»»åŠ¡ï¼Œæ¯ä¸ªä»»åŠ¡é€’å¢æ•°ç»„ä¸­10ä¸ªéšæœºç´¢å¼•çš„è®¡æ•°å™¨1000æ¬¡
          for (int i = 0; i < 10; i++) {
              executor.submit(() -> {
                  int[] indices = new int[10];
                  for (int j = 0; j < indices.length; j++) {
                      indices[j] = (int) (Math.random() * 10); // éšæœºç´¢å¼•
                  }
                  for (int k = 0; k < 1000; k++) {
                      counterArray.increment(indices[k % indices.length]); // é€’å¢éšæœºç´¢å¼•
                  }
              });
          }
          
          executor.shutdown();
          executor.awaitTermination(10, TimeUnit.SECONDS);
          
          // è¾“å‡ºæœ€ç»ˆè®¡æ•°
          System.out.println("æœ€ç»ˆè®¡æ•°æ•°ç»„: " + Arrays.toString(counterArray.getBatch(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9})));
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_int_array_bitmap" label="ä½å›¾å®ç°">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerArray;
  import java.util.Arrays;
  
  /**
   * ä½¿ç”¨AtomicIntegerArrayå®ç°ä½å›¾
   */
  public class AtomicBitmap {
      private final AtomicIntegerArray bits;
      private final int size;
      
      public AtomicBitmap(int size) {
          this.size = size;
          // ç¡®ä¿æ•°ç»„å¤§å°æ˜¯32çš„å€æ•°ï¼Œæˆ–è€…å‘ä¸Šå–æ•´
          this.bits = new AtomicIntegerArray((size + 31) / 32 * 32);
      }
      
      /**
       * è®¾ç½®ä½
       */
      public void set(int index) {
          if (index < 0 || index >= size) {
              throw new IndexOutOfBoundsException("Index out of bounds: " + index);
          }
          
          int arrayIndex = index / 32;
          int bitIndex = index % 32;
          int mask = 1 << bitIndex;
          
          while (true) {
              int current = bits.get(arrayIndex);
              int updated = current | mask;
              if (bits.compareAndSet(arrayIndex, current, updated)) {
                  break;
              }
          }
      }
      
      /**
       * æ¸…é™¤ä½
       */
      public void clear(int index) {
          if (index < 0 || index >= size) {
              throw new IndexOutOfBoundsException("Index out of bounds: " + index);
          }
          
          int arrayIndex = index / 32;
          int bitIndex = index % 32;
          int mask = ~(1 << bitIndex);
          
          while (true) {
              int current = bits.get(arrayIndex);
              int updated = current & mask;
              if (bits.compareAndSet(arrayIndex, current, updated)) {
                  break;
              }
          }
      }
      
      /**
       * è·å–ä½
       */
      public boolean get(int index) {
          if (index < 0 || index >= size) {
              throw new IndexOutOfBoundsException("Index out of bounds: " + index);
          }
          
          int arrayIndex = index / 32;
          int bitIndex = index % 32;
          int mask = 1 << bitIndex;
          
          return (bits.get(arrayIndex) & mask) != 0;
      }
      
      /**
       * è·å–ä½å›¾å¤§å°
       */
      public int size() {
          return size;
      }
      
      /**
       * è·å–ä½å›¾æ•°ç»„
       */
      public AtomicIntegerArray getBits() {
          return bits;
      }
      
      @Override
      public String toString() {
          StringBuilder sb = new StringBuilder();
          for (int i = 0; i < size; i++) {
              sb.append(get(i) ? 1 : 0);
              if ((i + 1) % 8 == 0) sb.append(" ");
              if ((i + 1) % 32 == 0) sb.append("\n");
          }
          return sb.toString();
      }
  }
  ```
  </TabItem>
</Tabs>

## 5. å­—æ®µæ›´æ–°å™¨

### 5.1 å­—æ®µæ›´æ–°å™¨æ¦‚è¿°

å­—æ®µæ›´æ–°å™¨å…è®¸åŸå­æ€§åœ°æ›´æ–°å¯¹è±¡çš„volatileå­—æ®µï¼Œæ— éœ€å°†æ•´ä¸ªå¯¹è±¡å£°æ˜ä¸ºåŸå­ç±»ã€‚

```mermaid
sequenceDiagram
    participant Thread1 as çº¿ç¨‹1
    participant AtomicFieldUpdater as AtomicFieldUpdater
    participant TargetObject as ç›®æ ‡å¯¹è±¡
    
    Note over TargetObject: åˆå§‹å€¼: 100
    
    Thread1->>TargetObject: è·å–å½“å‰å€¼
    TargetObject-->>Thread1: è¿”å› 100
    Thread1->>Thread1: è®¡ç®—æ–°å€¼ 101
    
    Thread1->>AtomicFieldUpdater: compareAndSet(100, 101)
    AtomicFieldUpdater-->>Thread1: æˆåŠŸï¼Œè¿”å›true
    Note over TargetObject: å½“å‰å€¼: 101
    
    Thread1->>TargetObject: è·å–å½“å‰å€¼
    TargetObject-->>Thread1: è¿”å› 101
    Thread1->>AtomicFieldUpdater: compareAndSet(101, 102)
    AtomicFieldUpdater-->>Thread1: æˆåŠŸï¼Œè¿”å›true
    Note over TargetObject: å½“å‰å€¼: 102
    
    Thread1->>TargetObject: è·å–å½“å‰å€¼
    TargetObject-->>Thread1: è¿”å› 102
    Thread1->>AtomicFieldUpdater: compareAndSet(102, 103)
    AtomicFieldUpdater-->>Thread1: æˆåŠŸï¼Œè¿”å›true
    Note over TargetObject: å½“å‰å€¼: 103
  ```

<Tabs>
  <TabItem value="atomic_field_updater_basic" label="åŸºæœ¬ä½¿ç”¨" default>
  ```java
  import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
  import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  // å‡è®¾æœ‰ä¸€ä¸ªç±»éœ€è¦åŸå­æ›´æ–°å…¶intå­—æ®µ
  public class AtomicFieldUpdaterExample {
      public static class Counter {
          public volatile int count = 0;
          
          // ä½¿ç”¨AtomicIntegerFieldUpdater
          private static final AtomicIntegerFieldUpdater<Counter> UPDATER =
              AtomicIntegerFieldUpdater.newUpdater(Counter.class, "count");
          
          public void increment() {
              UPDATER.incrementAndGet(this);
          }
          
          public int getCount() {
              return UPDATER.get(this);
          }
          
          public boolean compareAndSet(int expect, int update) {
              return UPDATER.compareAndSet(this, expect, update);
          }
      }
      
      public static void main(String[] args) {
          Counter counter = new Counter();
          
          // å¤šä¸ªçº¿ç¨‹åŒæ—¶é€’å¢è®¡æ•°å™¨
          for (int i = 0; i < 10; i++) {
              new Thread(() -> {
                  for (int j = 0; j < 1000; j++) {
                      counter.increment();
                  }
              }).start();
          }
          
          try {
              Thread.sleep(1000); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
          
          System.out.println("æœ€ç»ˆè®¡æ•°: " + counter.getCount());
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_field_updater_example" label="ç¤ºä¾‹">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
  import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  // å‡è®¾æœ‰ä¸€ä¸ªç±»éœ€è¦åŸå­æ›´æ–°å…¶intå­—æ®µ
  public class AtomicFieldUpdaterExample {
      public static class Counter {
          public volatile int count = 0;
          
          // ä½¿ç”¨AtomicIntegerFieldUpdater
          private static final AtomicIntegerFieldUpdater<Counter> UPDATER =
              AtomicIntegerFieldUpdater.newUpdater(Counter.class, "count");
          
          public void increment() {
              UPDATER.incrementAndGet(this);
          }
          
          public int getCount() {
              return UPDATER.get(this);
          }
          
          public boolean compareAndSet(int expect, int update) {
              return UPDATER.compareAndSet(this, expect, update);
          }
      }
      
      public static void main(String[] args) {
          Counter counter = new Counter();
          
          // å¤šä¸ªçº¿ç¨‹åŒæ—¶é€’å¢è®¡æ•°å™¨
          for (int i = 0; i < 10; i++) {
              new Thread(() -> {
                  for (int j = 0; j < 1000; j++) {
                      counter.increment();
                  }
              }).start();
          }
          
          try {
              Thread.sleep(1000); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
          
          System.out.println("æœ€ç»ˆè®¡æ•°: " + counter.getCount());
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_field_updater_limitations" label="é™åˆ¶æ¡ä»¶">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
  import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  // å‡è®¾æœ‰ä¸€ä¸ªç±»éœ€è¦åŸå­æ›´æ–°å…¶intå­—æ®µ
  public class AtomicFieldUpdaterExample {
      public static class Counter {
          public volatile int count = 0;
          
          // ä½¿ç”¨AtomicIntegerFieldUpdater
          private static final AtomicIntegerFieldUpdater<Counter> UPDATER =
              AtomicIntegerFieldUpdater.newUpdater(Counter.class, "count");
          
          public void increment() {
              UPDATER.incrementAndGet(this);
          }
          
          public int getCount() {
              return UPDATER.get(this);
          }
          
          public boolean compareAndSet(int expect, int update) {
              return UPDATER.compareAndSet(this, expect, update);
          }
      }
      
      public static void main(String[] args) {
          Counter counter = new Counter();
          
          // å¤šä¸ªçº¿ç¨‹åŒæ—¶é€’å¢è®¡æ•°å™¨
          for (int i = 0; i < 10; i++) {
              new Thread(() -> {
                  for (int j = 0; j < 1000; j++) {
                      counter.increment();
                  }
              }).start();
          }
          
          try {
              Thread.sleep(1000); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
          
          System.out.println("æœ€ç»ˆè®¡æ•°: " + counter.getCount());
      }
  }
  ```
  </TabItem>
</Tabs>

## 6. åŸå­ç±»æœ€ä½³å®è·µ

### 6.1 ä½¿ç”¨å»ºè®®

:::tip æ ¸å¿ƒåŸåˆ™
ä½¿ç”¨åŸå­ç±»æ—¶éœ€è¦è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š
- **æ€§èƒ½è¦æ±‚**ï¼šåŸå­ç±»é€‚åˆé«˜å¹¶å‘ã€ä½ç«äº‰åœºæ™¯
- **åŠŸèƒ½éœ€æ±‚**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„åŸå­ç±»
- **ABAé—®é¢˜**ï¼šéœ€è¦ç‰ˆæœ¬æ§åˆ¶æ—¶ä½¿ç”¨AtomicStampedReference
- **å†…å­˜å¼€é”€**ï¼šåŸå­ç±»æ¯”æ™®é€šå˜é‡å ç”¨æ›´å¤šå†…å­˜
:::

### 6.2 æ€§èƒ½ä¼˜åŒ–

```mermaid
sequenceDiagram
    participant Thread1 as çº¿ç¨‹1
    participant AtomicInteger as AtomicInteger
    participant Thread2 as çº¿ç¨‹2
    
    Note over AtomicInteger: åˆå§‹å€¼: 100
    
    Thread1->>AtomicInteger: get() è·å–å½“å‰å€¼
    AtomicInteger-->>Thread1: è¿”å› 100
    Thread1->>Thread1: è®¡ç®—æ–°å€¼ 101
    
    Thread2->>AtomicInteger: get() è·å–å½“å‰å€¼
    AtomicInteger-->>Thread2: è¿”å› 100
    Thread2->>AtomicInteger: compareAndSet(100, 101)
    AtomicInteger-->>Thread2: å¤±è´¥ï¼Œè¿”å›false
    Note over Thread2: éœ€è¦é‡è¯•æˆ–å¤„ç†å¤±è´¥
  ```

<Tabs>
  <TabItem value="atomic_optimization_basic" label="åŸºæœ¬ä¼˜åŒ–" default>
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  
  public class AtomicClassOptimization {
      private final AtomicInteger counter = new AtomicInteger(0);
      
      /**
       * å‡å°‘CASå¤±è´¥
       */
      public void optimizedIncrement() {
          while (true) {
              int current = counter.get();
              int next = current + 1;
              if (counter.compareAndSet(current, next)) {
                  break;
              }
              // å¯ä»¥æ·»åŠ é€€é¿ç­–ç•¥
              Thread.yield();
          }
      }
      
      /**
       * é¿å…è¿‡åº¦ä½¿ç”¨
       */
      public static class AvoidOveruse {
          // ä¸æ¨èï¼šè¿‡åº¦ä½¿ç”¨åŸå­ç±»
          private final AtomicInteger x = new AtomicInteger(0);
          private final AtomicInteger y = new AtomicInteger(0);
          private final AtomicInteger z = new AtomicInteger(0);
          
          // æ¨èï¼šä½¿ç”¨å¤åˆå¯¹è±¡
          public static class Point {
              private volatile int x, y, z;
              
              public synchronized void setCoordinates(int x, int y, int z) {
                  this.x = x;
                  this.y = y;
                  this.z = z;
              }
              
              public synchronized int[] getCoordinates() {
                  return new int[]{x, y, z};
              }
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_optimization_performance" label="æ€§èƒ½ä¼˜åŒ–">
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.atomic.AtomicBoolean;
  import java.util.concurrent.atomic.AtomicReference;
  import java.util.concurrent.atomic.AtomicStampedReference;
  import java.util.concurrent.atomic.AtomicMarkableReference;
  import java.util.concurrent.atomic.AtomicIntegerArray;
  import java.util.concurrent.atomic.AtomicLongArray;
  import java.util.concurrent.atomic.AtomicReferenceArray;
  import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
  import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  public class AtomicClassOptimization {
      private final AtomicInteger counter = new AtomicInteger(0);
      private final AtomicLong longCounter = new AtomicLong(0);
      private final AtomicBoolean booleanFlag = new AtomicBoolean(false);
      private final AtomicReference<String> stringRef = new AtomicReference<>("initial");
      private final AtomicStampedReference<String> stampedRef = new AtomicStampedReference<>("A", 0);
      private final AtomicMarkableReference<String> markableRef = new AtomicMarkableReference<>("data", false);
      private final AtomicIntegerArray intArray = new AtomicIntegerArray(5);
      private final AtomicLongArray longArray = new AtomicLongArray(5);
      private final AtomicReferenceArray<String> refArray = new AtomicReferenceArray<>(5);
      private final AtomicIntegerFieldUpdater<AtomicClassOptimization> intUpdater =
          AtomicIntegerFieldUpdater.newUpdater(AtomicClassOptimization.class, "counter");
      private final AtomicLongFieldUpdater<AtomicClassOptimization> longUpdater =
          AtomicLongFieldUpdater.newUpdater(AtomicClassOptimization.class, "longCounter");
      private final AtomicReferenceFieldUpdater<AtomicClassOptimization, String> refUpdater =
          AtomicReferenceFieldUpdater.newUpdater(AtomicClassOptimization.class, String.class, "stringRef");
      
      /**
       * å‡å°‘CASå¤±è´¥
       */
      public void optimizedIncrement() {
          while (true) {
              int current = counter.get();
              int next = current + 1;
              if (counter.compareAndSet(current, next)) {
                  break;
              }
              // å¯ä»¥æ·»åŠ é€€é¿ç­–ç•¥
              Thread.yield();
          }
      }
      
      /**
       * é¿å…è¿‡åº¦ä½¿ç”¨
       */
      public static class AvoidOveruse {
          // ä¸æ¨èï¼šè¿‡åº¦ä½¿ç”¨åŸå­ç±»
          private final AtomicInteger x = new AtomicInteger(0);
          private final AtomicInteger y = new AtomicInteger(0);
          private final AtomicInteger z = new AtomicInteger(0);
          
          // æ¨èï¼šä½¿ç”¨å¤åˆå¯¹è±¡
          public static class Point {
              private volatile int x, y, z;
              
              public synchronized void setCoordinates(int x, int y, int z) {
                  this.x = x;
                  this.y = y;
                  this.z = z;
              }
              
              public synchronized int[] getCoordinates() {
                  return new int[]{x, y, z};
              }
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_optimization_common_pitfalls" label="å¸¸è§é™·é˜±">
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.atomic.AtomicBoolean;
  import java.util.concurrent.atomic.AtomicReference;
  import java.util.concurrent.atomic.AtomicStampedReference;
  import java.util.concurrent.atomic.AtomicMarkableReference;
  import java.util.concurrent.atomic.AtomicIntegerArray;
  import java.util.concurrent.atomic.AtomicLongArray;
  import java.util.concurrent.atomic.AtomicReferenceArray;
  import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
  import java.util.concurrent.atomic.AtomicLongFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  public class AtomicClassOptimization {
      private final AtomicInteger counter = new AtomicInteger(0);
      private final AtomicLong longCounter = new AtomicLong(0);
      private final AtomicBoolean booleanFlag = new AtomicBoolean(false);
      private final AtomicReference<String> stringRef = new AtomicReference<>("initial");
      private final AtomicStampedReference<String> stampedRef = new AtomicStampedReference<>("A", 0);
      private final AtomicMarkableReference<String> markableRef = new AtomicMarkableReference<>("data", false);
      private final AtomicIntegerArray intArray = new AtomicIntegerArray(5);
      private final AtomicLongArray longArray = new AtomicLongArray(5);
      private final AtomicReferenceArray<String> refArray = new AtomicReferenceArray<>(5);
      private final AtomicIntegerFieldUpdater<AtomicClassOptimization> intUpdater =
          AtomicIntegerFieldUpdater.newUpdater(AtomicClassOptimization.class, "counter");
      private final AtomicLongFieldUpdater<AtomicClassOptimization> longUpdater =
          AtomicLongFieldUpdater.newUpdater(AtomicClassOptimization.class, "longCounter");
      private final AtomicReferenceFieldUpdater<AtomicClassOptimization, String> refUpdater =
          AtomicReferenceFieldUpdater.newUpdater(AtomicClassOptimization.class, String.class, "stringRef");
      
      /**
       * å‡å°‘CASå¤±è´¥
       */
      public void optimizedIncrement() {
          while (true) {
              int current = counter.get();
              int next = current + 1;
              if (counter.compareAndSet(current, next)) {
                  break;
              }
              // å¯ä»¥æ·»åŠ é€€é¿ç­–ç•¥
              Thread.yield();
          }
      }
      
      /**
       * é¿å…è¿‡åº¦ä½¿ç”¨
       */
      public static class AvoidOveruse {
          // ä¸æ¨èï¼šè¿‡åº¦ä½¿ç”¨åŸå­ç±»
          private final AtomicInteger x = new AtomicInteger(0);
          private final AtomicInteger y = new AtomicInteger(0);
          private final AtomicInteger z = new AtomicInteger(0);
          
          // æ¨èï¼šä½¿ç”¨å¤åˆå¯¹è±¡
          public static class Point {
              private volatile int x, y, z;
              
              public synchronized void setCoordinates(int x, int y, int z) {
                  this.x = x;
                  this.y = y;
                  this.z = z;
              }
              
              public synchronized int[] getCoordinates() {
                  return new int[]{x, y, z};
              }
          }
      }
  }
  ```
  </TabItem>
</Tabs>

## 7. æ€»ç»“

åŸå­ç±»æ˜¯Javaå¹¶å‘ç¼–ç¨‹ä¸­çš„é‡è¦å·¥å…·ï¼Œå®ƒä»¬æä¾›äº†é«˜æ€§èƒ½ã€æ— é˜»å¡çš„çº¿ç¨‹å®‰å…¨æ“ä½œã€‚

### 7.1 å…³é”®è¦ç‚¹

1. **CASæœºåˆ¶**ï¼šæ¯”è¾ƒå¹¶äº¤æ¢ï¼Œæ— é”ç®—æ³•çš„åŸºç¡€
2. **åŸå­ç±»åˆ†ç±»**ï¼šåŸºæœ¬ç±»å‹ã€å¼•ç”¨ç±»å‹ã€æ•°ç»„ç±»å‹ã€å­—æ®µæ›´æ–°å™¨
3. **ABAé—®é¢˜**ï¼šé€šè¿‡ç‰ˆæœ¬å·æˆ–æ ‡è®°è§£å†³
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘CASå¤±è´¥ã€é¿å…è¿‡åº¦ä½¿ç”¨

### 7.2 é€‰æ‹©å»ºè®®

| åœºæ™¯ | æ¨èåŸå­ç±» | åŸå›  |
|------|------------|------|
| **ç®€å•è®¡æ•°å™¨** | AtomicInteger/AtomicLong | æ€§èƒ½é«˜ï¼Œä½¿ç”¨ç®€å• |
| **å¯¹è±¡å¼•ç”¨** | AtomicReference | æ”¯æŒæ³›å‹ï¼ŒåŠŸèƒ½ä¸°å¯Œ |
| **éœ€è¦ç‰ˆæœ¬æ§åˆ¶** | AtomicStampedReference | è§£å†³ABAé—®é¢˜ |
| **éœ€è¦æ ‡è®°** | AtomicMarkableReference | æ”¯æŒå¸ƒå°”æ ‡è®° |
| **æ•°ç»„æ“ä½œ** | AtomicIntegerArrayç­‰ | åŸå­æ•°ç»„æ“ä½œ |
| **å­—æ®µæ›´æ–°** | å­—æ®µæ›´æ–°å™¨ | æ— éœ€ä¿®æ”¹ç±»ç»“æ„ |

### 7.3 å­¦ä¹ å»ºè®®

1. **ç†è§£åŸç†**ï¼šæ·±å…¥ç†è§£CASæœºåˆ¶çš„å·¥ä½œåŸç†
2. **å®è·µéªŒè¯**ï¼šé€šè¿‡ç¼–å†™ä»£ç éªŒè¯ä¸åŒåŸå­ç±»çš„æ•ˆæœ
3. **æ€§èƒ½æµ‹è¯•**ï¼šå¯¹æ¯”åŸå­ç±»ä¸åŒæ­¥æœºåˆ¶çš„æ€§èƒ½å·®å¼‚
4. **åœºæ™¯é€‰æ‹©**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„åŸå­ç±»

é€šè¿‡æ·±å…¥ç†è§£å’Œç†Ÿç»ƒè¿ç”¨è¿™äº›åŸå­ç±»æŠ€æœ¯ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå‡ºæ›´åŠ é«˜æ•ˆã€å¥å£®å’Œå¯ç»´æŠ¤çš„Javaå¹¶å‘åº”ç”¨ç¨‹åºã€‚ 