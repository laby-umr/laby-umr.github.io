---
sidebar_position: 4
title: "Javaå¹¶å‘å·¥å…·ç±»è¯¦è§£"
description: "å…¨é¢ä»‹ç»Javaå¹¶å‘å·¥å…·ç±»ã€åŒæ­¥æœºåˆ¶ã€çº¿ç¨‹åè°ƒä¸æœ€ä½³å®è·µ"
authors: [Laby]
last_update:
  date: 2025-01-07
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TOCInline from '@theme/TOCInline';

# Java å¹¶å‘å·¥å…·ç±»è¯¦è§£

Javaå¹¶å‘åŒ…ï¼ˆjava.util.concurrentï¼‰æä¾›äº†ä¸°å¯Œçš„å¹¶å‘å·¥å…·ç±»ï¼Œç”¨äºç®€åŒ–å¤šçº¿ç¨‹ç¼–ç¨‹ã€‚è¿™äº›å·¥å…·ç±»æä¾›äº†æ¯”ä¼ ç»Ÿsynchronizedæ›´çµæ´»å’Œé«˜æ•ˆçš„å¹¶å‘æ§åˆ¶æœºåˆ¶ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»å„ç§å¹¶å‘å·¥å…·ç±»çš„ä½¿ç”¨æ–¹æ³•å’Œæœ€ä½³å®è·µã€‚

:::info æœ¬æ–‡å†…å®¹æ¦‚è§ˆ
<TOCInline toc={toc} />
:::

:::tip æ ¸å¿ƒä»·å€¼
**å¹¶å‘å·¥å…·ç±» = çµæ´»åŒæ­¥ + æ€§èƒ½ä¼˜åŒ– + æ˜“ç”¨æ€§ + ä¸°å¯ŒåŠŸèƒ½**
- ğŸ”„ **çµæ´»æ§åˆ¶**ï¼šæä¾›æ¯”synchronizedæ›´çµæ´»çš„åŒæ­¥æœºåˆ¶
- ğŸš€ **é«˜æ€§èƒ½**ï¼šé‡‡ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•å’Œå®ç°ï¼Œä¼˜åŒ–ç«äº‰å¤„ç†
- ğŸ§© **åŠŸèƒ½ä¸°å¯Œ**ï¼šé’ˆå¯¹ä¸åŒåœºæ™¯æä¾›ä¸“ç”¨å·¥å…·
- ğŸ›¡ï¸ **å¥å£®æ€§**ï¼šå†…ç½®è¶…æ—¶ã€ä¸­æ–­ã€å¼‚å¸¸å¤„ç†ç­‰æœºåˆ¶
- ğŸ“Š **å¯ä¼¸ç¼©æ€§**ï¼šé€‚åº”å„ç§å¤æ‚å¹¶å‘åœºæ™¯
:::

## 1. å¹¶å‘å·¥å…·ç±»æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯å¹¶å‘å·¥å…·ç±»ï¼Ÿ

```mermaid
graph TD
    A[Javaå¹¶å‘å·¥å…·ç±»] -->|åŸºäº| B[AbstractQueuedSynchronizer<br>AQSæ¡†æ¶]
    B -->|æä¾›| C[é«˜æ•ˆåŒæ­¥æœºåˆ¶]
    A -->|åŒ…å«| D[åŒæ­¥å·¥å…·ç±»]
    A -->|åŒ…å«| E[æ‰§è¡ŒæœåŠ¡]
    A -->|åŒ…å«| F[å¹¶å‘é›†åˆ]
    A -->|åŒ…å«| G[åŸå­å˜é‡]
    
    D -->|åŒ…æ‹¬| D1[CountDownLatch]
    D -->|åŒ…æ‹¬| D2[CyclicBarrier]
    D -->|åŒ…æ‹¬| D3[Semaphore]
    D -->|åŒ…æ‹¬| D4[Phaser]
    D -->|åŒ…æ‹¬| D5[Exchanger]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style D,E,F,G fill:#cff,stroke:#333
```

:::tip æ ¸å¿ƒæ¦‚å¿µ
å¹¶å‘å·¥å…·ç±»æ˜¯Javaå¹¶å‘åŒ…ä¸­æä¾›çš„ä¸€ç»„é«˜çº§åŒæ­¥å·¥å…·ï¼Œå®ƒä»¬åŸºäºAQSï¼ˆAbstractQueuedSynchronizerï¼‰å®ç°ï¼Œæä¾›äº†æ¯”ä¼ ç»Ÿsynchronizedæ›´çµæ´»ã€æ›´é«˜æ•ˆçš„å¹¶å‘æ§åˆ¶æœºåˆ¶ã€‚
:::

### 1.2 å¹¶å‘å·¥å…·ç±»çš„ä¼˜åŠ¿

<div className="card">
<div className="card__header">
<h4>å¹¶å‘å·¥å…·ç±»ä¸ä¼ ç»ŸåŒæ­¥æœºåˆ¶å¯¹æ¯”</h4>
</div>
<div className="card__body">

| ä¼˜åŠ¿ | å…·ä½“ä½“ç° | ä¸šåŠ¡ä»·å€¼ |
|------|----------|----------|
| **çµæ´»æ€§** | æ”¯æŒè¶…æ—¶ã€ä¸­æ–­ã€å…¬å¹³æ€§ç­‰ç‰¹æ€§ | é€‚åº”å¤æ‚ä¸šåŠ¡åœºæ™¯ |
| **é«˜æ€§èƒ½** | åŸºäºAQSå®ç°ï¼Œæ€§èƒ½ä¼˜äºsynchronized | æé«˜ç³»ç»Ÿååé‡ |
| **åŠŸèƒ½ä¸°å¯Œ** | æä¾›å¤šç§åŒæ­¥æœºåˆ¶ | ç®€åŒ–ç¼–ç¨‹å¤æ‚åº¦ |
| **å¯æ‰©å±•æ€§** | æ”¯æŒè‡ªå®šä¹‰åŒæ­¥å™¨ | æ»¡è¶³ç‰¹æ®Šéœ€æ±‚ |
| **å¯è¯»æ€§** | è¯­ä¹‰æ¸…æ™°ï¼Œä»£ç æ˜“ç†è§£ | æé«˜ä»£ç è´¨é‡ |

</div>
</div>

### 1.3 å¹¶å‘å·¥å…·ç±»åˆ†ç±»

```mermaid
classDiagram
    class ConcurrentTools {
        <<interface>>
    }
    
    class SynchronizationTools {
        CountDownLatch
        CyclicBarrier
        Semaphore
        Phaser
    }
    
    class ExchangeTools {
        Exchanger
    }
    
    class AsyncTools {
        FutureTask
        CompletableFuture
    }
    
    class AtomicTools {
        AtomicInteger
        AtomicLong
        AtomicReference
        LongAdder
    }
    
    ConcurrentTools <|-- SynchronizationTools
    ConcurrentTools <|-- ExchangeTools
    ConcurrentTools <|-- AsyncTools
    ConcurrentTools <|-- AtomicTools
```

<Tabs>
  <TabItem value="sync_tools" label="åŒæ­¥å·¥å…·ç±»" default>
  <div className="card">
  <div className="card__body">
  
  **åŒæ­¥å·¥å…·ç±»ä¸»è¦ç”¨äºåè°ƒå¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œé¡ºåºå’ŒçŠ¶æ€ï¼š**
  
  | å·¥å…·ç±» | ä¸»è¦åŠŸèƒ½ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
  |-------|---------|------|----------|
  | **CountDownLatch** | è®©ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…ä¸€ç»„æ“ä½œå®Œæˆ | ä¸€æ¬¡æ€§ä½¿ç”¨ï¼Œè®¡æ•°å™¨ä¸º0åæ— æ³•é‡ç½® | å¯åŠ¨ä¿¡å·ã€èµ„æºåˆå§‹åŒ–ç­‰å¾… |
  | **CyclicBarrier** | è®©ä¸€ç»„çº¿ç¨‹åœ¨æŸä¸ªç‚¹ç›¸äº’ç­‰å¾… | å¯é‡å¤ä½¿ç”¨ï¼Œè‡ªåŠ¨é‡ç½®è®¡æ•° | åˆ†é˜¶æ®µè®¡ç®—ã€å¹¶è¡Œè¿­ä»£ç®—æ³• |
  | **Semaphore** | æ§åˆ¶åŒæ—¶è®¿é—®æŸä¸ªèµ„æºçš„çº¿ç¨‹æ•°é‡ | æ”¯æŒå…¬å¹³/éå…¬å¹³æ¨¡å¼ï¼Œå¯åŠ¨æ€è°ƒæ•´è®¸å¯ | è¿æ¥æ± ç®¡ç†ã€èµ„æºé™åˆ¶ |
  | **Phaser** | å…è®¸å¤šé˜¶æ®µåŒæ­¥ï¼ŒåŠ¨æ€è°ƒæ•´å‚ä¸æ–¹æ•°é‡ | åŠŸèƒ½æœ€å¼ºå¤§ã€æœ€å¤æ‚ | å¤æ‚å¤šé˜¶æ®µå¹¶è¡Œä»»åŠ¡ |
  
  </div>
  </div>
  </TabItem>
  
  <TabItem value="exchange_tools" label="äº¤æ¢å·¥å…·ç±»">
  <div className="card">
  <div className="card__body">
  
  **äº¤æ¢å·¥å…·ç±»ç”¨äºçº¿ç¨‹é—´æ•°æ®äº¤æ¢ï¼š**
  
  | å·¥å…·ç±» | ä¸»è¦åŠŸèƒ½ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
  |-------|---------|------|----------|
  | **Exchanger** | ä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´äº¤æ¢æ•°æ® | åŒå‘äº¤æ¢ï¼Œæ”¯æŒè¶…æ—¶ | ç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å¼ã€åŒå‘æ•°æ®æµ |
  
  </div>
  </div>
  </TabItem>
  
  <TabItem value="async_tools" label="å¼‚æ­¥å·¥å…·ç±»">
  <div className="card">
  <div className="card__body">
  
  **å¼‚æ­¥å·¥å…·ç±»ç”¨äºå¤„ç†å¼‚æ­¥è®¡ç®—ç»“æœï¼š**
  
  | å·¥å…·ç±» | ä¸»è¦åŠŸèƒ½ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
  |-------|---------|------|----------|
  | **FutureTask** | è¡¨ç¤ºä¸€ä¸ªå¯å–æ¶ˆçš„å¼‚æ­¥è®¡ç®— | å¯è·å–ç»“æœã€æ£€æŸ¥çŠ¶æ€ã€å–æ¶ˆä»»åŠ¡ | å•ä¸ªå¼‚æ­¥ä»»åŠ¡å¤„ç† |
  | **CompletableFuture** | æ”¯æŒç»„åˆå¼å¼‚æ­¥ç¼–ç¨‹ | æ”¯æŒä»»åŠ¡é“¾å¼å¤„ç†ã€å¼‚å¸¸å¤„ç† | å¤æ‚å¼‚æ­¥å·¥ä½œæµ |
  
  </div>
  </div>
  </TabItem>
  
  <TabItem value="atomic_tools" label="åŸå­å·¥å…·ç±»">
  <div className="card">
  <div className="card__body">
  
  **åŸå­å·¥å…·ç±»ç”¨äºåŸå­æ“ä½œï¼š**
  
  | å·¥å…·ç±» | ä¸»è¦åŠŸèƒ½ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
  |-------|---------|------|----------|
  | **AtomicInteger** | åŸå­æ›´æ–°æ•´å‹å€¼ | CASæ“ä½œï¼Œæ— é” | è®¡æ•°å™¨ã€åºåˆ—å·ç”Ÿæˆ |
  | **AtomicReference** | åŸå­æ›´æ–°å¼•ç”¨ç±»å‹ | æ”¯æŒå¼•ç”¨çš„åŸå­æ›´æ–° | åŸå­æ›´æ–°å¯¹è±¡ |
  | **LongAdder** | é«˜å¹¶å‘è®¡æ•°å™¨ | åˆ†æ®µè®¡æ•°ï¼Œå‡å°‘ç«äº‰ | é«˜å¹¶å‘ç»Ÿè®¡åœºæ™¯ |
  
  </div>
  </div>
  </TabItem>
</Tabs>

## 2. CountDownLatchï¼ˆå€’è®¡æ—¶é—¨é—©ï¼‰

### 2.1 CountDownLatch åŸºæœ¬æ¦‚å¿µ

```mermaid
stateDiagram-v2
    [*] --> åˆ›å»º: new CountDownLatch(n)
    åˆ›å»º --> ç­‰å¾…: await()
    åˆ›å»º --> è®¡æ•°å‡ä¸€: countDown()
    è®¡æ•°å‡ä¸€ --> æ£€æŸ¥è®¡æ•°
    æ£€æŸ¥è®¡æ•° --> è®¡æ•°å‡ä¸€: è®¡æ•°>0
    æ£€æŸ¥è®¡æ•° --> é€šçŸ¥ç­‰å¾…çº¿ç¨‹: è®¡æ•°=0
    é€šçŸ¥ç­‰å¾…çº¿ç¨‹ --> [*]
    ç­‰å¾… --> è¢«é˜»å¡: è®¡æ•°>0
    ç­‰å¾… --> ç»§ç»­æ‰§è¡Œ: è®¡æ•°=0
    è¢«é˜»å¡ --> ç»§ç»­æ‰§è¡Œ: æ”¶åˆ°é€šçŸ¥
    ç»§ç»­æ‰§è¡Œ --> [*]
```

<div className="card">
<div className="card__header">
<h4>CountDownLatchæ ¸å¿ƒç‰¹æ€§</h4>
</div>
<div className="card__body">

**CountDownLatch**æ˜¯ä¸€ä¸ªåŒæ­¥å·¥å…·ç±»ï¼Œå…è®¸ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹å®Œæˆæ“ä½œã€‚

**å…³é”®ç‰¹æ€§ï¼š**
- åˆå§‹åŒ–æ—¶æŒ‡å®šè®¡æ•°å€¼
- è°ƒç”¨`countDown()`æ–¹æ³•ä½¿è®¡æ•°å€¼å‡1
- è°ƒç”¨`await()`æ–¹æ³•ç­‰å¾…è®¡æ•°å€¼å˜ä¸º0
- **ä¸€æ¬¡æ€§ä½¿ç”¨**ï¼šè®¡æ•°å€¼ä¸º0åæ— æ³•é‡ç½®
- æ”¯æŒè¶…æ—¶ç­‰å¾…ï¼š`await(long timeout, TimeUnit unit)`

**ä¸»è¦åº”ç”¨åœºæ™¯ï¼š**
- å¯åŠ¨ä¿¡å·ï¼šç­‰å¾…æ‰€æœ‰æœåŠ¡å°±ç»ªåå†å¼€å§‹
- ä»»åŠ¡åˆ†è§£ï¼šå°†å¤§ä»»åŠ¡åˆ†è§£ä¸ºå¤šä¸ªå°ä»»åŠ¡å¹¶è¡Œå¤„ç†
- èµ„æºåˆå§‹åŒ–ï¼šç­‰å¾…å¤šä¸ªèµ„æºåˆå§‹åŒ–å®Œæˆ

</div>
</div>

<Tabs>
  <TabItem value="basic_usage" label="åŸºæœ¬ç”¨æ³•" default>
  ```java
  import java.util.concurrent.CountDownLatch;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  /**
   * CountDownLatchåŸºæœ¬ç”¨æ³•
   */
  public static class BasicUsage {
      public static void main(String[] args) throws InterruptedException {
          int threadCount = 3;
          // åˆ›å»ºä¸€ä¸ªåˆå§‹è®¡æ•°ä¸º3çš„CountDownLatch
          CountDownLatch latch = new CountDownLatch(threadCount);
          ExecutorService executor = Executors.newFixedThreadPool(threadCount);
          
          // å¯åŠ¨å¤šä¸ªå·¥ä½œçº¿ç¨‹
          for (int i = 0; i < threadCount; i++) {
              final int taskId = i;
              executor.submit(() -> {
                  try {
                      System.out.println("ä»»åŠ¡ " + taskId + " å¼€å§‹æ‰§è¡Œ");
                      Thread.sleep(1000 + taskId * 500); // æ¨¡æ‹Ÿå·¥ä½œ
                      System.out.println("ä»»åŠ¡ " + taskId + " æ‰§è¡Œå®Œæˆ");
                  } catch (InterruptedException e) {
                      Thread.currentThread().interrupt();
                  } finally {
                      latch.countDown(); // è®¡æ•°å™¨å‡1
                      System.out.println("ä»»åŠ¡ " + taskId + " è®¡æ•°å™¨å‡1ï¼Œå‰©ä½™: " + latch.getCount());
                  }
              });
          }
          
          System.out.println("ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ...");
          latch.await(); // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
          System.out.println("æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆï¼");
              
          executor.shutdown();
      }
  }
  ```
  
  **å·¥ä½œåŸç†ï¼š**
  1. åˆ›å»º`CountDownLatch`å¹¶è®¾ç½®åˆå§‹è®¡æ•°å€¼
  2. å¯åŠ¨å¤šä¸ªçº¿ç¨‹æ‰§è¡Œä»»åŠ¡
  3. æ¯ä¸ªä»»åŠ¡å®Œæˆåè°ƒç”¨`countDown()`ä½¿è®¡æ•°å€¼å‡1
  4. ä¸»çº¿ç¨‹è°ƒç”¨`await()`ç­‰å¾…è®¡æ•°å€¼å˜ä¸º0
  5. å½“æ‰€æœ‰ä»»åŠ¡å®Œæˆåï¼Œä¸»çº¿ç¨‹ç»§ç»­æ‰§è¡Œ
  
  </TabItem>
  <TabItem value="timeout_usage" label="è¶…æ—¶ç­‰å¾…">
  ```java
  import java.util.concurrent.CountDownLatch;
  import java.util.concurrent.TimeUnit;
  
  /**
   * CountDownLatchè¶…æ—¶ç­‰å¾…
   */
  public static class TimeoutUsage {
      public static void main(String[] args) throws InterruptedException {
          CountDownLatch latch = new CountDownLatch(3);
          
          // å¯åŠ¨å·¥ä½œçº¿ç¨‹
          for (int i = 0; i < 3; i++) {
              final int taskId = i;
              new Thread(() -> {
                  try {
                      // æ¯ä¸ªä»»åŠ¡æ‰§è¡Œæ—¶é—´ä¸åŒ
                      Thread.sleep(2000 + taskId * 1000); // æ¨¡æ‹Ÿé•¿æ—¶é—´å·¥ä½œ
                      System.out.println("ä»»åŠ¡ " + taskId + " å®Œæˆ");
                      latch.countDown();
                  } catch (InterruptedException e) {
                      Thread.currentThread().interrupt();
                  }
              }).start();
          }
          
          // æœ€å¤šç­‰å¾…5ç§’
          boolean completed = latch.await(5, TimeUnit.SECONDS);
          if (completed) {
              System.out.println("æ‰€æœ‰ä»»åŠ¡åœ¨è¶…æ—¶æ—¶é—´å†…å®Œæˆ");
          } else {
              System.out.println("ç­‰å¾…è¶…æ—¶ï¼Œè¿˜æœ‰ " + latch.getCount() + " ä¸ªä»»åŠ¡æœªå®Œæˆ");
          }
      }
  }
  ```
  
  **è¶…æ—¶å¤„ç†çš„ä¼˜åŠ¿ï¼š**
  - é¿å…æ— é™æœŸç­‰å¾…
  - æä¾›å¤±è´¥å¿«é€Ÿè·¯å¾„
  - å¢å¼ºç³»ç»Ÿé²æ£’æ€§
  - æ”¯æŒä¼˜é›…é™çº§ç­–ç•¥
  
  </TabItem>
  <TabItem value="practical_usage" label="å®é™…åº”ç”¨">
  ```java
  import java.util.concurrent.CountDownLatch;
  
  /**
   * æ•°æ®åŠ è½½åœºæ™¯
   */
  public static class DataLoader {
      public void loadData() throws InterruptedException {
          // åˆ›å»ºç”¨äºç­‰å¾…ä¸‰ç±»æ•°æ®åŠ è½½å®Œæˆçš„CountDownLatch
          CountDownLatch latch = new CountDownLatch(3);
          
          // å¹¶è¡ŒåŠ è½½ä¸åŒç±»å‹çš„æ•°æ®
          new Thread(() -> {
              try {
                  loadUserData();
                  System.out.println("ç”¨æˆ·æ•°æ®åŠ è½½å®Œæˆ");
              } finally {
                  latch.countDown();
              }
          }).start();
          
          new Thread(() -> {
              try {
                  loadProductData();
                  System.out.println("äº§å“æ•°æ®åŠ è½½å®Œæˆ");
              } finally {
                  latch.countDown();
              }
          }).start();
          
          new Thread(() -> {
              try {
                  loadOrderData();
                  System.out.println("è®¢å•æ•°æ®åŠ è½½å®Œæˆ");
              } finally {
                  latch.countDown();
              }
          }).start();
          
          // ç­‰å¾…æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆ
          latch.await();
          System.out.println("æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆï¼Œå¼€å§‹å¤„ç†ä¸šåŠ¡é€»è¾‘");
          processAllData();
      }
      
      // æ•°æ®åŠ è½½å’Œå¤„ç†æ–¹æ³•
      private void loadUserData() { /* å®ç°çœç•¥ */ }
      private void loadProductData() { /* å®ç°çœç•¥ */ }
      private void loadOrderData() { /* å®ç°çœç•¥ */ }
      private void processAllData() { /* å®ç°çœç•¥ */ }
  }
  ```
  
  **åº”ç”¨åœºæ™¯ç¤ºä¾‹ï¼š**
  - **å¾®æœåŠ¡å¯åŠ¨**ï¼šç­‰å¾…å¤šä¸ªä¾èµ–æœåŠ¡å°±ç»ª
  - **å¹¶è¡Œæ•°æ®å¤„ç†**ï¼šåˆ†ç‰‡å¤„ç†å¤§å‹æ•°æ®é›†
  - **æµ‹è¯•å¤šçº¿ç¨‹**ï¼šç¡®ä¿å¤šä¸ªçº¿ç¨‹åŒæ—¶å¼€å§‹æ‰§è¡Œ
  - **èµ„æºåˆå§‹åŒ–**ï¼šç­‰å¾…å¤šä¸ªèµ„æºå‡†å¤‡å®Œæ¯•
  
  </TabItem>
</Tabs>

### 2.2 CountDownLatch vs CyclicBarrier

```mermaid
graph TB
    subgraph CountDownLatch
        A1[ä¸€æ¬¡æ€§ä½¿ç”¨] --> B1[ä¸€ä¸ª/å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹]
        C1[è®¡æ•°å™¨ä¸º0åæ— æ³•é‡ç½®] --> D1[åªèƒ½å‡è®¡æ•°]
    end
    
    subgraph CyclicBarrier
        A2[å¯é‡å¤ä½¿ç”¨] --> B2[ä¸€ç»„çº¿ç¨‹ç›¸äº’ç­‰å¾…]
        C2[è‡ªåŠ¨é‡ç½®] --> D2[æ”¯æŒå±éšœåŠ¨ä½œ]
    end
    
    style CountDownLatch fill:#f9d,stroke:#333
    style CyclicBarrier fill:#9df,stroke:#333
```

<div className="card">
<div className="card__header">
<h4>CountDownLatchä¸CyclicBarrierå¯¹æ¯”</h4>
</div>
<div className="card__body">

| ç‰¹æ€§ | CountDownLatch | CyclicBarrier |
|------|--------------|--------------|
| **ç­‰å¾…æ–¹å‘** | ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…å…¶ä»–çº¿ç¨‹ | ä¸€ç»„çº¿ç¨‹ç›¸äº’ç­‰å¾… |
| **é‡ç”¨æ€§** | ä¸€æ¬¡æ€§ä½¿ç”¨ï¼Œä¸å¯é‡ç½® | å¯é‡å¤ä½¿ç”¨ï¼Œè‡ªåŠ¨é‡ç½® |
| **è®¡æ•°æ“ä½œ** | `countDown()`å‡å°‘è®¡æ•° | è°ƒç”¨`await()`å¢åŠ è®¡æ•° |
| **å›è°ƒåŠ¨ä½œ** | ä¸æ”¯æŒ | æ”¯æŒå±éšœåŠ¨ä½œï¼ˆbarrier actionï¼‰ |
| **è¶…æ—¶æ”¯æŒ** | æ”¯æŒè¶…æ—¶ç­‰å¾… | æ”¯æŒè¶…æ—¶ç­‰å¾… |
| **åˆ›å»ºæ–¹å¼** | æŒ‡å®šè®¡æ•°å€¼ | æŒ‡å®šå‚ä¸çº¿ç¨‹æ•°å’Œå¯é€‰çš„å±éšœåŠ¨ä½œ |
| **ä½¿ç”¨åœºæ™¯** | å¯åŠ¨ä¿¡å·ã€ä»»åŠ¡åˆ†è§£ | åˆ†é˜¶æ®µè®¡ç®—ã€å¹¶è¡Œè¿­ä»£ |

</div>
</div>

### 2.3 CountDownLatch å®ç°åŸç†

```mermaid
classDiagram
    class AbstractQueuedSynchronizer {
        #int state
        #tryAcquireShared()
        #tryReleaseShared()
    }
    
    class CountDownLatch {
        -Sync sync
        +await()
        +countDown()
        +getCount()
    }
    
    class Sync {
        -int startCount
        #tryAcquireShared()
        #tryReleaseShared()
    }
    
    AbstractQueuedSynchronizer <|-- Sync
    CountDownLatch *-- Sync
```

<details>
<summary><strong>CountDownLatchå†…éƒ¨å®ç°ç»†èŠ‚</strong></summary>

CountDownLatchåŸºäºAQSï¼ˆAbstractQueuedSynchronizerï¼‰å®ç°ï¼Œå®ƒä½¿ç”¨AQSçš„å…±äº«æ¨¡å¼ï¼š

1. **çŠ¶æ€ç®¡ç†**ï¼š
   - AQSçš„stateå˜é‡ç”¨ä½œè®¡æ•°å™¨
   - åˆå§‹åŒ–æ—¶è®¾ç½®ä¸ºæŒ‡å®šçš„è®¡æ•°å€¼
   - æ¯æ¬¡countDown()æ—¶å°†stateå‡1
   - å½“stateå˜ä¸º0æ—¶ï¼Œæ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹è¢«é‡Šæ”¾

2. **å…³é”®æ–¹æ³•å®ç°**ï¼š
   - `countDown()`ï¼šè°ƒç”¨AQSçš„`releaseShared()`æ–¹æ³•ï¼Œå‡å°‘è®¡æ•°
   - `await()`ï¼šè°ƒç”¨AQSçš„`acquireShared()`æ–¹æ³•ï¼Œå¦‚æœè®¡æ•°ä¸ä¸º0åˆ™é˜»å¡
   - `await(timeout, unit)`ï¼šè°ƒç”¨AQSçš„`tryAcquireSharedNanos()`æ–¹æ³•ï¼Œæ”¯æŒè¶…æ—¶

3. **çº¿ç¨‹æ’é˜Ÿæœºåˆ¶**ï¼š
   - ä½¿ç”¨AQSå†…éƒ¨çš„FIFOé˜Ÿåˆ—æ¥ç®¡ç†ç­‰å¾…çš„çº¿ç¨‹
   - å½“è®¡æ•°å™¨å˜ä¸º0æ—¶ï¼ŒAQSä¼šé‡Šæ”¾æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹

4. **ä¸ºä»€ä¹ˆä¸å¯é‡ç”¨**ï¼š
   - CountDownLatchçš„è®¡æ•°å™¨åªèƒ½å‡ä¸èƒ½å¢
   - ä¸€æ—¦è®¡æ•°å™¨è¾¾åˆ°0ï¼Œå°±æ— æ³•æ¢å¤åˆ°åˆå§‹çŠ¶æ€
   - è¿™æ˜¯è®¾è®¡å†³ç­–ï¼Œè€ŒéæŠ€æœ¯é™åˆ¶

</details>

## 3. CyclicBarrierï¼ˆå¾ªç¯å±éšœï¼‰

### 3.1 CyclicBarrier åŸºæœ¬æ¦‚å¿µ

CyclicBarrieræ˜¯ä¸€ä¸ªåŒæ­¥å·¥å…·ç±»ï¼Œå…è®¸ä¸€ç»„çº¿ç¨‹äº’ç›¸ç­‰å¾…ï¼Œç›´åˆ°æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾æŸä¸ªå…¬å…±å±éšœç‚¹ã€‚

```java title="CyclicBarrieråŸºæœ¬ç”¨æ³•ç¤ºä¾‹"
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.BrokenBarrierException;

public class CyclicBarrierExamples {
    
    /**
     * CyclicBarrieråŸºæœ¬ç”¨æ³•
     */
    public static class BasicUsage {
    public static void main(String[] args) {
        int threadCount = 3;
        CyclicBarrier barrier = new CyclicBarrier(threadCount, () -> {
            System.out.println("æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾å±éšœç‚¹ï¼Œå¼€å§‹ä¸‹ä¸€è½®");
        });
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            
            System.out.println("=== CyclicBarrieråŸºæœ¬ç”¨æ³• ===");
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int round = 0; round < 3; round++) {
                        System.out.println("çº¿ç¨‹ " + threadId + " æ‰§è¡Œç¬¬ " + round + " è½®");
                            Thread.sleep(1000 + threadId * 200);
                        System.out.println("çº¿ç¨‹ " + threadId + " åˆ°è¾¾å±éšœç‚¹");
                        barrier.await(); // ç­‰å¾…å…¶ä»–çº¿ç¨‹
                    }
                    } catch (InterruptedException | BrokenBarrierException e) {
                        Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
    }
}
    
    /**
     * CyclicBarrierè¶…æ—¶å¤„ç†
     */
    public static class TimeoutUsage {
        public static void main(String[] args) {
            int threadCount = 3;
            CyclicBarrier barrier = new CyclicBarrier(threadCount);
            
            for (int i = 0; i < threadCount; i++) {
                final int threadId = i;
                new Thread(() -> {
                    try {
                        for (int round = 0; round < 2; round++) {
                            System.out.println("çº¿ç¨‹ " + threadId + " å¼€å§‹ç¬¬ " + round + " è½®");
                            
                            // æ¨¡æ‹Ÿä¸åŒçº¿ç¨‹çš„æ‰§è¡Œæ—¶é—´
                            Thread.sleep(1000 + threadId * 1000);
                            
                            try {
                                // ç­‰å¾…æœ€å¤š3ç§’
                                barrier.await(3, TimeUnit.SECONDS);
                                System.out.println("çº¿ç¨‹ " + threadId + " ç¬¬ " + round + " è½®å®Œæˆ");
                            } catch (TimeoutException e) {
                                System.out.println("çº¿ç¨‹ " + threadId + " ç­‰å¾…è¶…æ—¶");
                                barrier.reset(); // é‡ç½®å±éšœ
                                break;
                            }
                        }
                    } catch (InterruptedException | BrokenBarrierException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
            }
        }
    }
    
    /**
     * CyclicBarrierå®é™…åº”ç”¨åœºæ™¯
     */
    public static class PracticalApplications {
        
        /**
         * çŸ©é˜µå¤„ç†åœºæ™¯
         */
        public static class MatrixProcessor {
            public void processMatrix(int[][] matrix) {
        int rows = matrix.length;
        CyclicBarrier barrier = new CyclicBarrier(rows, () -> {
            System.out.println("æ‰€æœ‰è¡Œå¤„ç†å®Œæˆï¼Œå¼€å§‹ä¸‹ä¸€é˜¶æ®µ");
        });
        
        for (int i = 0; i < rows; i++) {
            final int rowIndex = i;
            new Thread(() -> {
                try {
                            // ç¬¬ä¸€é˜¶æ®µï¼šå¤„ç†çŸ©é˜µçš„æ¯ä¸€è¡Œ
                    processRow(matrix[rowIndex]);
                    barrier.await();
                    
                            // ç¬¬äºŒé˜¶æ®µï¼šç­‰å¾…æ‰€æœ‰è¡Œå¤„ç†å®Œæˆåï¼Œè¿›è¡Œä¸‹ä¸€é˜¶æ®µ
                    processRowPhase2(matrix[rowIndex]);
                    barrier.await();
                    
                            // ç¬¬ä¸‰é˜¶æ®µï¼šæœ€ç»ˆå¤„ç†
                            processRowPhase3(matrix[rowIndex]);
                            barrier.await();
                            
                        } catch (InterruptedException | BrokenBarrierException e) {
                            Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
    
    private void processRow(int[] row) {
                try {
                    System.out.println("å¤„ç†è¡Œæ•°æ®: " + Arrays.toString(row));
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
    }
    
    private void processRowPhase2(int[] row) {
                try {
                    System.out.println("ç¬¬äºŒé˜¶æ®µå¤„ç†è¡Œæ•°æ®: " + Arrays.toString(row));
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            
            private void processRowPhase3(int[] row) {
                try {
                    System.out.println("ç¬¬ä¸‰é˜¶æ®µå¤„ç†è¡Œæ•°æ®: " + Arrays.toString(row));
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        
        /**
         * æ¸¸æˆåŒæ­¥åœºæ™¯
         */
        public static class GameSynchronizer {
            public void startGame(int playerCount) {
                CyclicBarrier barrier = new CyclicBarrier(playerCount, () -> {
                    System.out.println("æ‰€æœ‰ç©å®¶å‡†å¤‡å°±ç»ªï¼Œå¼€å§‹æ–°ä¸€è½®");
                });
                
                for (int i = 0; i < playerCount; i++) {
                    final int playerId = i;
                    new Thread(() -> {
                        try {
                            for (int round = 0; round < 3; round++) {
                                System.out.println("ç©å®¶ " + playerId + " å‡†å¤‡ç¬¬ " + round + " è½®");
                                Thread.sleep(1000 + playerId * 200);
                                
                                barrier.await();
                                
                                System.out.println("ç©å®¶ " + playerId + " å®Œæˆç¬¬ " + round + " è½®");
                            }
                        } catch (InterruptedException | BrokenBarrierException e) {
                            Thread.currentThread().interrupt();
                        }
                    }).start();
                }
            }
        }
    }
}
```

## 4. Semaphoreï¼ˆä¿¡å·é‡ï¼‰

### 4.1 Semaphore åŸºæœ¬æ¦‚å¿µ

Semaphoreæ˜¯ä¸€ä¸ªè®¡æ•°ä¿¡å·é‡ï¼Œç”¨äºæ§åˆ¶åŒæ—¶è®¿é—®ç‰¹å®šèµ„æºçš„çº¿ç¨‹æ•°é‡ã€‚

```java title="SemaphoreåŸºæœ¬ç”¨æ³•ç¤ºä¾‹"
import java.util.concurrent.Semaphore;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class SemaphoreExamples {
    
    /**
     * SemaphoreåŸºæœ¬ç”¨æ³•
     */
    public static class BasicUsage {
    public static void main(String[] args) {
        // é™åˆ¶åŒæ—¶è®¿é—®çš„çº¿ç¨‹æ•°ä¸º2
        Semaphore semaphore = new Semaphore(2);
        ExecutorService executor = Executors.newFixedThreadPool(5);
            
            System.out.println("=== SemaphoreåŸºæœ¬ç”¨æ³• ===");
        
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    System.out.println("ä»»åŠ¡ " + taskId + " å°è¯•è·å–è®¸å¯");
                    semaphore.acquire(); // è·å–è®¸å¯
                    
                    System.out.println("ä»»åŠ¡ " + taskId + " è·å¾—è®¸å¯ï¼Œå¼€å§‹æ‰§è¡Œ");
                    Thread.sleep(2000); // æ¨¡æ‹Ÿå·¥ä½œ
                    System.out.println("ä»»åŠ¡ " + taskId + " æ‰§è¡Œå®Œæˆ");
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    semaphore.release(); // é‡Šæ”¾è®¸å¯
                    System.out.println("ä»»åŠ¡ " + taskId + " é‡Šæ”¾è®¸å¯");
                }
            });
        }
        
        executor.shutdown();
    }
}
    
    /**
     * Semaphoreå…¬å¹³æ¨¡å¼
     */
    public static class FairUsage {
        public static void main(String[] args) {
            // åˆ›å»ºå…¬å¹³æ¨¡å¼çš„ä¿¡å·é‡
            Semaphore semaphore = new Semaphore(2, true);
            
            for (int i = 0; i < 4; i++) {
                final int threadId = i;
                new Thread(() -> {
                    try {
                        System.out.println("çº¿ç¨‹ " + threadId + " å°è¯•è·å–è®¸å¯");
                        semaphore.acquire();
                        
                        System.out.println("çº¿ç¨‹ " + threadId + " è·å¾—è®¸å¯");
                        Thread.sleep(1000);
                        
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    } finally {
                        semaphore.release();
                        System.out.println("çº¿ç¨‹ " + threadId + " é‡Šæ”¾è®¸å¯");
                    }
                }).start();
            }
        }
    }
    
    /**
     * Semaphoreè¶…æ—¶æ§åˆ¶
     */
    public static class TimeoutUsage {
        public static void main(String[] args) {
            Semaphore semaphore = new Semaphore(1);
            
            // çº¿ç¨‹1ï¼šé•¿æ—¶é—´æŒæœ‰è®¸å¯
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println("çº¿ç¨‹1è·å¾—è®¸å¯ï¼Œå¼€å§‹é•¿æ—¶é—´å·¥ä½œ");
                    Thread.sleep(5000);
                    System.out.println("çº¿ç¨‹1å®Œæˆå·¥ä½œ");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    semaphore.release();
                }
            }).start();
            
            // çº¿ç¨‹2ï¼šå°è¯•è·å–è®¸å¯ï¼Œä½†ä¼šè¶…æ—¶
            new Thread(() -> {
                try {
                    System.out.println("çº¿ç¨‹2å°è¯•è·å–è®¸å¯");
                    boolean acquired = semaphore.tryAcquire(2, TimeUnit.SECONDS);
                    if (acquired) {
                        System.out.println("çº¿ç¨‹2è·å¾—è®¸å¯");
                        semaphore.release();
                    } else {
                        System.out.println("çº¿ç¨‹2è·å–è®¸å¯è¶…æ—¶");
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
    
    /**
     * Semaphoreå®é™…åº”ç”¨åœºæ™¯
     */
    public static class PracticalApplications {
        
        /**
         * è¿æ¥æ± å®ç°
         */
        public static class ConnectionPool {
    private final Semaphore semaphore;
    private final List<Connection> connections;
    
    public ConnectionPool(int poolSize) {
        this.semaphore = new Semaphore(poolSize);
        this.connections = new ArrayList<>();
        
        // åˆå§‹åŒ–è¿æ¥æ± 
        for (int i = 0; i < poolSize; i++) {
            connections.add(new Connection("Connection-" + i));
        }
    }
    
    public Connection getConnection() throws InterruptedException {
        semaphore.acquire(); // è·å–è®¸å¯
        synchronized (connections) {
            return connections.remove(0);
        }
    }
    
    public void releaseConnection(Connection connection) {
        synchronized (connections) {
            connections.add(connection);
        }
        semaphore.release(); // é‡Šæ”¾è®¸å¯
    }
            
            public int getAvailableConnections() {
                return semaphore.availablePermits();
            }
    
    static class Connection {
        private final String name;
        
        public Connection(String name) {
            this.name = name;
        }
        
        public String getName() {
            return name;
                }
                
                @Override
                public String toString() {
                    return "Connection{name='" + name + "'}";
                }
            }
        }
        
        /**
         * é™æµå™¨å®ç°
         */
        public static class RateLimiter {
            private final Semaphore semaphore;
            private final int maxPermits;
            
            public RateLimiter(int maxPermits) {
                this.maxPermits = maxPermits;
                this.semaphore = new Semaphore(maxPermits);
            }
            
            public boolean tryAcquire() {
                return semaphore.tryAcquire();
            }
            
            public boolean tryAcquire(long timeout, TimeUnit unit) {
                try {
                    return semaphore.tryAcquire(timeout, unit);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return false;
                }
            }
            
            public void acquire() throws InterruptedException {
                semaphore.acquire();
            }
            
            public void release() {
                semaphore.release();
            }
            
            public int getAvailablePermits() {
                return semaphore.availablePermits();
            }
            
            public void reset() {
                semaphore.drainPermits();
                semaphore.release(maxPermits);
            }
        }
    }
}
```

## 5. Exchangerï¼ˆæ•°æ®äº¤æ¢å™¨ï¼‰

### 5.1 Exchanger åŸºæœ¬æ¦‚å¿µ

Exchangeræ˜¯ä¸€ä¸ªåŒæ­¥å·¥å…·ç±»ï¼Œç”¨äºä¸¤ä¸ªçº¿ç¨‹ä¹‹é—´äº¤æ¢æ•°æ®ã€‚

```java title="ExchangeråŸºæœ¬ç”¨æ³•ç¤ºä¾‹"
import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExchangerExamples {
    
    /**
     * ExchangeråŸºæœ¬ç”¨æ³•
     */
    public static class BasicUsage {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();
        ExecutorService executor = Executors.newFixedThreadPool(2);
            
            System.out.println("=== ExchangeråŸºæœ¬ç”¨æ³• ===");
        
        // ç”Ÿäº§è€…çº¿ç¨‹
        executor.submit(() -> {
            try {
                String data = "ç”Ÿäº§è€…æ•°æ®";
                System.out.println("ç”Ÿäº§è€…å‡†å¤‡äº¤æ¢æ•°æ®: " + data);
                String received = exchanger.exchange(data);
                System.out.println("ç”Ÿäº§è€…æ”¶åˆ°æ•°æ®: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // æ¶ˆè´¹è€…çº¿ç¨‹
        executor.submit(() -> {
            try {
                Thread.sleep(1000); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                String data = "æ¶ˆè´¹è€…æ•°æ®";
                System.out.println("æ¶ˆè´¹è€…å‡†å¤‡äº¤æ¢æ•°æ®: " + data);
                String received = exchanger.exchange(data);
                System.out.println("æ¶ˆè´¹è€…æ”¶åˆ°æ•°æ®: " + received);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        executor.shutdown();
    }
}
    
    /**
     * Exchangerè¶…æ—¶æ§åˆ¶
     */
    public static class TimeoutUsage {
        public static void main(String[] args) {
            Exchanger<String> exchanger = new Exchanger<>();
            
            // çº¿ç¨‹1ï¼šç«‹å³äº¤æ¢
            new Thread(() -> {
                try {
                    String data = "æ•°æ®1";
                    System.out.println("çº¿ç¨‹1å‡†å¤‡äº¤æ¢: " + data);
                    String received = exchanger.exchange(data, 2, TimeUnit.SECONDS);
                    System.out.println("çº¿ç¨‹1æ”¶åˆ°: " + received);
                } catch (InterruptedException | TimeoutException e) {
                    System.out.println("çº¿ç¨‹1äº¤æ¢è¶…æ—¶æˆ–ä¸­æ–­");
                }
            }).start();
            
            // çº¿ç¨‹2ï¼šå»¶è¿Ÿäº¤æ¢
            new Thread(() -> {
                try {
                    Thread.sleep(3000); // å»¶è¿Ÿ3ç§’
                    String data = "æ•°æ®2";
                    System.out.println("çº¿ç¨‹2å‡†å¤‡äº¤æ¢: " + data);
                    String received = exchanger.exchange(data);
                    System.out.println("çº¿ç¨‹2æ”¶åˆ°: " + received);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
    
    /**
     * Exchangerå®é™…åº”ç”¨åœºæ™¯
     */
    public static class PracticalApplications {
        
        /**
         * ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å¼
         */
        public static class ProducerConsumer {
    public static void main(String[] args) {
        Exchanger<List<String>> exchanger = new Exchanger<>();
        
        // ç”Ÿäº§è€…
        new Thread(() -> {
            try {
                List<String> buffer = new ArrayList<>();
                for (int i = 0; i < 5; i++) {
                    buffer.add("æ•°æ®-" + i);
                    if (buffer.size() == 3) {
                        System.out.println("ç”Ÿäº§è€…äº¤æ¢ç¼“å†²åŒº");
                        buffer = exchanger.exchange(buffer);
                        Thread.sleep(1000);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // æ¶ˆè´¹è€…
        new Thread(() -> {
            try {
                List<String> buffer = new ArrayList<>();
                for (int i = 0; i < 5; i++) {
                    if (buffer.isEmpty()) {
                        System.out.println("æ¶ˆè´¹è€…ç­‰å¾…æ•°æ®");
                        buffer = exchanger.exchange(buffer);
                    }
                    String data = buffer.remove(0);
                    System.out.println("æ¶ˆè´¹è€…å¤„ç†: " + data);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
            }
        }
        
        /**
         * æ•°æ®æ ¡éªŒåœºæ™¯
         */
        public static class DataValidator {
            public static void main(String[] args) {
                Exchanger<DataPacket> exchanger = new Exchanger<>();
                
                // æ•°æ®ç”Ÿæˆå™¨
                new Thread(() -> {
                    try {
                        for (int i = 0; i < 3; i++) {
                            DataPacket packet = new DataPacket("æ•°æ®åŒ…-" + i, i * 100);
                            System.out.println("ç”Ÿæˆæ•°æ®åŒ…: " + packet);
                            
                            DataPacket validatedPacket = exchanger.exchange(packet);
                            System.out.println("æ”¶åˆ°æ ¡éªŒç»“æœ: " + validatedPacket);
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
                
                // æ•°æ®æ ¡éªŒå™¨
                new Thread(() -> {
                    try {
                        for (int i = 0; i < 3; i++) {
                            DataPacket packet = exchanger.exchange(null);
                            System.out.println("æ ¡éªŒæ•°æ®åŒ…: " + packet);
                            
                            // æ¨¡æ‹Ÿæ ¡éªŒè¿‡ç¨‹
                            Thread.sleep(500);
                            packet.setValidated(true);
                            
                            exchanger.exchange(packet);
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }).start();
            }
            
            static class DataPacket {
                private String data;
                private int value;
                private boolean validated;
                
                public DataPacket(String data, int value) {
                    this.data = data;
                    this.value = value;
                    this.validated = false;
                }
                
                public void setValidated(boolean validated) {
                    this.validated = validated;
                }
                
                @Override
                public String toString() {
                    return "DataPacket{data='" + data + "', value=" + value + ", validated=" + validated + "}";
                }
            }
        }
    }
}
```

## 6. Phaserï¼ˆé˜¶æ®µå™¨ï¼‰

### 6.1 Phaser åŸºæœ¬æ¦‚å¿µ

Phaseræ˜¯ä¸€ä¸ªæ›´çµæ´»çš„åŒæ­¥å·¥å…·ç±»ï¼Œå¯ä»¥åŠ¨æ€è°ƒæ•´å‚ä¸åŒæ­¥çš„çº¿ç¨‹æ•°é‡ã€‚

```java title="PhaseråŸºæœ¬ç”¨æ³•ç¤ºä¾‹"
import java.util.concurrent.Phaser;

public class PhaserExamples {
    
    /**
     * PhaseråŸºæœ¬ç”¨æ³•
     */
    public static class BasicUsage {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(3); // åˆå§‹å‚ä¸çº¿ç¨‹æ•°ä¸º3
            
            System.out.println("=== PhaseråŸºæœ¬ç”¨æ³• ===");
        
        for (int i = 0; i < 3; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("çº¿ç¨‹ " + threadId + " å¼€å§‹ç¬¬ä¸€é˜¶æ®µ");
                    Thread.sleep(1000);
                    phaser.arriveAndAwaitAdvance(); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆç¬¬ä¸€é˜¶æ®µ
                    
                    System.out.println("çº¿ç¨‹ " + threadId + " å¼€å§‹ç¬¬äºŒé˜¶æ®µ");
                    Thread.sleep(1000);
                    phaser.arriveAndAwaitAdvance(); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆç¬¬äºŒé˜¶æ®µ
                    
                    System.out.println("çº¿ç¨‹ " + threadId + " å®Œæˆæ‰€æœ‰é˜¶æ®µ");
                    phaser.arriveAndDeregister(); // é€€å‡ºåŒæ­¥
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }
}
    
    /**
     * PhaseråŠ¨æ€æ³¨å†Œ
     */
    public static class DynamicRegistration {
        public static void main(String[] args) {
            Phaser phaser = new Phaser(1); // ä¸»çº¿ç¨‹æ³¨å†Œ
            
            for (int i = 0; i < 3; i++) {
                final int threadId = i;
            new Thread(() -> {
                    phaser.register(); // åŠ¨æ€æ³¨å†Œ
                try {
                        System.out.println("çº¿ç¨‹ " + threadId + " æ³¨å†Œï¼Œå½“å‰å‚ä¸æ•°: " + phaser.getRegisteredParties());
                    
                        System.out.println("çº¿ç¨‹ " + threadId + " å¼€å§‹å·¥ä½œ");
                        Thread.sleep(1000);
                        
                        phaser.arriveAndDeregister(); // å®Œæˆå·¥ä½œå¹¶æ³¨é”€
                        System.out.println("çº¿ç¨‹ " + threadId + " æ³¨é”€ï¼Œå½“å‰å‚ä¸æ•°: " + phaser.getRegisteredParties());
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
        
            // ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ
            phaser.arriveAndAwaitAdvance();
            System.out.println("æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ");
        }
    }
    
    /**
     * Phaserå®é™…åº”ç”¨åœºæ™¯
     */
    public static class PracticalApplications {
        
        /**
         * å¤šé˜¶æ®µä»»åŠ¡å¤„ç†
         */
        public static class MultiPhaseProcessor {
            public void processMultiPhaseTask() {
                Phaser phaser = new Phaser(1);
                
                for (int i = 0; i < 3; i++) {
                    final int workerId = i;
        new Thread(() -> {
                        phaser.register();
                        try {
                            // ç¬¬ä¸€é˜¶æ®µï¼šæ•°æ®å‡†å¤‡
                            System.out.println("å·¥ä½œè€… " + workerId + " å¼€å§‹æ•°æ®å‡†å¤‡");
                            Thread.sleep(1000);
                            phaser.arriveAndAwaitAdvance();
                            
                            // ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®å¤„ç†
                            System.out.println("å·¥ä½œè€… " + workerId + " å¼€å§‹æ•°æ®å¤„ç†");
                            Thread.sleep(1500);
                            phaser.arriveAndAwaitAdvance();
                            
                            // ç¬¬ä¸‰é˜¶æ®µï¼šç»“æœè¾“å‡º
                            System.out.println("å·¥ä½œè€… " + workerId + " å¼€å§‹ç»“æœè¾“å‡º");
                            Thread.sleep(800);
                            phaser.arriveAndDeregister();
                            
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }).start();
                }
                
                // ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰é˜¶æ®µå®Œæˆ
                phaser.arriveAndAwaitAdvance();
                System.out.println("æ‰€æœ‰é˜¶æ®µå®Œæˆ");
            }
        }
        
        /**
         * æ¸¸æˆå›åˆåˆ¶å¤„ç†
         */
        public static class GameRoundProcessor {
            public void processGameRounds(int playerCount, int roundCount) {
                Phaser phaser = new Phaser(playerCount);
                
                for (int i = 0; i < playerCount; i++) {
                    final int playerId = i;
                    new Thread(() -> {
                        try {
                            for (int round = 0; round < roundCount; round++) {
                                System.out.println("ç©å®¶ " + playerId + " å¼€å§‹ç¬¬ " + round + " è½®");
                                
                                // æ¨¡æ‹Ÿç©å®¶è¡ŒåŠ¨
                                Thread.sleep(500 + playerId * 100);
                                
                                System.out.println("ç©å®¶ " + playerId + " å®Œæˆç¬¬ " + round + " è½®");
                                phaser.arriveAndAwaitAdvance(); // ç­‰å¾…æ‰€æœ‰ç©å®¶å®Œæˆå½“å‰è½®
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
                }
            }
        }
    }
}
```

## 7. å¹¶å‘å·¥å…·ç±»æœ€ä½³å®è·µ

### 7.1 å·¥å…·ç±»é€‰æ‹©æŒ‡å—

:::tip æ ¸å¿ƒåŸåˆ™
é€‰æ‹©åˆé€‚çš„å¹¶å‘å·¥å…·ç±»éœ€è¦è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š
- **åŒæ­¥éœ€æ±‚**ï¼šä¸€æ¬¡æ€§ç­‰å¾…è¿˜æ˜¯å¾ªç¯ç­‰å¾…
- **çº¿ç¨‹æ•°é‡**ï¼šå›ºå®šæ•°é‡è¿˜æ˜¯åŠ¨æ€å˜åŒ–
- **è¶…æ—¶è¦æ±‚**ï¼šæ˜¯å¦éœ€è¦è¶…æ—¶æ§åˆ¶
- **å…¬å¹³æ€§**ï¼šæ˜¯å¦éœ€è¦å…¬å¹³æ€§ä¿è¯
:::

```java title="å·¥å…·ç±»é€‰æ‹©æŒ‡å—ç¤ºä¾‹"
public class ToolSelectionGuide {
    
    /**
     * å·¥å…·ç±»é€‰æ‹©æŒ‡å—
     */
    public static void selectionGuide() {
        System.out.println("=== å¹¶å‘å·¥å…·ç±»é€‰æ‹©æŒ‡å— ===");
        
        // 1. ä¸€æ¬¡æ€§ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ
        System.out.println("1. ä¸€æ¬¡æ€§ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ -> CountDownLatch");
        System.out.println("   é€‚ç”¨åœºæ™¯ï¼šæœåŠ¡å¯åŠ¨ã€æ•°æ®åŠ è½½ã€ä»»åŠ¡å®Œæˆç­‰å¾…");
        
        // 2. å¾ªç¯ç­‰å¾…å¤šä¸ªçº¿ç¨‹åŒæ­¥
        System.out.println("2. å¾ªç¯ç­‰å¾…å¤šä¸ªçº¿ç¨‹åŒæ­¥ -> CyclicBarrier");
        System.out.println("   é€‚ç”¨åœºæ™¯ï¼šå¤šé˜¶æ®µå¤„ç†ã€æ¸¸æˆå›åˆã€çŸ©é˜µè®¡ç®—");
        
        // 3. æ§åˆ¶å¹¶å‘è®¿é—®æ•°é‡
        System.out.println("3. æ§åˆ¶å¹¶å‘è®¿é—®æ•°é‡ -> Semaphore");
        System.out.println("   é€‚ç”¨åœºæ™¯ï¼šè¿æ¥æ± ã€é™æµå™¨ã€èµ„æºæ§åˆ¶");
        
        // 4. ä¸¤ä¸ªçº¿ç¨‹äº¤æ¢æ•°æ®
        System.out.println("4. ä¸¤ä¸ªçº¿ç¨‹äº¤æ¢æ•°æ® -> Exchanger");
        System.out.println("   é€‚ç”¨åœºæ™¯ï¼šç”Ÿäº§è€…æ¶ˆè´¹è€…ã€æ•°æ®æ ¡éªŒã€ç¼“å†²åŒºäº¤æ¢");
        
        // 5. åŠ¨æ€è°ƒæ•´å‚ä¸çº¿ç¨‹æ•°é‡
        System.out.println("5. åŠ¨æ€è°ƒæ•´å‚ä¸çº¿ç¨‹æ•°é‡ -> Phaser");
        System.out.println("   é€‚ç”¨åœºæ™¯ï¼šå¤šé˜¶æ®µä»»åŠ¡ã€æ¸¸æˆå¤„ç†ã€å¤æ‚åŒæ­¥");
    }
}
```

### 7.2 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```java title="æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹"
public class PerformanceOptimization {
    
    /**
     * é¿å…è¿‡åº¦åŒæ­¥
     */
    public static class AvoidOverSynchronization {
        public void optimizedApproach() {
            // ä¸æ¨èï¼šè¿‡åº¦ä½¿ç”¨åŒæ­¥
            CountDownLatch latch = new CountDownLatch(1);
            Semaphore semaphore = new Semaphore(1);
            
            // æ¨èï¼šé€‰æ‹©åˆé€‚çš„å·¥å…·
            // ç®€å•ç­‰å¾… -> CountDownLatch
            // èµ„æºæ§åˆ¶ -> Semaphore
            // æ•°æ®äº¤æ¢ -> Exchanger
        }
    }
    
    /**
     * åˆç†è®¾ç½®è¶…æ—¶
     */
    public static class TimeoutOptimization {
        public void optimizedTimeout() {
            // è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
            Semaphore semaphore = new Semaphore(1);
            
            try {
                // æ ¹æ®ä¸šåŠ¡éœ€æ±‚è®¾ç½®è¶…æ—¶æ—¶é—´
                boolean acquired = semaphore.tryAcquire(5, TimeUnit.SECONDS);
                if (acquired) {
                    // å¤„ç†ä¸šåŠ¡é€»è¾‘
                    semaphore.release();
                } else {
                    // å¤„ç†è¶…æ—¶æƒ…å†µ
                    System.out.println("è·å–èµ„æºè¶…æ—¶");
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    /**
     * é¿å…æ­»é”
     */
    public static class DeadlockPrevention {
        public void preventDeadlock() {
            // 1. å›ºå®šèµ„æºè·å–é¡ºåº
            Semaphore sem1 = new Semaphore(1);
            Semaphore sem2 = new Semaphore(1);
            
            // æ€»æ˜¯å…ˆè·å–sem1ï¼Œå†è·å–sem2
    try {
        sem1.acquire();
        sem2.acquire();
        // ä½¿ç”¨èµ„æº
    } finally {
        sem2.release();
        sem1.release();
            }
            
            // 2. ä½¿ç”¨è¶…æ—¶æœºåˆ¶
            try {
                if (sem1.tryAcquire(1, TimeUnit.SECONDS)) {
                    if (sem2.tryAcquire(1, TimeUnit.SECONDS)) {
                        // ä½¿ç”¨èµ„æº
                        sem2.release();
                    }
                    sem1.release();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

### 7.3 å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

| é™·é˜± | é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| **CountDownLatché‡ç”¨** | CountDownLatchæ˜¯ä¸€æ¬¡æ€§çš„ | ä½¿ç”¨CyclicBarrieræˆ–Phaser |
| **CyclicBarrierçº¿ç¨‹æ•°ä¸åŒ¹é…** | çº¿ç¨‹æ•°å˜åŒ–å¯¼è‡´æ­»é” | ä½¿ç”¨PhaseråŠ¨æ€è°ƒæ•´ |
| **Semaphoreå¿˜è®°é‡Šæ”¾** | å¯¼è‡´å…¶ä»–çº¿ç¨‹æ— æ³•è·å–èµ„æº | ä½¿ç”¨try-finallyç¡®ä¿é‡Šæ”¾ |
| **Exchangerè¶…æ—¶å¤„ç†** | ä¸€ä¸ªçº¿ç¨‹è¶…æ—¶å¯¼è‡´å¦ä¸€ä¸ªçº¿ç¨‹é˜»å¡ | ä½¿ç”¨è¶…æ—¶ç‰ˆæœ¬çš„exchangeæ–¹æ³• |
| **Phaserè¿‡åº¦æ³¨å†Œ** | æ³¨å†Œè¿‡å¤šçº¿ç¨‹å½±å“æ€§èƒ½ | åˆç†æ§åˆ¶æ³¨å†Œæ•°é‡ |

## 8. æ€»ç»“

Javaå¹¶å‘å·¥å…·ç±»ä¸ºå¤šçº¿ç¨‹ç¼–ç¨‹æä¾›äº†å¼ºå¤§è€Œçµæ´»çš„æ”¯æŒã€‚

### 8.1 å…³é”®è¦ç‚¹

1. **å·¥å…·ç±»ç‰¹æ€§**ï¼šCountDownLatchã€CyclicBarrierã€Semaphoreã€Exchangerã€Phaser
2. **ä½¿ç”¨åœºæ™¯**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·ç±»
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé¿å…è¿‡åº¦åŒæ­¥ã€åˆç†è®¾ç½®è¶…æ—¶ã€é˜²æ­¢æ­»é”
4. **æœ€ä½³å®è·µ**ï¼šæ­£ç¡®ä½¿ç”¨ã€åŠæ—¶æ¸…ç†ã€å¼‚å¸¸å¤„ç†

### 8.2 é€‰æ‹©å»ºè®®

| åœºæ™¯ | æ¨èå·¥å…·ç±» | åŸå›  |
|------|------------|------|
| **ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ** | CountDownLatch | ä¸€æ¬¡æ€§ç­‰å¾…ï¼Œç®€å•é«˜æ•ˆ |
| **å¾ªç¯åŒæ­¥** | CyclicBarrier | æ”¯æŒé‡ç½®ï¼Œé€‚åˆå¤šè½®å¤„ç† |
| **èµ„æºæ§åˆ¶** | Semaphore | æ§åˆ¶å¹¶å‘æ•°é‡ï¼Œæ”¯æŒå…¬å¹³æ€§ |
| **æ•°æ®äº¤æ¢** | Exchanger | ä¸“é—¨ç”¨äºä¸¤ä¸ªçº¿ç¨‹äº¤æ¢æ•°æ® |
| **åŠ¨æ€åŒæ­¥** | Phaser | æ”¯æŒåŠ¨æ€è°ƒæ•´å‚ä¸çº¿ç¨‹æ•°é‡ |

### 8.3 å­¦ä¹ å»ºè®®

1. **ç†è§£åŸç†**ï¼šæ·±å…¥ç†è§£å„ç§å·¥å…·ç±»çš„å·¥ä½œåŸç†
2. **å®è·µéªŒè¯**ï¼šé€šè¿‡ç¼–å†™ä»£ç éªŒè¯ä¸åŒå·¥å…·ç±»çš„æ•ˆæœ
3. **åœºæ™¯é€‰æ‹©**ï¼šæ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„å·¥å…·ç±»
4. **æ€§èƒ½æµ‹è¯•**ï¼šå¯¹æ¯”ä¸åŒå®ç°æ–¹å¼çš„æ€§èƒ½å·®å¼‚

é€šè¿‡æ·±å…¥ç†è§£å’Œç†Ÿç»ƒè¿ç”¨è¿™äº›å¹¶å‘å·¥å…·ç±»ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå‡ºæ›´åŠ é«˜æ•ˆã€å¥å£®å’Œå¯ç»´æŠ¤çš„Javaå¹¶å‘åº”ç”¨ç¨‹åºã€‚ 