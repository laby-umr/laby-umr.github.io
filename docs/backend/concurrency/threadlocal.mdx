---
sidebar_position: 7
title: "Java ThreadLocalè¯¦è§£"
description: "å…¨é¢ä»‹ç»Java ThreadLocalã€çº¿ç¨‹æœ¬åœ°å˜é‡ã€å†…å­˜æ³„æ¼ä¸æœ€ä½³å®è·µ"
authors: [Laby]
last_update:
  date: 2025-01-07
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TOCInline from '@theme/TOCInline';

# Java ThreadLocal è¯¦è§£

ThreadLocalæ˜¯Javaä¸­ç”¨äºåˆ›å»ºçº¿ç¨‹å±€éƒ¨å˜é‡çš„ç±»ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œçº¿ç¨‹é—´ä¸ä¼šç›¸äº’å½±å“ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»ThreadLocalçš„åŸç†ã€ä½¿ç”¨æ–¹æ³•å’Œæœ€ä½³å®è·µã€‚

:::info æœ¬æ–‡å†…å®¹æ¦‚è§ˆ
<TOCInline toc={toc} />
:::

:::tip æ ¸å¿ƒä»·å€¼
**ThreadLocal = çº¿ç¨‹éš”ç¦» + ä¸Šä¸‹æ–‡ä¼ é€’ + æ— é”å¹¶å‘ + èµ„æºç®¡ç†**
- ğŸ§µ **çº¿ç¨‹éš”ç¦»**ï¼šä¸ºæ¯ä¸ªçº¿ç¨‹æä¾›ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œé¿å…å…±äº«å†²çª
- ğŸ”„ **ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šåœ¨åŒä¸€çº¿ç¨‹çš„ä¸åŒæ–¹æ³•ä¹‹é—´ä¼ é€’æ•°æ®
- ğŸš€ **æ— é”å¹¶å‘**ï¼šæ— éœ€åŒæ­¥å³å¯å®ç°çº¿ç¨‹å®‰å…¨
- ğŸ“Š **èµ„æºç®¡ç†**ï¼šç®¡ç†çº¿ç¨‹çº§åˆ«çš„èµ„æºï¼ˆå¦‚æ•°æ®åº“è¿æ¥ã€ç”¨æˆ·ä¼šè¯ï¼‰
:::

## 1. ThreadLocalæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯ThreadLocalï¼Ÿ

```mermaid
graph LR
    ThreadA[Thread A] --> TLA[ThreadLocal<br>å˜é‡å‰¯æœ¬ A]
    ThreadB[Thread B] --> TLB[ThreadLocal<br>å˜é‡å‰¯æœ¬ B]
    ThreadC[Thread C] --> TLC[ThreadLocal<br>å˜é‡å‰¯æœ¬ C]
    
    class ThreadA,ThreadB,ThreadC thread;
    class TLA,TLB,TLC local;
    
    classDef thread fill:#6495ED,stroke:#333,stroke-width:2px
    classDef local fill:#90EE90,stroke:#333,stroke-width:1px
```

:::tip æ ¸å¿ƒæ¦‚å¿µ
ThreadLocalæ˜¯Javaä¸­ç”¨äºåˆ›å»ºçº¿ç¨‹å±€éƒ¨å˜é‡çš„ç±»ï¼Œå®ƒæä¾›äº†çº¿ç¨‹éš”ç¦»çš„å­˜å‚¨æœºåˆ¶ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œçº¿ç¨‹é—´ä¸ä¼šç›¸äº’å½±å“ã€‚
:::

### 1.2 ThreadLocalçš„ç‰¹ç‚¹

<div className="card">
<div className="card__header">
<h4>ThreadLocalçš„å…³é”®ç‰¹æ€§</h4>
</div>
<div className="card__body">

| ç‰¹ç‚¹ | å…·ä½“ä½“ç° | ä¸šåŠ¡ä»·å€¼ |
|------|----------|----------|
| **çº¿ç¨‹éš”ç¦»** | æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹å˜é‡å‰¯æœ¬ | é¿å…çº¿ç¨‹é—´æ•°æ®ç«äº‰ |
| **çº¿ç¨‹å®‰å…¨** | å¤©ç„¶çº¿ç¨‹å®‰å…¨ï¼Œæ— éœ€åŒæ­¥ | ç®€åŒ–ç¼–ç¨‹ï¼Œæé«˜æ€§èƒ½ |
| **å†…å­˜æ³„æ¼é£é™©** | ä½¿ç”¨ä¸å½“å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ | éœ€è¦æ­£ç¡®ç®¡ç†ç”Ÿå‘½å‘¨æœŸ |
| **é€‚ç”¨åœºæ™¯** | çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’ã€æ•°æ®åº“è¿æ¥ç­‰ | è§£å†³ç‰¹å®šä¸šåŠ¡é—®é¢˜ |
| **æ€§èƒ½å½±å“** | è®¿é—®é€Ÿåº¦å¿«ï¼Œå†…å­˜å¼€é”€å° | é€‚åˆé«˜é¢‘è®¿é—®åœºæ™¯ |

</div>
</div>

```mermaid
graph TD
    A[ThreadLocalç‰¹æ€§] --> B[çº¿ç¨‹éš”ç¦»]
    A --> C[æ— é”çº¿ç¨‹å®‰å…¨]
    A --> D[æ–¹æ³•é—´å…±äº«]
    A --> E[çŠ¶æ€ç®¡ç†]
    
    B --> B1[ç‹¬ç«‹å˜é‡å‰¯æœ¬]
    C --> C1[æ— éœ€åŒæ­¥æ“ä½œ]
    D --> D1[ä¸Šä¸‹æ–‡ä¼ é€’]
    E --> E1[è¯·æ±‚èŒƒå›´å­˜å‚¨]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B,C,D,E fill:#bbf,stroke:#333
```

### 1.3 ThreadLocalåŸºæœ¬ä½¿ç”¨

<Tabs>
  <TabItem value="basic" label="åŸºæœ¬ä½¿ç”¨" default>
  ```java
  /**
   * ThreadLocalåŸºæœ¬ä½¿ç”¨ç¤ºä¾‹
   */
  public static class BasicUsage {
      // åˆ›å»ºThreadLocalå˜é‡
      private static final ThreadLocal<String> threadLocal = new ThreadLocal<>();
      
      public static void main(String[] args) {
          // çº¿ç¨‹1
          Thread thread1 = new Thread(() -> {
              // è®¾ç½®å€¼ - åªå½±å“å½“å‰çº¿ç¨‹
              threadLocal.set("Thread1-Value");
              // è·å–å€¼ - åªèƒ½è·å–å½“å‰çº¿ç¨‹è®¾ç½®çš„å€¼
              System.out.println("Thread1: " + threadLocal.get());
              
              // æ¸…ç†ThreadLocal - é˜²æ­¢å†…å­˜æ³„æ¼
              threadLocal.remove();
          });
          
          // çº¿ç¨‹2
          Thread thread2 = new Thread(() -> {
              // çº¿ç¨‹2è®¾ç½®çš„å€¼ä¸çº¿ç¨‹1äº’ä¸å¹²æ‰°
              threadLocal.set("Thread2-Value");
              System.out.println("Thread2: " + threadLocal.get());
              
              // æ¸…ç†ThreadLocal
              threadLocal.remove();
          });
          
          // å¯åŠ¨çº¿ç¨‹
          thread1.start();
          thread2.start();
          
          try {
              thread1.join();
              thread2.join();
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="initial_value" label="åˆå§‹å€¼">
  ```java
  /**
   * ThreadLocalåˆå§‹å€¼ç¤ºä¾‹
   */
  public static class InitialValueUsage {
      // ä½¿ç”¨withInitialæ–¹æ³•æä¾›åˆå§‹å€¼
      private static final ThreadLocal<Integer> counter = 
          ThreadLocal.withInitial(() -> 0);
      
      // ä½¿ç”¨åŒ¿åå†…éƒ¨ç±»æ–¹å¼æä¾›åˆå§‹å€¼
      private static final ThreadLocal<List<String>> itemList = 
          new ThreadLocal<List<String>>() {
              @Override
              protected List<String> initialValue() {
                  return new ArrayList<>();
              }
          };
      
      public static void main(String[] args) {
          // å¤šä¸ªçº¿ç¨‹è®¿é—®ThreadLocal
          for (int i = 0; i < 3; i++) {
              final int threadId = i;
              new Thread(() -> {
                  // è·å–åˆå§‹å€¼ - æ— éœ€æ£€æŸ¥null
                  System.out.println("çº¿ç¨‹" + threadId + "åˆå§‹è®¡æ•°: " + counter.get()); // 0
                  
                  // ä¿®æ”¹å€¼
                  counter.set(counter.get() + 1);
                  System.out.println("çº¿ç¨‹" + threadId + "ä¿®æ”¹åè®¡æ•°: " + counter.get()); // 1
                  
                  // ä½¿ç”¨itemListæ·»åŠ å…ƒç´ 
                  itemList.get().add("Item-" + threadId);
                  System.out.println("çº¿ç¨‹" + threadId + "é¡¹ç›®åˆ—è¡¨: " + itemList.get());
                  
                  // æ¸…ç†ThreadLocal
                  counter.remove();
                  itemList.remove();
              }).start();
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="using_helper" label="è¾…åŠ©ç±»">
  ```java
  /**
   * ThreadLocalè¾…åŠ©ç±»ç¤ºä¾‹
   */
  public static class ThreadLocalHelper {
      // å®šä¹‰ä¸€ä¸ªé™æ€å·¥å…·ç±»æ¥ç®¡ç†ThreadLocal
      public static class UserContextHolder {
          private static final ThreadLocal<UserContext> CONTEXT = new ThreadLocal<>();
          
          public static void set(UserContext context) {
              CONTEXT.set(context);
          }
          
          public static UserContext get() {
              return CONTEXT.get();
          }
          
          public static void clear() {
              CONTEXT.remove();
          }
          
          // ä½¿ç”¨try-with-resourcesæ¨¡å¼è‡ªåŠ¨æ¸…ç†
          public static class Context implements AutoCloseable {
              public Context(UserContext userContext) {
                  CONTEXT.set(userContext);
              }
              
              @Override
              public void close() {
                  CONTEXT.remove();
              }
          }
      }
      
      // ç”¨æˆ·ä¸Šä¸‹æ–‡ç±»
      public static class UserContext {
          private final String userId;
          private final String username;
          
          public UserContext(String userId, String username) {
              this.userId = userId;
              this.username = username;
          }
          
          public String getUserId() {
              return userId;
          }
          
          public String getUsername() {
              return username;
          }
      }
      
      // ç¤ºä¾‹ç”¨æ³•
      public static void main(String[] args) {
          // ä½¿ç”¨try-with-resourcesè‡ªåŠ¨æ¸…ç†
          try (UserContextHolder.Context ignored = 
                   new UserContextHolder.Context(new UserContext("123", "Alice"))) {
              
              // åœ¨å½“å‰çº¿ç¨‹çš„ä»»æ„ä½ç½®è®¿é—®ç”¨æˆ·ä¸Šä¸‹æ–‡
              UserContext ctx = UserContextHolder.get();
              System.out.println("å½“å‰ç”¨æˆ·: " + ctx.getUsername());
              
              // è°ƒç”¨å…¶ä»–æ–¹æ³•ï¼Œæ— éœ€ä¼ é€’å‚æ•°
              processRequest();
          }
          
          // æ­¤æ—¶ThreadLocalå·²è‡ªåŠ¨æ¸…ç†
      }
      
      private static void processRequest() {
          // è·å–å½“å‰ç”¨æˆ·ä¸Šä¸‹æ–‡ï¼Œæ— éœ€é€šè¿‡å‚æ•°ä¼ é€’
          UserContext ctx = UserContextHolder.get();
          if (ctx != null) {
              System.out.println("å¤„ç†ç”¨æˆ·è¯·æ±‚: " + ctx.getUserId());
          }
      }
  }
  ```
  </TabItem>
</Tabs>

## 2. ThreadLocalåŸç†

### 2.1 ThreadLocalæºç åˆ†æ

```mermaid
classDiagram
    class Thread {
        ThreadLocalMap threadLocals
        ThreadLocalMap inheritableThreadLocals
    }
    
    class ThreadLocal {
        <<generic T>>
        -int threadLocalHashCode
        +T get()
        +void set(T value)
        +void remove()
        #T initialValue()
        +static ThreadLocal withInitial()
    }
    
    class ThreadLocalMap {
        -Entry[] table
        -int size
        -int threshold
        -void set(ThreadLocal key, Object value)
        -Entry getEntry(ThreadLocal key)
        -void remove(ThreadLocal key)
        -void resize()
        -void cleanSomeSlots()
    }
    
    class Entry {
        <<WeakReference>>
        +ThreadLocal key
        +Object value
    }
    
    Thread "1" --> "0..*" ThreadLocalMap
    ThreadLocalMap "1" --> "0..*" Entry
    Entry ..> ThreadLocal
```

<div className="card">
<div className="card__header">
<h4>ThreadLocalæ ¸å¿ƒæ–¹æ³•</h4>
</div>
<div className="card__body">

| æ–¹æ³• | æè¿° | å…³é”®å®ç° |
|------|------|----------|
| **get()** | è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„å€¼ | è·å–å½“å‰çº¿ç¨‹ThreadLocalMapï¼Œç„¶åæ ¹æ®ThreadLocalæŸ¥æ‰¾å¯¹åº”çš„Entry |
| **set(T)** | è®¾ç½®å½“å‰çº¿ç¨‹å¯¹åº”çš„å€¼ | è·å–å½“å‰çº¿ç¨‹ThreadLocalMapï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºï¼Œç„¶åæ·»åŠ æˆ–æ›´æ–°Entry |
| **remove()** | ç§»é™¤å½“å‰çº¿ç¨‹å¯¹åº”çš„å€¼ | è·å–å½“å‰çº¿ç¨‹ThreadLocalMapï¼Œå¦‚æœå­˜åœ¨åˆ™ç§»é™¤å¯¹åº”çš„Entry |
| **initialValue()** | è¿”å›åˆå§‹å€¼ | é»˜è®¤è¿”å›nullï¼Œå­ç±»å¯è¦†ç›–æä¾›åˆå§‹å€¼ |
| **withInitial()** | åˆ›å»ºå¸¦åˆå§‹å€¼çš„ThreadLocal | è¿”å›å¸¦æœ‰æŒ‡å®šSupplierçš„ThreadLocalå®ç° |

</div>
</div>

<Tabs>
  <TabItem value="get_method" label="get()æ–¹æ³•" default>
  ```java
  /**
   * è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„å€¼
   */
  public T get() {
      // è·å–å½“å‰çº¿ç¨‹
      Thread t = Thread.currentThread();
      // è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalMap
      ThreadLocalMap map = getMap(t);
      if (map != null) {
          // å¦‚æœmapå­˜åœ¨ï¼Œåˆ™æŸ¥æ‰¾å½“å‰ThreadLocalå¯¹åº”çš„Entry
          ThreadLocalMap.Entry e = map.getEntry(this);
          if (e != null) {
              @SuppressWarnings("unchecked")
              T result = (T)e.value;
              return result;
          }
      }
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å€¼ï¼Œåˆ™åˆå§‹åŒ–
      return setInitialValue();
  }
  
  // åˆå§‹åŒ–å€¼
  private T setInitialValue() {
      // è·å–åˆå§‹å€¼ï¼ˆé»˜è®¤ä¸ºnullï¼Œå­ç±»å¯ä»¥é‡å†™ï¼‰
      T value = initialValue();
      Thread t = Thread.currentThread();
      ThreadLocalMap map = getMap(t);
      if (map != null) {
          // å¦‚æœmapå­˜åœ¨ï¼Œè®¾ç½®åˆå§‹å€¼
          map.set(this, value);
      } else {
          // å¦åˆ™åˆ›å»ºThreadLocalMap
          createMap(t, value);
      }
      return value;
  }
  ```
  
  **å·¥ä½œæµç¨‹ï¼š**
  1. è·å–å½“å‰çº¿ç¨‹
  2. è·å–çº¿ç¨‹ä¸­çš„ThreadLocalMap
  3. å¦‚æœmapå­˜åœ¨ä¸”æ‰¾åˆ°Entryï¼Œè¿”å›å¯¹åº”çš„å€¼
  4. å¦åˆ™åˆå§‹åŒ–ä¸€ä¸ªå€¼å¹¶è¿”å›
  
  </TabItem>
  <TabItem value="set_method" label="set()æ–¹æ³•">
  ```java
  /**
   * è®¾ç½®å½“å‰çº¿ç¨‹å¯¹åº”çš„å€¼
   */
  public void set(T value) {
      // è·å–å½“å‰çº¿ç¨‹
      Thread t = Thread.currentThread();
      // è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalMap
      ThreadLocalMap map = getMap(t);
      if (map != null) {
          // å¦‚æœmapå­˜åœ¨ï¼Œæ›´æ–°å€¼
          map.set(this, value);
      } else {
          // å¦åˆ™åˆ›å»ºThreadLocalMap
          createMap(t, value);
      }
  }
  
  // åˆ›å»ºThreadLocalMap
  void createMap(Thread t, T firstValue) {
      // åˆ›å»ºThreadLocalMapï¼Œå¹¶å°†å½“å‰ThreadLocalå’Œå€¼ä½œä¸ºç¬¬ä¸€ä¸ªEntry
      t.threadLocals = new ThreadLocalMap(this, firstValue);
  }
  ```
  
  **å·¥ä½œæµç¨‹ï¼š**
  1. è·å–å½“å‰çº¿ç¨‹
  2. è·å–çº¿ç¨‹ä¸­çš„ThreadLocalMap
  3. å¦‚æœmapå­˜åœ¨ï¼Œè®¾ç½®æˆ–æ›´æ–°Entry
  4. å¦åˆ™åˆ›å»ºæ–°çš„ThreadLocalMap
  
  </TabItem>
  <TabItem value="remove_method" label="remove()æ–¹æ³•">
  ```java
  /**
   * ç§»é™¤å½“å‰çº¿ç¨‹å¯¹åº”çš„å€¼
   */
  public void remove() {
      // è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalMap
      ThreadLocalMap m = getMap(Thread.currentThread());
      if (m != null) {
          // ä»mapä¸­ç§»é™¤å½“å‰ThreadLocalå¯¹åº”çš„Entry
          m.remove(this);
      }
  }
  ```
  
  **å·¥ä½œæµç¨‹ï¼š**
  1. è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalMap
  2. å¦‚æœmapå­˜åœ¨ï¼Œç§»é™¤å¯¹åº”çš„Entry
  3. è¿™ä¸€æ­¥å¾ˆé‡è¦ï¼Œèƒ½å¤Ÿé¿å…å†…å­˜æ³„æ¼
  
  </TabItem>
</Tabs>

### 2.2 ThreadLocalMapç»“æ„

```mermaid
graph TD
    A[ThreadLocalMap] --> B[Entryæ•°ç»„]
    B --> C[Entry]
    C --> D[key: WeakReference<ThreadLocal>]
    C --> E[value: Object]
    A --> F[çº¿æ€§æ¢æµ‹æ³•è§£å†³å“ˆå¸Œå†²çª]
    A --> G[æ‡’æƒ°æ¸…ç†ç­–ç•¥]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333
    style D fill:#fbf,stroke:#333
    style G fill:#ff9,stroke:#333
```

<Tabs>
  <TabItem value="entry_structure" label="Entryç»“æ„" default>
  ```java
  /**
   * ThreadLocalMapçš„Entryç»§æ‰¿è‡ªWeakReference
   */
  static class Entry extends WeakReference<ThreadLocal<?>> {
      /** ä¸è¿™ä¸ªThreadLocalå…³è”çš„å€¼ */
      Object value;
  
      Entry(ThreadLocal<?> k, Object v) {
          super(k);  // keyä½œä¸ºå¼±å¼•ç”¨ä¼ ç»™çˆ¶ç±»
          value = v; // valueæ˜¯å¼ºå¼•ç”¨
      }
  }
  ```
  
  **å…³é”®ç‰¹æ€§ï¼š**
  - Entryç»§æ‰¿è‡ªWeakReferenceï¼Œkeyæ˜¯ThreadLocalçš„å¼±å¼•ç”¨
  - å½“ThreadLocalå¯¹è±¡æ²¡æœ‰å¼ºå¼•ç”¨æ—¶ï¼Œkeyä¼šè¢«åƒåœ¾æ”¶é›†å™¨å›æ”¶
  - ä½†valueä»ç„¶æ˜¯å¼ºå¼•ç”¨ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
  - è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå¿…é¡»è°ƒç”¨remove()çš„åŸå› 
  
  </TabItem>
  <TabItem value="hash_algorithm" label="å“ˆå¸Œç®—æ³•">
  ```java
  /**
   * ThreadLocalä¸­çš„å“ˆå¸Œç ç”Ÿæˆ
   */
  private final int threadLocalHashCode = nextHashCode();
  
  // åŸå­æ›´æ–°ä¸‹ä¸€ä¸ªå“ˆå¸Œç 
  private static AtomicInteger nextHashCode = new AtomicInteger();
  
  // é­”æ•° - é»„é‡‘åˆ†å‰²æ•° * 2^32
  private static final int HASH_INCREMENT = 0x61c88647;
  
  // ç”Ÿæˆä¸‹ä¸€ä¸ªå“ˆå¸Œç 
  private static int nextHashCode() {
      return nextHashCode.getAndAdd(HASH_INCREMENT);
  }
  
  /**
   * ThreadLocalMapä¸­çš„å“ˆå¸Œè®¡ç®—
   */
  int i = key.threadLocalHashCode & (table.length - 1);
  ```
  
  **ç‰¹ç‚¹ï¼š**
  1. ä½¿ç”¨æ–æ³¢é‚£å¥‘æ•£åˆ—ï¼ˆé»„é‡‘åˆ†å‰²æ•°ï¼‰
  2. é€šè¿‡AtomicIntegerç”Ÿæˆé€’å¢å“ˆå¸Œç 
  3. æ¯ä¸ªThreadLocalå®ä¾‹è·å–å”¯ä¸€å“ˆå¸Œç 
  4. å“ˆå¸Œç å‡åŒ€åˆ†å¸ƒï¼Œå‡å°‘å†²çª
  5. å“ˆå¸Œè¡¨å¤§å°å¿…é¡»æ˜¯2çš„å¹‚ï¼Œé€šè¿‡ä½ä¸æ“ä½œè®¡ç®—ç´¢å¼•
  
  </TabItem>
  <TabItem value="hash_collision" label="å“ˆå¸Œå†²çª">
  ```java
  /**
   * ThreadLocalMapå¤„ç†å“ˆå¸Œå†²çªçš„æ–¹æ³•
   */
  private void set(ThreadLocal<?> key, Object value) {
      Entry[] tab = table;
      int len = tab.length;
      // è®¡ç®—åˆå§‹ç´¢å¼•
      int i = key.threadLocalHashCode & (len-1);
  
      // çº¿æ€§æ¢æµ‹æŸ¥æ‰¾å¯ç”¨ä½ç½®
      for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
          ThreadLocal<?> k = e.get();
          
          // æ‰¾åˆ°å¯¹åº”çš„Entryï¼Œæ›´æ–°å€¼
          if (k == key) {
              e.value = value;
              return;
          }
          
          // æ¸…ç†å·²è¢«GCå›æ”¶çš„key
          if (k == null) {
              replaceStaleEntry(key, value, i);
              return;
          }
      }
      
      // åˆ›å»ºæ–°Entry
      tab[i] = new Entry(key, value);
      // å¢åŠ sizeå¹¶æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
      // ...
  }
  
  // è®¡ç®—ä¸‹ä¸€ä¸ªç´¢å¼•ï¼ˆçº¿æ€§æ¢æµ‹ï¼‰
  private static int nextIndex(int i, int len) {
      return ((i + 1 < len) ? i + 1 : 0);
  }
  ```
  
  **çº¿æ€§æ¢æµ‹ç­–ç•¥:**
  1. å‘ç”Ÿå†²çªæ—¶ï¼ŒæŸ¥æ‰¾ä¸‹ä¸€ä¸ªä½ç½®
  2. é‡åˆ°è¡¨å°¾åˆ™ä»å¤´å¼€å§‹
  3. åŒæ—¶å¤„ç†è¿‡æœŸEntry
  4. æŒ‰éœ€æ‰©å®¹æ•°ç»„
  
  </TabItem>
  <TabItem value="entry_cleanup" label="Entryæ¸…ç†">
  ```java
  /**
   * ThreadLocalMapæ¸…ç†è¿‡æœŸEntryçš„æ–¹æ³•
   */
  private boolean cleanSomeSlots(int i, int n) {
      boolean removed = false;
      Entry[] tab = table;
      int len = tab.length;
      do {
          i = nextIndex(i, len);
          Entry e = tab[i];
          // å¦‚æœæ‰¾åˆ°keyä¸ºnullçš„Entry
          if (e != null && e.get() == null) {
              // è¿›è¡Œæ›´å½»åº•çš„æ¸…ç†
              n = len;
              removed = true;
              i = expungeStaleEntry(i);
          }
      } while ((n >>>= 1) != 0);
      return removed;
  }
  
  // å½»åº•æ¸…ç†è¿‡æœŸçš„Entry
  private int expungeStaleEntry(int staleSlot) {
      Entry[] tab = table;
      int len = tab.length;
      
      // ç§»é™¤æŒ‡å®šä½ç½®çš„Entry
      tab[staleSlot].value = null;
      tab[staleSlot] = null;
      size--;
      
      // é‡æ–°å“ˆå¸Œåé¢çš„Entry
      // ...
      
      return i;
  }
  ```
  
  **æ¸…ç†ç­–ç•¥:**
  1. åœ¨setã€getã€removeæ“ä½œæ—¶è§¦å‘æ¸…ç†
  2. æ¸…ç†keyä¸ºnullçš„Entry
  3. åŒæ—¶è¿›è¡Œé‡å“ˆå¸Œï¼Œä¿æŒè¡¨çš„ç´§å‡‘
  4. å‡å°‘å†…å­˜æ³„æ¼é£é™©
  
  </TabItem>
</Tabs>

## 3. ThreadLocalä½¿ç”¨åœºæ™¯

```mermaid
mindmap
  root((ThreadLocal<br>ä½¿ç”¨åœºæ™¯))
    çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’
      ç”¨æˆ·ä¿¡æ¯
      æƒé™æ§åˆ¶
      è¯·æ±‚ID
      MDCæ—¥å¿—æ ‡è¯†
    èµ„æºç®¡ç†
      æ•°æ®åº“è¿æ¥
      Hibernate Session
      äº‹åŠ¡æ§åˆ¶
    æ€§èƒ½ä¼˜åŒ–
      ç¼“å­˜
      çº¿ç¨‹çº§ç¼“å†²åŒº
    å¹¶å‘æ§åˆ¶
      ç®€åŒ–å‚æ•°ä¼ é€’
      é¿å…åŒæ­¥
```

### 3.1 çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’

<div className="card">
<div className="card__header">
<h4>çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’çš„ä»·å€¼</h4>
</div>
<div className="card__body">

**çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’**æ˜¯ThreadLocalæœ€å¸¸è§çš„åº”ç”¨åœºæ™¯ä¹‹ä¸€ã€‚å®ƒå…è®¸æˆ‘ä»¬åœ¨åŒä¸€çº¿ç¨‹å†…çš„ä¸åŒæ–¹æ³•ä¹‹é—´ä¼ é€’æ•°æ®ï¼Œè€Œæ— éœ€é€šè¿‡æ–¹æ³•å‚æ•°æ˜¾å¼ä¼ é€’ã€‚

**ä¸»è¦ä¼˜åŠ¿ï¼š**
- **ç®€åŒ–APIè®¾è®¡**ï¼šé¿å…æ–¹æ³•å‚æ•°è†¨èƒ€å’Œå±‚å±‚ä¼ é€’
- **ä»£ç è§£è€¦**ï¼šå„å±‚å¯ä»¥ç‹¬ç«‹è®¿é—®ä¸Šä¸‹æ–‡ä¿¡æ¯
- **æ–¹ä¾¿è·¨æ–¹æ³•è®¿é—®**ï¼šä»»ä½•æ–¹æ³•éƒ½å¯ä»¥è®¿é—®å½“å‰çº¿ç¨‹çš„ä¸Šä¸‹æ–‡
- **æ— éœ€åŒæ­¥**ï¼šæ¯ä¸ªçº¿ç¨‹æœ‰è‡ªå·±çš„å‰¯æœ¬ï¼Œé¿å…åŒæ­¥å¼€é”€

**å¸¸è§ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼š**
- ç”¨æˆ·èº«ä»½å’Œæƒé™ä¿¡æ¯
- è¯·æ±‚è¿½è¸ªID
- äº‹åŠ¡ä¸Šä¸‹æ–‡
- æœ¬åœ°åŒ–è®¾ç½®ï¼ˆå¦‚è¯­è¨€ã€æ—¶åŒºï¼‰
- å®‰å…¨ä¸Šä¸‹æ–‡

</div>
</div>

<Tabs>
  <TabItem value="user_context" label="ç”¨æˆ·ä¸Šä¸‹æ–‡" default>
  ```java
  /**
   * ç”¨æˆ·ä¸Šä¸‹æ–‡ä¼ é€’
   */
  public class UserContextExample {
      // ç”¨æˆ·ä¸Šä¸‹æ–‡ç±»
      public static class UserContext {
          private final String userId;
          private final String userName;
          private final Set<String> roles;
          private final String locale;
          
          public UserContext(String userId, String userName, Set<String> roles, String locale) {
              this.userId = userId;
              this.userName = userName;
              this.roles = Collections.unmodifiableSet(new HashSet<>(roles));
              this.locale = locale;
          }
          
          public String getUserId() { return userId; }
          public String getUserName() { return userName; }
          public Set<String> getRoles() { return roles; }
          public String getLocale() { return locale; }
          public boolean hasRole(String role) { return roles.contains(role); }
          
          @Override
          public String toString() {
              return String.format("UserContext{userId='%s', userName='%s', roles=%s, locale='%s'}",
                                 userId, userName, roles, locale);
          }
      }
      
      // ThreadLocalå­˜å‚¨ç”¨æˆ·ä¸Šä¸‹æ–‡
      private static final ThreadLocal<UserContext> userContextHolder = new ThreadLocal<>();
      
      // åˆ›å»ºå¯è‡ªåŠ¨æ¸…ç†çš„ä¸Šä¸‹æ–‡è¾…åŠ©ç±»
      public static class UserContextScope implements AutoCloseable {
          public UserContextScope(UserContext context) {
              userContextHolder.set(context);
          }
          
          @Override
          public void close() {
              userContextHolder.remove();
          }
      }
      
      // è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡
      public static void setUserContext(UserContext userContext) {
          userContextHolder.set(userContext);
      }
      
      // è·å–ç”¨æˆ·ä¸Šä¸‹æ–‡
      public static UserContext getUserContext() {
          return userContextHolder.get();
      }
      
      // æ¸…é™¤ç”¨æˆ·ä¸Šä¸‹æ–‡
      public static void clearUserContext() {
          userContextHolder.remove();
      }
      
      // ä¸šåŠ¡æœåŠ¡å±‚æ–¹æ³•
      public static class UserService {
          public void processRequest(String action) {
              UserContext ctx = getUserContext();
              System.out.println("å¤„ç†è¯·æ±‚: " + action);
              System.out.println("å½“å‰ç”¨æˆ·: " + ctx.getUserName());
              
              if ("admin".equals(action) && !ctx.hasRole("ADMIN")) {
                  throw new SecurityException("éœ€è¦ç®¡ç†å‘˜æƒé™");
              }
              
              // è°ƒç”¨å…¶ä»–æ–¹æ³•ï¼Œæ— éœ€ä¼ é€’ç”¨æˆ·ä¸Šä¸‹æ–‡
              auditLog("æ‰§è¡Œæ“ä½œ: " + action);
          }
          
          private void auditLog(String message) {
              UserContext ctx = getUserContext();
              System.out.println("å®¡è®¡æ—¥å¿—: [ç”¨æˆ·=" + ctx.getUserId() + "] " + message);
          }
      }
      
      // ç¤ºä¾‹ç”¨æ³•
      public static void main(String[] args) {
          UserService userService = new UserService();
          
          // æ¨¡æ‹Ÿæ™®é€šç”¨æˆ·è¯·æ±‚
          Set<String> userRoles = new HashSet<>(Arrays.asList("USER"));
          UserContext userCtx = new UserContext("user123", "Alice", userRoles, "en_US");
          
          // ä½¿ç”¨try-with-resourcesè‡ªåŠ¨æ¸…ç†ThreadLocal
          try (UserContextScope ignored = new UserContextScope(userCtx)) {
              userService.processRequest("view");
              // å°è¯•æ‰§è¡Œéœ€è¦ç®¡ç†å‘˜æƒé™çš„æ“ä½œ
              try {
                  userService.processRequest("admin");
              } catch (SecurityException e) {
                  System.out.println("é”™è¯¯: " + e.getMessage());
              }
          }
          
          // æ¨¡æ‹Ÿç®¡ç†å‘˜è¯·æ±‚
          Set<String> adminRoles = new HashSet<>(Arrays.asList("USER", "ADMIN"));
          UserContext adminCtx = new UserContext("admin456", "Bob", adminRoles, "en_US");
          
          try (UserContextScope ignored = new UserContextScope(adminCtx)) {
              userService.processRequest("admin");
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="request_trace" label="è¯·æ±‚è¿½è¸ª">
  ```java
  /**
   * è¯·æ±‚è¿½è¸ªä¸Šä¸‹æ–‡
   */
  public class RequestTraceExample {
      // è¯·æ±‚è¿½è¸ªä¸Šä¸‹æ–‡
      public static class TraceContext {
          private final String requestId;
          private final long startTime;
          private final Map<String, String> attributes;
          
          public TraceContext(String requestId) {
              this.requestId = requestId;
              this.startTime = System.currentTimeMillis();
              this.attributes = new ConcurrentHashMap<>();
          }
          
          public String getRequestId() {
              return requestId;
          }
          
          public long getStartTime() {
              return startTime;
          }
          
          public long getElapsedTime() {
              return System.currentTimeMillis() - startTime;
          }
          
          public void setAttribute(String key, String value) {
              attributes.put(key, value);
          }
          
          public String getAttribute(String key) {
              return attributes.get(key);
          }
      }
      
      // ThreadLocalå­˜å‚¨è¯·æ±‚è¿½è¸ªä¸Šä¸‹æ–‡
      private static final ThreadLocal<TraceContext> traceContextHolder = new ThreadLocal<>();
      
      // åˆå§‹åŒ–è¯·æ±‚ä¸Šä¸‹æ–‡
      public static void initTrace(String requestId) {
          traceContextHolder.set(new TraceContext(requestId));
      }
      
      // è·å–è¿½è¸ªä¸Šä¸‹æ–‡
      public static TraceContext getTraceContext() {
          return traceContextHolder.get();
      }
      
      // æ¸…é™¤è¿½è¸ªä¸Šä¸‹æ–‡
      public static void clearTraceContext() {
          traceContextHolder.remove();
      }
      
      // æ—¥å¿—å·¥å…·ç±»
      public static class Logger {
          public static void info(String message) {
              TraceContext ctx = getTraceContext();
              if (ctx != null) {
                  System.out.println(String.format("[%s] [%dms] %s",
                                                 ctx.getRequestId(),
                                                 ctx.getElapsedTime(),
                                                 message));
              } else {
                  System.out.println(message);
              }
          }
      }
      
      // æœåŠ¡ç±»
      public static class OrderService {
          public void createOrder(String productId) {
              Logger.info("å¼€å§‹åˆ›å»ºè®¢å•: " + productId);
              
              // è®¾ç½®è¿½è¸ªå±æ€§
              TraceContext ctx = getTraceContext();
              ctx.setAttribute("productId", productId);
              
              // è°ƒç”¨å…¶ä»–æœåŠ¡
              validateInventory(productId);
              processPayment();
              
              Logger.info("è®¢å•åˆ›å»ºå®Œæˆ");
          }
          
          private void validateInventory(String productId) {
              Logger.info("éªŒè¯åº“å­˜: " + productId);
              try {
                  Thread.sleep(50); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
              } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
              }
          }
          
          private void processPayment() {
              Logger.info("å¤„ç†æ”¯ä»˜");
              TraceContext ctx = getTraceContext();
              Logger.info("å¤„ç†å•†å“: " + ctx.getAttribute("productId"));
              
              try {
                  Thread.sleep(100); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
              } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
              }
          }
      }
      
      // ç¤ºä¾‹ç”¨æ³•
      public static void main(String[] args) {
          for (int i = 1; i <= 3; i++) {
              final String requestId = "REQ-" + i;
              final String productId = "PROD-" + (100 + i);
              
              new Thread(() -> {
                  try {
                      initTrace(requestId);
                      Logger.info("æ¥æ”¶è¯·æ±‚");
                      
                      OrderService orderService = new OrderService();
                      orderService.createOrder(productId);
                      
                      Logger.info("è¯·æ±‚å¤„ç†å®Œæˆ");
                  } finally {
                      clearTraceContext();
                  }
              }).start();
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="mdc_logging" label="æ—¥å¿—ä¸Šä¸‹æ–‡">
  ```java
  /**
   * MDCæ—¥å¿—ä¸Šä¸‹æ–‡ç¤ºä¾‹
   * MDC: Mapped Diagnostic Context
   */
  public class MdcLoggingExample {
      // ç®€åŒ–ç‰ˆMDCå®ç°
      public static class MDC {
          private static final ThreadLocal<Map<String, String>> contextMap = 
              ThreadLocal.withInitial(HashMap::new);
          
          public static void put(String key, String value) {
              contextMap.get().put(key, value);
          }
          
          public static String get(String key) {
              return contextMap.get().get(key);
          }
          
          public static void remove(String key) {
              contextMap.get().remove(key);
          }
          
          public static void clear() {
              contextMap.remove();
          }
          
          public static Map<String, String> getCopyOfContextMap() {
              return new HashMap<>(contextMap.get());
          }
      }
      
      // æ—¥å¿—å·¥å…·ç±»
      public static class Logger {
          private final String name;
          
          public Logger(String name) {
              this.name = name;
          }
          
          public void info(String message) {
              // æ ¼å¼: [æ—¶é—´æˆ³] [çº¿ç¨‹å] [ç±»å] [traceId] [userId] - æ¶ˆæ¯
              String threadName = Thread.currentThread().getName();
              String traceId = MDC.get("traceId");
              String userId = MDC.get("userId");
              
              System.out.println(String.format("[%tT] [%s] [%s] [%s] [%s] - %s",
                  new Date(), threadName, name, traceId, userId, message));
          }
      }
      
      // Webè¯·æ±‚è¿‡æ»¤å™¨ç¤ºä¾‹
      public static class RequestFilter {
          public static void doFilter(String userId, String requestUri, Runnable next) {
              String traceId = "TRACE-" + System.nanoTime();
              
              try {
                  // è®¾ç½®MDCä¸Šä¸‹æ–‡
                  MDC.put("traceId", traceId);
                  MDC.put("userId", userId);
                  
                  Logger logger = new Logger("RequestFilter");
                  logger.info("å¼€å§‹å¤„ç†è¯·æ±‚: " + requestUri);
                  
                  // æ‰§è¡Œè¯·æ±‚
                  next.run();
                  
                  logger.info("è¯·æ±‚å¤„ç†å®Œæˆ: " + requestUri);
              } finally {
                  // æ¸…ç†MDCä¸Šä¸‹æ–‡
                  MDC.clear();
              }
          }
      }
      
      // æœåŠ¡ç±»
      public static class UserService {
          private static final Logger logger = new Logger("UserService");
          
          public void findUserById(String id) {
              logger.info("æŸ¥æ‰¾ç”¨æˆ·: " + id);
              // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  Thread.currentThread().interrupt();
              }
              
              // è°ƒç”¨å…¶ä»–æœåŠ¡
              AuditService.logAccess("USER", id);
          }
      }
      
      // å®¡è®¡æœåŠ¡
      public static class AuditService {
          private static final Logger logger = new Logger("AuditService");
          
          public static void logAccess(String entityType, String entityId) {
              // æ—¥å¿—ä¸­è‡ªåŠ¨åŒ…å«å½“å‰ç”¨æˆ·å’Œè¿½è¸ªID
              logger.info("è®°å½•è®¿é—®: " + entityType + ":" + entityId);
          }
      }
      
      // ç¤ºä¾‹ç”¨æ³•
      public static void main(String[] args) {
          for (int i = 1; i <= 3; i++) {
              final String userId = "user" + i;
              Thread thread = new Thread(() -> {
                  RequestFilter.doFilter(userId, "/api/users/" + userId, () -> {
                      UserService userService = new UserService();
                      userService.findUserById(userId);
                  });
              }, "Thread-" + i);
              
              thread.start();
          }
      }
  }
  ```
  </TabItem>
</Tabs>

### 3.2 æ•°æ®åº“è¿æ¥ç®¡ç†

```java title="æ•°æ®åº“è¿æ¥ç®¡ç†ç¤ºä¾‹"
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DatabaseConnectionExamples {
    
    /**
     * æ•°æ®åº“è¿æ¥ç®¡ç†
     */
    public static class DatabaseConnectionManager {
        
        // ThreadLocalå­˜å‚¨æ•°æ®åº“è¿æ¥
        private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<>();
        
        // è·å–æ•°æ®åº“è¿æ¥
        public static Connection getConnection() throws SQLException {
            Connection connection = connectionHolder.get();
            if (connection == null || connection.isClosed()) {
                connection = createConnection();
                connectionHolder.set(connection);
            }
            return connection;
        }
        
        // åˆ›å»ºæ•°æ®åº“è¿æ¥
        private static Connection createConnection() throws SQLException {
            // è¿™é‡Œåº”è¯¥ä½¿ç”¨çœŸå®çš„æ•°æ®åº“è¿æ¥é…ç½®
            return DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "user", "password");
        }
        
        // å…³é—­æ•°æ®åº“è¿æ¥
        public static void closeConnection() {
            Connection connection = connectionHolder.get();
            if (connection != null) {
                try {
                    connection.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                } finally {
                    connectionHolder.remove();
                }
            }
        }
        
        // äº‹åŠ¡ç®¡ç†
        public static void executeInTransaction(Runnable task) {
            try {
                Connection connection = getConnection();
                connection.setAutoCommit(false);
                
                try {
                    task.run();
                    connection.commit();
                } catch (Exception e) {
                    connection.rollback();
                    throw e;
                } finally {
                    closeConnection();
                }
            } catch (SQLException e) {
                throw new RuntimeException("æ•°æ®åº“æ“ä½œå¤±è´¥", e);
            }
        }
        
        public static void main(String[] args) {
            System.out.println("=== æ•°æ®åº“è¿æ¥ç®¡ç† ===");
            
            // æ¨¡æ‹Ÿå¤šçº¿ç¨‹æ•°æ®åº“æ“ä½œ
            for (int i = 1; i <= 3; i++) {
                final int threadId = i;
                new Thread(() -> {
                    try {
                        executeInTransaction(() -> {
                            System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œæ•°æ®åº“æ“ä½œ");
                            // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
                            try {
                                Thread.sleep(500);
                            } catch (InterruptedException e) {
                                Thread.currentThread().interrupt();
                            }
                        });
                    } catch (Exception e) {
                        System.err.println("çº¿ç¨‹" + threadId + "æ“ä½œå¤±è´¥: " + e.getMessage());
                    }
                }).start();
            }
        }
    }
}
```

### 3.3 äº‹åŠ¡ç®¡ç†

```java title="äº‹åŠ¡ç®¡ç†ç¤ºä¾‹"
public class TransactionManagementExamples {
    
    /**
     * äº‹åŠ¡ç®¡ç†
     */
    public static class TransactionManager {
        
        // ThreadLocalå­˜å‚¨äº‹åŠ¡ä¿¡æ¯
        private static ThreadLocal<TransactionInfo> transactionHolder = new ThreadLocal<>();
        
        // äº‹åŠ¡ä¿¡æ¯
        public static class TransactionInfo {
            private String transactionId;
            private long startTime;
            private boolean active;
            
            public TransactionInfo(String transactionId) {
                this.transactionId = transactionId;
                this.startTime = System.currentTimeMillis();
                this.active = true;
            }
            
            public String getTransactionId() { return transactionId; }
            public long getStartTime() { return startTime; }
            public boolean isActive() { return active; }
            public void setActive(boolean active) { this.active = active; }
        }
        
        // å¼€å§‹äº‹åŠ¡
        public static void beginTransaction() {
            String transactionId = "TXN-" + System.currentTimeMillis();
            transactionHolder.set(new TransactionInfo(transactionId));
            System.out.println("å¼€å§‹äº‹åŠ¡: " + transactionId);
        }
        
        // æäº¤äº‹åŠ¡
        public static void commitTransaction() {
            TransactionInfo info = transactionHolder.get();
            if (info != null && info.isActive()) {
                info.setActive(false);
                System.out.println("æäº¤äº‹åŠ¡: " + info.getTransactionId());
            }
        }
        
        // å›æ»šäº‹åŠ¡
        public static void rollbackTransaction() {
            TransactionInfo info = transactionHolder.get();
            if (info != null && info.isActive()) {
                info.setActive(false);
                System.out.println("å›æ»šäº‹åŠ¡: " + info.getTransactionId());
            }
        }
        
        // è·å–å½“å‰äº‹åŠ¡ID
        public static String getCurrentTransactionId() {
            TransactionInfo info = transactionHolder.get();
            return info != null ? info.getTransactionId() : null;
        }
        
        // æ¸…ç†äº‹åŠ¡ä¿¡æ¯
        public static void clearTransaction() {
            transactionHolder.remove();
        }
        
        public static void main(String[] args) {
            System.out.println("=== äº‹åŠ¡ç®¡ç† ===");
            
            // æ¨¡æ‹Ÿå¤šçº¿ç¨‹äº‹åŠ¡æ“ä½œ
            for (int i = 1; i <= 3; i++) {
                final int threadId = i;
                new Thread(() -> {
                    try {
                        beginTransaction();
                        System.out.println("çº¿ç¨‹" + threadId + "æ‰§è¡Œä¸šåŠ¡æ“ä½œ");
                        
                        // æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ
                        Thread.sleep(1000);
                        
                        if (Math.random() > 0.5) {
                            commitTransaction();
                        } else {
                            rollbackTransaction();
                        }
                        
                    } catch (InterruptedException e) {
                        rollbackTransaction();
                        Thread.currentThread().interrupt();
                    } finally {
                        clearTransaction();
                    }
                }).start();
            }
        }
    }
}
```

## 4. ThreadLocalå†…å­˜æ³„æ¼

### 4.1 å†…å­˜æ³„æ¼åŸå› 

```java title="å†…å­˜æ³„æ¼åŸå› åˆ†æç¤ºä¾‹"
public class MemoryLeakAnalysis {
    
    /**
     * å†…å­˜æ³„æ¼åŸå› åˆ†æ
     */
    public static class MemoryLeakCauses {
        
        /**
         * å†…å­˜æ³„æ¼ç¤ºä¾‹
         */
        public static void demonstrateMemoryLeak() {
            System.out.println("=== ThreadLocalå†…å­˜æ³„æ¼åŸå›  ===");
            
            // å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼çš„ThreadLocal
            ThreadLocal<byte[]> threadLocal = new ThreadLocal<>();
            
            // åˆ›å»ºå¤§é‡çº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½è®¾ç½®ThreadLocal
            for (int i = 0; i < 1000; i++) {
                Thread thread = new Thread(() -> {
                    // è®¾ç½®å¤§å¯¹è±¡
                    threadLocal.set(new byte[1024 * 1024]); // 1MB
                    
                    // çº¿ç¨‹ç»“æŸï¼Œä½†æ²¡æœ‰æ¸…ç†ThreadLocal
                    // è¿™ä¼šå¯¼è‡´å†…å­˜æ³„æ¼
                });
                thread.start();
            }
            
            System.out.println("é—®é¢˜ï¼šçº¿ç¨‹ç»“æŸåï¼ŒThreadLocalMapä¸­çš„Entryä»ç„¶å­˜åœ¨");
            System.out.println("è™½ç„¶ThreadLocalè¢«å›æ”¶ï¼Œä½†valueä»ç„¶è¢«å¼ºå¼•ç”¨");
        }
        
        /**
         * å†…å­˜æ³„æ¼åŸç†
         */
        public static void explainMemoryLeakPrinciple() {
            System.out.println("=== å†…å­˜æ³„æ¼åŸç† ===");
            System.out.println("1. ThreadLocalMap.Entryçš„keyæ˜¯ThreadLocalçš„å¼±å¼•ç”¨");
            System.out.println("2. å½“ThreadLocalè¢«å›æ”¶æ—¶ï¼Œkeyå˜ä¸ºnull");
            System.out.println("3. ä½†valueä»ç„¶æ˜¯å¼ºå¼•ç”¨ï¼Œæ— æ³•è¢«å›æ”¶");
            System.out.println("4. å¯¼è‡´å†…å­˜æ³„æ¼");
            System.out.println("5. åªæœ‰åœ¨ThreadLocalMapè¢«æ¸…ç†æ—¶æ‰èƒ½å›æ”¶value");
        }
    }
}
```

### 4.2 é˜²æ­¢å†…å­˜æ³„æ¼

```java title="é˜²æ­¢å†…å­˜æ³„æ¼ç¤ºä¾‹"
public class MemoryLeakPrevention {
    
    /**
     * é˜²æ­¢å†…å­˜æ³„æ¼çš„æœ€ä½³å®è·µ
     */
    public static class BestPractices {
        
        /**
         * ä½¿ç”¨try-finallyç¡®ä¿æ¸…ç†
         */
        public static void safeThreadLocalUsage() {
            System.out.println("=== å®‰å…¨çš„ThreadLocalä½¿ç”¨ ===");
            
            ThreadLocal<String> threadLocal = new ThreadLocal<>();
            
            try {
                threadLocal.set("some value");
                // ä½¿ç”¨ThreadLocal
                System.out.println(threadLocal.get());
            } finally {
                // ç¡®ä¿æ¸…ç†ThreadLocal
                threadLocal.remove();
            }
        }
        
        /**
         * ä½¿ç”¨ThreadLocal.withInitial()æä¾›åˆå§‹å€¼
         */
        public static void threadLocalWithInitial() {
            System.out.println("=== ä½¿ç”¨withInitial ===");
            
            ThreadLocal<String> threadLocal = ThreadLocal.withInitial(() -> "default value");
            
            // ä¸éœ€è¦æ‰‹åŠ¨è®¾ç½®åˆå§‹å€¼
            System.out.println(threadLocal.get()); // è¾“å‡º: default value
        }
        
        /**
         * åœ¨çº¿ç¨‹æ± ä¸­ä½¿ç”¨ThreadLocal
         */
        public static void threadLocalInThreadPool() {
            System.out.println("=== çº¿ç¨‹æ± ä¸­çš„ThreadLocalä½¿ç”¨ ===");
            
            ThreadLocal<String> threadLocal = new ThreadLocal<>();
            ExecutorService executor = Executors.newFixedThreadPool(5);
            
            for (int i = 0; i < 10; i++) {
                final int taskId = i;
                executor.submit(() -> {
                    try {
                        threadLocal.set("Task-" + taskId);
                        System.out.println("æ‰§è¡Œä»»åŠ¡: " + threadLocal.get());
                    } finally {
                        // åœ¨çº¿ç¨‹æ± ä¸­å¿…é¡»æ¸…ç†ThreadLocal
                        threadLocal.remove();
                    }
                });
            }
            
            executor.shutdown();
        }
    }
}
```

## 5. ThreadLocalæœ€ä½³å®è·µ

### 5.1 æ­£ç¡®ä½¿ç”¨ThreadLocal

```java title="ThreadLocalæœ€ä½³å®è·µç¤ºä¾‹"
public class ThreadLocalBestPractices {
    
    /**
     * ThreadLocalæœ€ä½³å®è·µ
     */
    public static class BestPractices {
        
        // 1. ä½¿ç”¨é™æ€finalä¿®é¥°ThreadLocal
        private static final ThreadLocal<UserContext> USER_CONTEXT = new ThreadLocal<>();
        
        // 2. æä¾›ä¾¿æ·çš„è®¿é—®æ–¹æ³•
        public static void setUserContext(UserContext context) {
            USER_CONTEXT.set(context);
        }
        
        public static UserContext getUserContext() {
            return USER_CONTEXT.get();
        }
        
        public static void clearUserContext() {
            USER_CONTEXT.remove();
        }
        
        // 3. ä½¿ç”¨try-finallyç¡®ä¿æ¸…ç†
        public static void executeWithUserContext(UserContext context, Runnable task) {
            try {
                setUserContext(context);
                task.run();
            } finally {
                clearUserContext();
            }
        }
        
        // 4. åœ¨çº¿ç¨‹æ± ä¸­ä½¿ç”¨ThreadLocal
        public static void executeInThreadPool() {
            ExecutorService executor = Executors.newFixedThreadPool(5);
            
            for (int i = 0; i < 10; i++) {
                final int userId = i;
                executor.submit(() -> {
                    UserContext context = new UserContext("user" + userId, "User" + userId, "session" + userId);
                    executeWithUserContext(context, () -> {
                        System.out.println("å½“å‰ç”¨æˆ·: " + getUserContext().getUserName());
                    });
                });
            }
            
            executor.shutdown();
        }
        
        // ç”¨æˆ·ä¸Šä¸‹æ–‡ç±»
        public static class UserContext {
            private String userId;
            private String userName;
            private String sessionId;
            
            public UserContext(String userId, String userName, String sessionId) {
                this.userId = userId;
                this.userName = userName;
                this.sessionId = sessionId;
            }
            
            public String getUserId() { return userId; }
            public String getUserName() { return userName; }
            public String getSessionId() { return sessionId; }
        }
    }
}
```

### 5.2 ThreadLocalå·¥å…·ç±»

```java title="ThreadLocalå·¥å…·ç±»ç¤ºä¾‹"
public class ThreadLocalUtils {
    
    /**
     * ThreadLocalå·¥å…·ç±»
     */
    public static class ThreadLocalManager {
        
        // ç”¨æˆ·ä¸Šä¸‹æ–‡ThreadLocal
        private static final ThreadLocal<UserContext> USER_CONTEXT = new ThreadLocal<>();
        
        // è¯·æ±‚ID ThreadLocal
        private static final ThreadLocal<String> REQUEST_ID = new ThreadLocal<>();
        
        // äº‹åŠ¡è¿æ¥ThreadLocal
        private static final ThreadLocal<Connection> TRANSACTION_CONNECTION = new ThreadLocal<>();
        
        // ç”¨æˆ·ä¸Šä¸‹æ–‡ç›¸å…³æ–¹æ³•
        public static void setUserContext(UserContext context) {
            USER_CONTEXT.set(context);
        }
        
        public static UserContext getUserContext() {
            return USER_CONTEXT.get();
        }
        
        public static void clearUserContext() {
            USER_CONTEXT.remove();
        }
        
        // è¯·æ±‚IDç›¸å…³æ–¹æ³•
        public static void setRequestId(String requestId) {
            REQUEST_ID.set(requestId);
        }
        
        public static String getRequestId() {
            return REQUEST_ID.get();
        }
        
        public static void clearRequestId() {
            REQUEST_ID.remove();
        }
        
        // äº‹åŠ¡è¿æ¥ç›¸å…³æ–¹æ³•
        public static void setTransactionConnection(Connection connection) {
            TRANSACTION_CONNECTION.set(connection);
        }
        
        public static Connection getTransactionConnection() {
            return TRANSACTION_CONNECTION.get();
        }
        
        public static void clearTransactionConnection() {
            TRANSACTION_CONNECTION.remove();
        }
        
        // æ¸…ç†æ‰€æœ‰ThreadLocal
        public static void clearAll() {
            USER_CONTEXT.remove();
            REQUEST_ID.remove();
            TRANSACTION_CONNECTION.remove();
        }
        
        // ç”¨æˆ·ä¸Šä¸‹æ–‡ç±»
        public static class UserContext {
            private String userId;
            private String userName;
            
            public UserContext(String userId, String userName) {
                this.userId = userId;
                this.userName = userName;
            }
            
            public String getUserId() { return userId; }
            public String getUserName() { return userName; }
        }
        
        // æ¨¡æ‹ŸConnectionç±»
        public static class Connection {
            private String name;
            
            public Connection(String name) {
                this.name = name;
            }
            
            public String getName() {
                return name;
            }
        }
    }
}
```

## 6. é¢è¯•é¢˜

### 6.1 åŸºç¡€æ¦‚å¿µ

**Q: ThreadLocalçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ**

**A:**
ThreadLocalç”¨äºåˆ›å»ºçº¿ç¨‹å±€éƒ¨å˜é‡ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œçº¿ç¨‹é—´ä¸ä¼šç›¸äº’å½±å“ã€‚

**Q: ThreadLocalçš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ**

**A:**
1. **ThreadLocalMap**ï¼šæ¯ä¸ªThreadéƒ½æœ‰ä¸€ä¸ªThreadLocalMap
2. **Entryæ•°ç»„**ï¼šThreadLocalMapå†…éƒ¨ä½¿ç”¨Entryæ•°ç»„å­˜å‚¨æ•°æ®
3. **å¼±å¼•ç”¨**ï¼šEntryçš„keyæ˜¯ThreadLocalçš„å¼±å¼•ç”¨
4. **å“ˆå¸Œç®—æ³•**ï¼šä½¿ç”¨ThreadLocalçš„hashCodeç¡®å®šå­˜å‚¨ä½ç½®

### 6.2 å†…å­˜æ³„æ¼

**Q: ThreadLocalçš„å†…å­˜æ³„æ¼é—®é¢˜ï¼Ÿ**

**A:**
**åŸå› **ï¼š
- ThreadLocalè¢«å›æ”¶åï¼ŒEntryçš„keyå˜ä¸ºnull
- ä½†Entryçš„valueä»ç„¶è¢«å¼ºå¼•ç”¨
- å¯¼è‡´valueæ— æ³•è¢«å›æ”¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
- åŠæ—¶è°ƒç”¨remove()æ–¹æ³•æ¸…ç†
- ä½¿ç”¨try-finallyç¡®ä¿æ¸…ç†
- åœ¨çº¿ç¨‹æ± ä¸­ç‰¹åˆ«æ³¨æ„æ¸…ç†

**Q: å¦‚ä½•é¿å…ThreadLocalå†…å­˜æ³„æ¼ï¼Ÿ**

**A:**
- ä½¿ç”¨å®ŒThreadLocalåç«‹å³è°ƒç”¨remove()
- åœ¨çº¿ç¨‹æ± ä¸­ä½¿ç”¨ThreadLocalæ—¶è¦ç‰¹åˆ«æ³¨æ„æ¸…ç†
- ä½¿ç”¨try-finallyç¡®ä¿æ¸…ç†
- é¿å…å­˜å‚¨å¤§å¯¹è±¡

### 6.3 ä½¿ç”¨åœºæ™¯

**Q: ThreadLocalçš„ä½¿ç”¨åœºæ™¯ï¼Ÿ**

**A:**
1. **çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šä¼ é€’ç”¨æˆ·ä¿¡æ¯ã€è¯·æ±‚IDç­‰
2. **æ•°æ®åº“è¿æ¥ç®¡ç†**ï¼šæ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„æ•°æ®åº“è¿æ¥
3. **äº‹åŠ¡ç®¡ç†**ï¼šçº¿ç¨‹çº§åˆ«çš„äº‹åŠ¡æ§åˆ¶
4. **è¯·æ±‚è¿½è¸ª**ï¼šè®°å½•è¯·æ±‚å¤„ç†è¿‡ç¨‹

**Q: ThreadLocalå’Œsynchronizedçš„åŒºåˆ«ï¼Ÿ**

**A:**
**ThreadLocal**ï¼š
- çº¿ç¨‹éš”ç¦»ï¼Œæ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹å˜é‡
- æ— éœ€åŒæ­¥ï¼Œå¤©ç„¶çº¿ç¨‹å®‰å…¨
- é€‚åˆçº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’

**synchronized**ï¼š
- çº¿ç¨‹é—´å…±äº«å˜é‡
- éœ€è¦åŒæ­¥æœºåˆ¶
- é€‚åˆçº¿ç¨‹é—´åä½œ

### 6.4 æœ€ä½³å®è·µ

**Q: å¦‚ä½•æ­£ç¡®ä½¿ç”¨ThreadLocalï¼Ÿ**

**A:**
```java
// æ­£ç¡®çš„ä½¿ç”¨æ–¹å¼
public class CorrectThreadLocalUsage {
    private static final ThreadLocal<String> threadLocal = new ThreadLocal<>();
    
    public static void correctUsage() {
        try {
            threadLocal.set("value");
            // ä½¿ç”¨ThreadLocal
            System.out.println(threadLocal.get());
        } finally {
            // ç¡®ä¿æ¸…ç†
            threadLocal.remove();
        }
    }
}
```

**Q: ThreadLocalåœ¨çº¿ç¨‹æ± ä¸­çš„é—®é¢˜ï¼Ÿ**

**A:**
**é—®é¢˜**ï¼š
- çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ä¼šé‡å¤ä½¿ç”¨
- ThreadLocalçš„å€¼å¯èƒ½è¢«ä¸Šä¸€ä¸ªä»»åŠ¡æ±¡æŸ“

**è§£å†³æ–¹æ¡ˆ**ï¼š
- åœ¨ä»»åŠ¡å¼€å§‹æ—¶æ¸…ç†ThreadLocal
- åœ¨ä»»åŠ¡ç»“æŸæ—¶æ¸…ç†ThreadLocal
- ä½¿ç”¨try-finallyç¡®ä¿æ¸…ç†

### 6.5 é«˜çº§ç‰¹æ€§

**Q: ThreadLocalçš„æ›¿ä»£æ–¹æ¡ˆï¼Ÿ**

**A:**
1. **InheritableThreadLocal**ï¼šå­çº¿ç¨‹ç»§æ‰¿çˆ¶çº¿ç¨‹çš„å€¼
2. **TransmittableThreadLocal**ï¼šæ”¯æŒçº¿ç¨‹æ± ä¼ é€’
3. **ThreadLocalRandom**ï¼šçº¿ç¨‹å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨
4. **è‡ªå®šä¹‰ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šä½¿ç”¨å‚æ•°ä¼ é€’

**Q: ThreadLocalçš„æ€§èƒ½å½±å“ï¼Ÿ**

**A:**
**ä¼˜ç‚¹**ï¼š
- æ— éœ€åŒæ­¥ï¼Œæ€§èƒ½å¥½
- çº¿ç¨‹éš”ç¦»ï¼Œé¿å…ç«äº‰

**ç¼ºç‚¹**ï¼š
- å†…å­˜å ç”¨è¾ƒå¤§
- å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
- è°ƒè¯•å›°éš¾

## 7. æ€»ç»“

ThreadLocalä¸ºJavaå¤šçº¿ç¨‹ç¼–ç¨‹æä¾›äº†çº¿ç¨‹éš”ç¦»çš„å­˜å‚¨æœºåˆ¶ã€‚

### 7.1 å…³é”®è¦ç‚¹

1. **çº¿ç¨‹éš”ç¦»**ï¼šæ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬
2. **å†…å­˜ç®¡ç†**ï¼šæ­£ç¡®ä½¿ç”¨å’Œæ¸…ç†ï¼Œé¿å…å†…å­˜æ³„æ¼
3. **ä½¿ç”¨åœºæ™¯**ï¼šçº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’ã€æ•°æ®åº“è¿æ¥ã€äº‹åŠ¡ç®¡ç†
4. **æœ€ä½³å®è·µ**ï¼šåŠæ—¶æ¸…ç†ã€åœ¨çº¿ç¨‹æ± ä¸­ç‰¹åˆ«æ³¨æ„

### 7.2 ä½¿ç”¨å»ºè®®

| åœºæ™¯ | æ¨èæ–¹å¼ | åŸå›  |
|------|----------|------|
| **çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’** | ThreadLocal | å¤©ç„¶çº¿ç¨‹å®‰å…¨ |
| **æ•°æ®åº“è¿æ¥ç®¡ç†** | ThreadLocal | çº¿ç¨‹éš”ç¦» |
| **äº‹åŠ¡ç®¡ç†** | ThreadLocal | çº¿ç¨‹çº§åˆ«æ§åˆ¶ |
| **è¯·æ±‚è¿½è¸ª** | ThreadLocal | ç®€å•æ˜“ç”¨ |

### 7.3 å­¦ä¹ å»ºè®®

1. **ç†è§£åŸç†**ï¼šæ·±å…¥ç†è§£ThreadLocalçš„å·¥ä½œåŸç†
2. **å®è·µéªŒè¯**ï¼šé€šè¿‡ç¼–å†™ä»£ç éªŒè¯ThreadLocalçš„æ•ˆæœ
3. **å†…å­˜ç®¡ç†**ï¼šç‰¹åˆ«æ³¨æ„å†…å­˜æ³„æ¼é—®é¢˜
4. **æœ€ä½³å®è·µ**ï¼šæŒæ¡æ­£ç¡®çš„ä½¿ç”¨æ–¹å¼

é€šè¿‡æ·±å…¥ç†è§£å’Œç†Ÿç»ƒè¿ç”¨ThreadLocalï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå‡ºæ›´åŠ é«˜æ•ˆã€å¥å£®å’Œå¯ç»´æŠ¤çš„Javaå¤šçº¿ç¨‹åº”ç”¨ç¨‹åºã€‚ 