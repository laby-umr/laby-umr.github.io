---
sidebar_position: 7
title: "Javaçº¿ç¨‹å®‰å…¨è¯¦è§£"
description: "å…¨é¢ä»‹ç»Javaçº¿ç¨‹å®‰å…¨æ¦‚å¿µã€å®ç°ç­–ç•¥ã€å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ"
authors: [Laby]
last_update:
  date: 2025-01-07
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TOCInline from '@theme/TOCInline';

# Java çº¿ç¨‹å®‰å…¨è¯¦è§£

çº¿ç¨‹å®‰å…¨æ˜¯å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼ŒæŒ‡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œç¨‹åºèƒ½å¤Ÿæ­£ç¡®æ‰§è¡Œï¼Œä¸ä¼šå‡ºç°æ•°æ®ä¸ä¸€è‡´æˆ–å¼‚å¸¸ç»“æœã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»çº¿ç¨‹å®‰å…¨çš„å®ç°ç­–ç•¥ã€å¸¸è§é—®é¢˜åŠè§£å†³æ–¹æ¡ˆã€‚

:::info æœ¬æ–‡å†…å®¹æ¦‚è§ˆ
<TOCInline toc={toc} />
:::

:::tip æ ¸å¿ƒä»·å€¼
**çº¿ç¨‹å®‰å…¨ = å¹¶å‘æ­£ç¡®æ€§ + æ•°æ®ä¸€è‡´æ€§ + å¯è§æ€§ + åŸå­æ€§ + æœ‰åºæ€§**
- ğŸ”’ **å¹¶å‘æ§åˆ¶**ï¼šç¡®ä¿å¤šçº¿ç¨‹ç¯å¢ƒä¸‹æ•°æ®æ“ä½œçš„æ­£ç¡®æ€§
- ğŸ›¡ï¸ **æ•°æ®ä¿æŠ¤**ï¼šé˜²æ­¢æ•°æ®æŸåå’ŒçŠ¶æ€ä¸ä¸€è‡´
- ğŸ‘ï¸ **å¯è§æ€§**ï¼šä¿è¯ä¸€ä¸ªçº¿ç¨‹å¯¹æ•°æ®çš„ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹å¯è§
- âš›ï¸ **åŸå­æ€§**ï¼šç¡®ä¿æ“ä½œè¦ä¹ˆå®Œå…¨æ‰§è¡Œï¼Œè¦ä¹ˆå®Œå…¨ä¸æ‰§è¡Œ
- ğŸ”„ **æœ‰åºæ€§**ï¼šæ§åˆ¶ä»£ç æ‰§è¡Œé¡ºåºï¼Œé˜²æ­¢æŒ‡ä»¤é‡æ’å¯¼è‡´çš„é—®é¢˜
:::

## 1. çº¿ç¨‹å®‰å…¨æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯çº¿ç¨‹å®‰å…¨ï¼Ÿ

```mermaid
graph TD
    A[çº¿ç¨‹å®‰å…¨] --> B[æ•°æ®ä¸€è‡´æ€§]
    A --> C[åŸå­æ€§]
    A --> D[å¯è§æ€§]
    A --> E[æœ‰åºæ€§]
    
    B --> B1[æ— å¹¶å‘ä¿®æ”¹å¼‚å¸¸]
    C --> C1[æ“ä½œä¸ä¼šè¢«ä¸­æ–­]
    D --> D1[ä¿®æ”¹ç«‹å³å¯è§]
    E --> E1[æŒ‰é¢„æœŸé¡ºåºæ‰§è¡Œ]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333
    style C fill:#bbf,stroke:#333
    style D fill:#bbf,stroke:#333
    style E fill:#bbf,stroke:#333
```

:::tip æ ¸å¿ƒæ¦‚å¿µ
çº¿ç¨‹å®‰å…¨æ˜¯æŒ‡å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œç¨‹åºèƒ½å¤Ÿæ­£ç¡®æ‰§è¡Œï¼Œä¸ä¼šå‡ºç°æ•°æ®ä¸ä¸€è‡´æˆ–å¼‚å¸¸ç»“æœã€‚çº¿ç¨‹å®‰å…¨çš„ä»£ç åœ¨å¤šçº¿ç¨‹å¹¶å‘æ‰§è¡Œæ—¶ï¼Œèƒ½å¤Ÿä¿è¯æ•°æ®çš„æ­£ç¡®æ€§å’Œä¸€è‡´æ€§ã€‚
:::

### 1.2 çº¿ç¨‹å®‰å…¨çš„é‡è¦æ€§

<div className="card">
<div className="card__header">
<h4>çº¿ç¨‹å®‰å…¨çš„ä¸šåŠ¡ä»·å€¼</h4>
</div>
<div className="card__body">

| é‡è¦æ€§ | å…·ä½“ä½“ç° | ä¸šåŠ¡ä»·å€¼ |
|--------|----------|----------|
| **æ•°æ®ä¸€è‡´æ€§** | é¿å…æ•°æ®æŸåå’Œä¸ä¸€è‡´ | ä¿è¯ä¸šåŠ¡é€»è¾‘æ­£ç¡®æ€§ |
| **ç³»ç»Ÿç¨³å®šæ€§** | é˜²æ­¢ç¨‹åºå´©æºƒå’Œå¼‚å¸¸ | æé«˜ç³»ç»Ÿå¯ç”¨æ€§ |
| **æ€§èƒ½ä¼˜åŒ–** | é¿å…ä¸å¿…è¦çš„åŒæ­¥å¼€é”€ | æå‡ç³»ç»Ÿæ€§èƒ½ |
| **å¯ç»´æŠ¤æ€§** | ä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºè°ƒè¯• | é™ä½ç»´æŠ¤æˆæœ¬ |

</div>
</div>

### 1.3 çº¿ç¨‹å®‰å…¨çº§åˆ«

```mermaid
graph LR
    A[çº¿ç¨‹å®‰å…¨çº§åˆ«] --> B[1. ä¸å¯å˜]
    A --> C[2. æ— çŠ¶æ€]
    A --> D[3. æœ‰çŠ¶æ€çº¿ç¨‹å®‰å…¨]
    A --> E[4. æœ‰æ¡ä»¶çº¿ç¨‹å®‰å…¨]
    A --> F[5. éçº¿ç¨‹å®‰å…¨]
    
    B --> B1[æ— éœ€å¤–éƒ¨åŒæ­¥]
    C --> C1[æ— å…±äº«çŠ¶æ€]
    D --> D1[å†…éƒ¨å®ç°åŒæ­¥]
    E --> E1[æŸäº›æ¡ä»¶ä¸‹å®‰å…¨]
    F --> F1[éœ€è¦å¤–éƒ¨åŒæ­¥]
    
    classDef safe fill:#bfb,stroke:#393
    classDef unsafe fill:#fbb,stroke:#933
    
    class B,C,D safe
    class E,F unsafe
```

<Tabs>
  <TabItem value="immutable" label="ä¸å¯å˜å¯¹è±¡" default>
  ```java
  /**
   * 1. ä¸å¯å˜å¯¹è±¡ - æœ€é«˜çº§åˆ«çš„çº¿ç¨‹å®‰å…¨
   * å¯¹è±¡åˆ›å»ºåçŠ¶æ€æ°¸è¿œä¸ä¼šæ”¹å˜
   */
  public static final class ImmutablePoint {
      private final int x;
      private final int y;
      
      public ImmutablePoint(int x, int y) {
          this.x = x;
          this.y = y;
      }
      
      public int getX() { return x; }
      public int getY() { return y; }
      
      // è¿”å›æ–°å¯¹è±¡è€Œä¸æ˜¯ä¿®æ”¹ç°æœ‰å¯¹è±¡
      public ImmutablePoint move(int dx, int dy) {
          return new ImmutablePoint(x + dx, y + dy);
      }
  }
  
  // ä½¿ç”¨ç¤ºä¾‹
  ImmutablePoint p1 = new ImmutablePoint(5, 10);
  // ç§»åŠ¨ç‚¹ä½ï¼Œè¿”å›æ–°å¯¹è±¡ï¼ŒåŸå¯¹è±¡ä¸å˜
  ImmutablePoint p2 = p1.move(3, 4);
  // p1ä»ç„¶æ˜¯(5,10)ï¼Œp2æ˜¯(8,14)
  ```
  
  **ç‰¹ç‚¹ï¼š**
  - æ‰€æœ‰å­—æ®µéƒ½æ˜¯final
  - å¯¹è±¡çŠ¶æ€ä¸å¯ä¿®æ”¹
  - æ‰€æœ‰å¯å˜æˆå‘˜å˜é‡éƒ½è¿›è¡Œé˜²å¾¡æ€§å¤åˆ¶
  - ä»»ä½•æ–¹æ³•éƒ½ä¸ä¼šä¿®æ”¹å¯¹è±¡çŠ¶æ€
  - ç»å¯¹çº¿ç¨‹å®‰å…¨ï¼Œæ— éœ€åŒæ­¥
  
  </TabItem>
  <TabItem value="stateless" label="æ— çŠ¶æ€å¯¹è±¡">
  ```java
  /**
   * 2. æ— çŠ¶æ€å¯¹è±¡ - å¤©ç„¶çº¿ç¨‹å®‰å…¨
   * ä¸åŒ…å«ä»»ä½•çŠ¶æ€ä¿¡æ¯
   */
  public static class StatelessCalculator {
      public int add(int a, int b) {
          return a + b;
      }
      
      public int multiply(int a, int b) {
          return a * b;
      }
  }
  
  // ä½¿ç”¨ç¤ºä¾‹
  StatelessCalculator calculator = new StatelessCalculator();
  // å¤šçº¿ç¨‹è°ƒç”¨addå’Œmultiplyæ–¹æ³•æ˜¯å®‰å…¨çš„
  // å› ä¸ºæ²¡æœ‰å…±äº«çŠ¶æ€å¯èƒ½è¢«ä¿®æ”¹
  ```
  
  **ç‰¹ç‚¹ï¼š**
  - ä¸åŒ…å«ä»»ä½•å®ä¾‹æˆ–ç±»å˜é‡
  - æ–¹æ³•çš„æ‰§è¡Œç»“æœåªä¾èµ–äºè¾“å…¥å‚æ•°
  - ä¸ä¾èµ–å¤–éƒ¨çŠ¶æ€
  - å¤©ç„¶çº¿ç¨‹å®‰å…¨ï¼Œæ— éœ€åŒæ­¥
  
  </TabItem>
  <TabItem value="thread_safe" label="çº¿ç¨‹å®‰å…¨å¯¹è±¡">
  ```java
  /**
   * 3. æœ‰çŠ¶æ€ä½†çº¿ç¨‹å®‰å…¨çš„å¯¹è±¡
   * é€šè¿‡åŒæ­¥æœºåˆ¶ä¿æŠ¤çŠ¶æ€
   */
  public static class ThreadSafeCounter {
      private int count = 0;
      
      // ä½¿ç”¨synchronizedç¡®ä¿çº¿ç¨‹å®‰å…¨
      public synchronized void increment() {
          count++;
      }
      
      public synchronized int getCount() {
          return count;
      }
  }
  
  // æˆ–è€…ä½¿ç”¨åŸå­ç±»
  public static class AtomicCounter {
      private AtomicInteger count = new AtomicInteger(0);
      
      public void increment() {
          count.incrementAndGet();
      }
      
      public int getCount() {
          return count.get();
      }
  }
  ```
  
  **ç‰¹ç‚¹ï¼š**
  - åŒ…å«å¯å˜çŠ¶æ€
  - é€šè¿‡åŒæ­¥æœºåˆ¶ï¼ˆsynchronizedã€Lockã€åŸå­ç±»ç­‰ï¼‰ä¿æŠ¤çŠ¶æ€
  - æ‰€æœ‰è®¿é—®å…±äº«çŠ¶æ€çš„æ–¹æ³•éƒ½ç»è¿‡åŒæ­¥
  - æ— éœ€å¤–éƒ¨åŒæ­¥å³å¯å®‰å…¨ä½¿ç”¨
  
  </TabItem>
  <TabItem value="unsafe" label="éçº¿ç¨‹å®‰å…¨å¯¹è±¡">
  ```java
  /**
   * 4. æœ‰çŠ¶æ€ä¸”éçº¿ç¨‹å®‰å…¨çš„å¯¹è±¡
   * éœ€è¦å¤–éƒ¨åŒæ­¥ä¿æŠ¤
   */
  public static class UnsafeCounter {
      private int count = 0;
      
      public void increment() {
          count++; // éåŸå­æ“ä½œï¼Œçº¿ç¨‹ä¸å®‰å…¨
      }
      
      public int getCount() {
          return count;
      }
  }
  
  // ä½¿ç”¨ç¤ºä¾‹ - éœ€è¦å¤–éƒ¨åŒæ­¥
  UnsafeCounter counter = new UnsafeCounter();
  
  // ä¸å®‰å…¨çš„å¤šçº¿ç¨‹è®¿é—®
  // new Thread(() -> counter.increment()).start();
  // new Thread(() -> counter.increment()).start();
  
  // å®‰å…¨çš„ä½¿ç”¨æ–¹å¼
  synchronized(counter) {
      counter.increment();
  }
  ```
  
  **ç‰¹ç‚¹ï¼š**
  - åŒ…å«å¯å˜çŠ¶æ€
  - æ²¡æœ‰åŒæ­¥æœºåˆ¶ä¿æŠ¤çŠ¶æ€
  - åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯èƒ½å¯¼è‡´æ•°æ®ä¸ä¸€è‡´
  - éœ€è¦å¤–éƒ¨åŒæ­¥æ‰èƒ½å®‰å…¨ä½¿ç”¨
  
  </TabItem>
</Tabs>

## 2. çº¿ç¨‹å®‰å…¨å®ç°ç­–ç•¥

<div className="card">
<div className="card__header">
<h4>çº¿ç¨‹å®‰å…¨å®ç°ç­–ç•¥å¯¹æ¯”</h4>
</div>
<div className="card__body">

| ç­–ç•¥ | æè¿° | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|------|----------|
| **ä¸å¯å˜å¯¹è±¡** | åˆ›å»ºåçŠ¶æ€ä¸å¯å˜ | æœ€ç®€å•å®‰å…¨ã€æ— éœ€åŒæ­¥ | æ¯æ¬¡æ“ä½œåˆ›å»ºæ–°å¯¹è±¡ | å°å¯¹è±¡ã€é…ç½®ç±» |
| **åŒæ­¥æœºåˆ¶** | ä½¿ç”¨synchronizedæˆ–Lock | ç®€å•ç›´æ¥ã€ä¿è¯åŸå­æ€§ | æ€§èƒ½å¼€é”€ã€æ­»é”é£é™© | é€šç”¨åœºæ™¯ |
| **åŸå­å˜é‡** | ä½¿ç”¨java.util.concurrent.atomicåŒ… | æ€§èƒ½å¥½ã€æ— é” | ä»…é€‚ç”¨äºç®€å•æ“ä½œ | è®¡æ•°å™¨ã€æ ‡å¿—ä½ |
| **çº¿ç¨‹å°é—­** | å°†æ•°æ®é™åˆ¶åœ¨å•çº¿ç¨‹å†…ä½¿ç”¨ | æ— éœ€åŒæ­¥ | é™åˆ¶æ•°æ®å…±äº« | è¯·æ±‚èŒƒå›´å†…æ•°æ® |
| **çº¿ç¨‹æœ¬åœ°å­˜å‚¨** | ä½¿ç”¨ThreadLocal | çº¿ç¨‹éš”ç¦»ã€æ— ç«äº‰ | å¯èƒ½å†…å­˜æ³„æ¼ | çº¿ç¨‹çº§åˆ«ç¼“å­˜ |
| **å†™æ—¶å¤åˆ¶** | ä¿®æ”¹æ—¶åˆ›å»ºå‰¯æœ¬ | è¯»æ“ä½œæ— é” | å†™å…¥å¼€é”€å¤§ | è¯»å¤šå†™å°‘ |
| **æ …æ æ¨¡å¼** | ä½¿ç”¨CountDownLatchç­‰ | åè°ƒå¤šçº¿ç¨‹æ‰§è¡Œ | å®ç°å¤æ‚ | çº¿ç¨‹åä½œåœºæ™¯ |

</div>
</div>

### 2.1 ä¸å¯å˜å¯¹è±¡ç­–ç•¥

```mermaid
classDiagram
    class ImmutableObject {
        <<interface>>
        +final fields
        +defensive copying
        +no setters
    }
    
    class String {
        -final char[] value
        +charAt(int) char
        +substring(int, int) String
        +concat(String) String
    }
    
    class LocalDate {
        -final int year
        -final int month
        -final int day
        +plusDays(long) LocalDate
        +minusMonths(long) LocalDate
    }
    
    class Collections.unmodifiableList {
        -final List list
        +get(int) E
        +size() int
    }
    
    ImmutableObject <|-- String
    ImmutableObject <|-- LocalDate
    ImmutableObject <|-- Collections.unmodifiableList
```

<Tabs>
  <TabItem value="immutable_string" label="ä¸å¯å˜å­—ç¬¦ä¸²" default>
  ```java
  /**
   * ä¸å¯å˜å­—ç¬¦ä¸²ç±»
   */
  public static final class ImmutableString {
      private final char[] value; // finalå¼•ç”¨ï¼Œç¡®ä¿ä¸èƒ½é‡æ–°èµ‹å€¼
      
      public ImmutableString(char[] value) {
          // é˜²å¾¡æ€§å¤åˆ¶ï¼Œé¿å…å¤–éƒ¨ä¿®æ”¹
          this.value = Arrays.copyOf(value, value.length);
      }
      
      public char[] getValue() {
          // è¿”å›å‰¯æœ¬ï¼Œé¿å…å¤–éƒ¨ä¿®æ”¹
          return Arrays.copyOf(value, value.length);
      }
      
      public char charAt(int index) {
          if (index < 0 || index >= value.length) {
              throw new IndexOutOfBoundsException();
          }
          return value[index];
      }
      
      public int length() {
          return value.length;
      }
      
      // å­—ç¬¦ä¸²è¿æ¥è¿”å›æ–°å¯¹è±¡ï¼Œä¸ä¿®æ”¹åŸå¯¹è±¡
      public ImmutableString concat(ImmutableString other) {
          char[] newValue = new char[value.length + other.value.length];
          System.arraycopy(value, 0, newValue, 0, value.length);
          System.arraycopy(other.value, 0, newValue, value.length, other.value.length);
          return new ImmutableString(newValue);
      }
  }
  ```
  </TabItem>
  <TabItem value="immutable_config" label="ä¸å¯å˜é…ç½®">
  ```java
  /**
   * ä¸å¯å˜é…ç½®ç±»
   */
  public static final class ImmutableConfig {
      private final Map<String, String> properties; // finalå¼•ç”¨
      
      public ImmutableConfig(Map<String, String> properties) {
          // åˆ›å»ºä¸å¯å˜Map - ä¸¤å±‚é˜²å¾¡
          // 1. å¤åˆ¶ä¼ å…¥çš„Mapï¼Œé˜²æ­¢å¤–éƒ¨å¼•ç”¨ä¿®æ”¹
          // 2. ä½¿ç”¨Collections.unmodifiableMapç¡®ä¿è¿”å›çš„Mapä¸å¯ä¿®æ”¹
          this.properties = Collections.unmodifiableMap(new HashMap<>(properties));
      }
      
      public String getProperty(String key) {
          return properties.get(key);
      }
      
      public Map<String, String> getAllProperties() {
          // è¿”å›ä¸å¯å˜è§†å›¾ï¼Œä¸éœ€è¦å†æ¬¡å¤åˆ¶
          // å› ä¸ºåœ¨æ„é€ å‡½æ•°ä¸­å·²ç»ä½¿ç”¨äº†unmodifiableMap
          return properties;
      }
      
      // æ·»åŠ æ–°é…ç½®è¿”å›æ–°å¯¹è±¡ï¼Œä¸ä¿®æ”¹åŸå¯¹è±¡
      public ImmutableConfig withProperty(String key, String value) {
          Map<String, String> newProperties = new HashMap<>(properties);
          newProperties.put(key, value);
          return new ImmutableConfig(newProperties);
      }
  }
  ```
  </TabItem>
  <TabItem value="immutable_collection" label="ä¸å¯å˜é›†åˆ">
  ```java
  /**
   * ä¸å¯å˜é›†åˆç±»
   */
  public static final class ImmutableCollection<T> {
      private final List<T> elements; // finalå¼•ç”¨
      
      public ImmutableCollection(Collection<T> elements) {
          this.elements = Collections.unmodifiableList(new ArrayList<>(elements));
      }
      
      public List<T> getElements() {
          // è¿”å›ä¸å¯å˜è§†å›¾
          return elements;
      }
      
      public T get(int index) {
          return elements.get(index);
      }
      
      public int size() {
          return elements.size();
      }
      
      // æ·»åŠ å…ƒç´ è¿”å›æ–°é›†åˆï¼Œä¸ä¿®æ”¹åŸé›†åˆ
      public ImmutableCollection<T> add(T element) {
          List<T> newElements = new ArrayList<>(elements);
          newElements.add(element);
          return new ImmutableCollection<>(newElements);
      }
      
      // ç§»é™¤å…ƒç´ è¿”å›æ–°é›†åˆï¼Œä¸ä¿®æ”¹åŸé›†åˆ
      public ImmutableCollection<T> remove(T element) {
          List<T> newElements = new ArrayList<>(elements);
          newElements.remove(element);
          return new ImmutableCollection<>(newElements);
      }
      
      // åˆ›å»ºä¸€ä¸ªBuilderç±»æ¥é«˜æ•ˆæ„å»ºé›†åˆ
      public static class Builder<T> {
          private final List<T> elements = new ArrayList<>();
          
          public Builder<T> add(T element) {
              elements.add(element);
              return this;
          }
          
          public Builder<T> addAll(Collection<T> collection) {
              elements.addAll(collection);
              return this;
          }
          
          public ImmutableCollection<T> build() {
              return new ImmutableCollection<>(elements);
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="immutable_benefits" label="ä¸å¯å˜ä¼˜åŠ¿">
  <div className="card">
  <div className="card__body">
  
  **ä¸å¯å˜å¯¹è±¡çš„ä¼˜åŠ¿:**
  
  1. **ç»å¯¹çº¿ç¨‹å®‰å…¨**
     - æ— éœ€åŒæ­¥
     - æ— ç«æ€æ¡ä»¶
     - æ— å¹¶å‘ä¿®æ”¹é—®é¢˜
  
  2. **ç®€åŒ–å¼€å‘**
     - ä¸éœ€è¦è€ƒè™‘é”å’ŒåŒæ­¥
     - ç®€åŒ–å¹¶å‘ç®—æ³•
     - å‡å°‘é”™è¯¯å¯èƒ½æ€§
  
  3. **æ€§èƒ½ä¼˜åŠ¿**
     - æ— åŒæ­¥å¼€é”€
     - å¯ä»¥å®‰å…¨ç¼“å­˜
     - é€‚åˆåšé”®å€¼æˆ–Mapçš„é”®
  
  4. **é˜²å¾¡æ€§ç¼–ç¨‹**
     - é¿å…æ„å¤–ä¿®æ”¹
     - çŠ¶æ€ä¸€è‡´æ€§ä¿è¯
     - å†…å­˜æ³„æ¼é£é™©é™ä½
  
  </div>
  </div>
  </TabItem>
</Tabs>

### 2.2 åŒæ­¥æœºåˆ¶ç­–ç•¥

```mermaid
flowchart TD
    A[åŒæ­¥æœºåˆ¶] --> B[å†…ç½®é”<br>synchronized]
    A --> C[æ˜¾å¼é”<br>Lockæ¥å£]
    A --> D[è¯»å†™é”<br>ReadWriteLock]
    
    B --> B1[æ–¹æ³•çº§åŒæ­¥]
    B --> B2[ä»£ç å—åŒæ­¥]
    B --> B3[é™æ€æ–¹æ³•åŒæ­¥]
    
    C --> C1[ReentrantLock]
    C --> C2[å¯ä¸­æ–­]
    C --> C3[è¶…æ—¶]
    C --> C4[å…¬å¹³æ€§]
    
    D --> D1[è¯»é”å…±äº«]
    D --> D2[å†™é”æ’ä»–]
    D --> D3[è¯»å†™åˆ†ç¦»]
```

<Tabs>
  <TabItem value="sync_method" label="æ–¹æ³•åŒæ­¥" default>
  ```java
  /**
   * æ–¹æ³•çº§åŒæ­¥
   */
  public static class MethodSynchronizedCounter {
      private int count = 0;
      
      // æ•´ä¸ªæ–¹æ³•åŒæ­¥ï¼Œé”æ˜¯thiså¯¹è±¡
      public synchronized void increment() {
          count++;
      }
      
      public synchronized void decrement() {
          count--;
      }
      
      public synchronized int getCount() {
          return count;
      }
      
      // é™æ€æ–¹æ³•åŒæ­¥ï¼Œé”æ˜¯ç±»å¯¹è±¡(MethodSynchronizedCounter.class)
      public static synchronized void staticMethod() {
          System.out.println("é™æ€åŒæ­¥æ–¹æ³•");
          // æ“ä½œé™æ€å˜é‡
      }
  }
  ```
  
  **æ–¹æ³•åŒæ­¥ç‰¹ç‚¹ï¼š**
  - é”å¯¹è±¡æ˜¯å½“å‰å®ä¾‹(`this`)æˆ–ç±»å¯¹è±¡(`Class`)
  - æ•´ä¸ªæ–¹æ³•ä½“éƒ½è¢«åŒæ­¥
  - ç®€å•æ˜“ç”¨ï¼Œä½†ç²’åº¦è¾ƒç²—
  - é€‚åˆç®€å•åœºæ™¯
  
  </TabItem>
  <TabItem value="sync_block" label="ä»£ç å—åŒæ­¥">
  ```java
  /**
   * ä»£ç å—åŒæ­¥
   */
  public static class BlockSynchronizedCounter {
      private int count = 0;
      private final Object lock = new Object(); // æ˜¾å¼é”å¯¹è±¡
      
      public void increment() {
          // åªåŒæ­¥å…³é”®ä»£ç å—
          synchronized (lock) {
              count++;
          }
          // è¿™é‡Œæ˜¯éåŒæ­¥ä»£ç ï¼Œå¯ä»¥å¹¶å‘æ‰§è¡Œ
          System.out.println("å½“å‰è®¡æ•°: " + count);
      }
      
      public void decrement() {
          synchronized (lock) {
              count--;
          }
      }
      
      public int getCount() {
          synchronized (lock) {
              return count;
          }
      }
      
      // ä½¿ç”¨ä¸“ç”¨é”å¯¹è±¡
      private final Object readLock = new Object();
      private final Object writeLock = new Object();
      
      public void complexOperation() {
          // ä½¿ç”¨ä¸åŒçš„é”å¯¹è±¡å®ç°æ›´ç»†ç²’åº¦çš„æ§åˆ¶
          synchronized (readLock) {
              // è¯»æ“ä½œ
              int currentValue = count;
              
              // å…¶ä»–çº¿ç¨‹å¯ä»¥åŒæ—¶è·å–writeLock
              // å®ç°æ›´é«˜çš„å¹¶å‘æ€§
              
              synchronized (writeLock) {
                  // å†™æ“ä½œ
                  count = currentValue + 1;
              }
          }
      }
  }
  ```
  
  **ä»£ç å—åŒæ­¥ç‰¹ç‚¹ï¼š**
  - å¯ä»¥æŒ‡å®šä»»æ„å¯¹è±¡ä½œä¸ºé”
  - åªé”å®šå¿…è¦çš„ä»£ç æ®µ
  - å¯ä»¥å®ç°æ›´ç»†ç²’åº¦çš„é”æ§åˆ¶
  - æ€§èƒ½æ›´å¥½ï¼Œå¹¶å‘æ€§æ›´é«˜
  
  </TabItem>
  <TabItem value="reentrant_lock" label="ReentrantLock">
  ```java
  import java.util.concurrent.locks.ReentrantLock;
  import java.util.concurrent.TimeUnit;
  
  /**
   * ä½¿ç”¨ReentrantLock
   */
  public static class ReentrantLockCounter {
      private int count = 0;
      private final ReentrantLock lock = new ReentrantLock();
      
      public void increment() {
          lock.lock(); // è·å–é”
          try {
              count++;
          } finally {
              lock.unlock(); // ç¡®ä¿é”è¢«é‡Šæ”¾
          }
      }
      
      public int getCount() {
          lock.lock();
          try {
              return count;
          } finally {
              lock.unlock();
          }
      }
      
      // Lockæ¥å£æä¾›çš„é¢å¤–åŠŸèƒ½
      
      // 1. å¯ä¸­æ–­è·å–é”
      public void incrementInterruptibly() throws InterruptedException {
          lock.lockInterruptibly(); // å¯ä»¥å“åº”ä¸­æ–­
          try {
              count++;
          } finally {
              lock.unlock();
          }
      }
      
      // 2. å°è¯•è·å–é”
      public boolean tryIncrement() {
          if (lock.tryLock()) { // å°è¯•è·å–é”ï¼Œç«‹å³è¿”å›ç»“æœ
              try {
                  count++;
                  return true;
              } finally {
                  lock.unlock();
              }
          }
          return false; // è·å–é”å¤±è´¥
      }
      
      // 3. è¶…æ—¶è·å–é”
      public boolean tryIncrementWithTimeout() {
          try {
              if (lock.tryLock(1, TimeUnit.SECONDS)) { // å°è¯•åœ¨1ç§’å†…è·å–é”
                  try {
                      count++;
                      return true;
                  } finally {
                      lock.unlock();
                  }
              }
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
          return false; // è·å–é”è¶…æ—¶æˆ–è¢«ä¸­æ–­
      }
  }
  ```
  
  **ReentrantLockç‰¹ç‚¹ï¼š**
  - æ¯”synchronizedæ›´çµæ´»
  - æ”¯æŒä¸­æ–­ã€è¶…æ—¶ã€å…¬å¹³æ€§
  - å¯ä»¥æŸ¥è¯¢é”çŠ¶æ€
  - éœ€è¦æ˜¾å¼è·å–å’Œé‡Šæ”¾
  
  </TabItem>
  <TabItem value="read_write_lock" label="è¯»å†™é”">
  ```java
  import java.util.HashMap;
  import java.util.Map;
  import java.util.concurrent.locks.ReadWriteLock;
  import java.util.concurrent.locks.ReentrantReadWriteLock;
  import java.util.concurrent.locks.Lock;
  
  /**
   * è¯»å†™é”åˆ†ç¦»
   */
  public static class ReadWriteLockCache {
      private final Map<String, String> cache = new HashMap<>();
      private final ReadWriteLock lock = new ReentrantReadWriteLock();
      private final Lock readLock = lock.readLock(); // è¯»é” - å…±äº«é”
      private final Lock writeLock = lock.writeLock(); // å†™é” - æ’ä»–é”
      
      // ä½¿ç”¨è¯»é” - å…è®¸å¹¶å‘è¯»å–
      public String get(String key) {
          readLock.lock();
          try {
              return cache.get(key);
          } finally {
              readLock.unlock();
          }
      }
      
      // ä½¿ç”¨å†™é” - ç‹¬å è®¿é—®
      public void put(String key, String value) {
          writeLock.lock();
          try {
              cache.put(key, value);
          } finally {
              writeLock.unlock();
          }
      }
      
      // å¤åˆæ“ä½œ - è¯»å–å¹¶æœ‰æ¡ä»¶åœ°æ›´æ–°
      public String getOrCreate(String key, String defaultValue) {
          // é¦–å…ˆå°è¯•è¯»å–
          readLock.lock();
          try {
              String value = cache.get(key);
              if (value != null) {
                  return value;
              }
          } finally {
              readLock.unlock(); // é‡Šæ”¾è¯»é”
          }
          
          // å¦‚æœå€¼ä¸å­˜åœ¨ï¼Œè·å–å†™é”åˆ›å»º
          writeLock.lock();
          try {
              // åŒé‡æ£€æŸ¥ï¼Œé¿å…åœ¨è·å–å†™é”æœŸé—´å…¶ä»–çº¿ç¨‹å·²åˆ›å»º
              String value = cache.get(key);
              if (value == null) {
                  value = defaultValue;
                  cache.put(key, value);
              }
              return value;
          } finally {
              writeLock.unlock();
          }
      }
      
      // æŸ¥è¯¢ç¼“å­˜å¤§å° - åªè¯»æ“ä½œ
      public int size() {
          readLock.lock();
          try {
              return cache.size();
          } finally {
              readLock.unlock();
          }
      }
  }
  ```
  
  **è¯»å†™é”ç‰¹ç‚¹ï¼š**
  - è¯»é”å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶æŒæœ‰
  - å†™é”æ˜¯ç‹¬å çš„
  - é€‚åˆè¯»å¤šå†™å°‘çš„åœºæ™¯
  - æé«˜å¹¶å‘æ€§èƒ½
  
  </TabItem>
</Tabs>

### 2.3 åŸå­æ“ä½œç­–ç•¥

```mermaid
classDiagram
    class AtomicPackage {
        <<package>>
    }
    
    class BasicTypes {
        AtomicInteger
        AtomicLong
        AtomicBoolean
    }
    
    class ReferenceTypes {
        AtomicReference
        AtomicStampedReference
        AtomicMarkableReference
    }
    
    class ArrayTypes {
        AtomicIntegerArray
        AtomicLongArray
        AtomicReferenceArray
    }
    
    class FieldUpdaters {
        AtomicIntegerFieldUpdater
        AtomicLongFieldUpdater
        AtomicReferenceFieldUpdater
    }
    
    AtomicPackage --> BasicTypes
    AtomicPackage --> ReferenceTypes
    AtomicPackage --> ArrayTypes
    AtomicPackage --> FieldUpdaters
```

<Tabs>
  <TabItem value="atomic_basic" label="åŸºæœ¬åŸå­ç±»" default>
  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.atomic.AtomicBoolean;
  
  /**
   * åŸºæœ¬ç±»å‹åŸå­ç±»
   */
  public static class AtomicCounter {
      private final AtomicInteger count = new AtomicInteger(0);
      private final AtomicLong total = new AtomicLong(0);
      private final AtomicBoolean flag = new AtomicBoolean(false);
      
      // ç®€å•åŸå­æ“ä½œ
      public void increment() {
          count.incrementAndGet(); // åŸå­è‡ªå¢ï¼Œè¿”å›æ–°å€¼
      }
      
      public void decrement() {
          count.decrementAndGet(); // åŸå­è‡ªå‡ï¼Œè¿”å›æ–°å€¼
      }
      
      public int getCount() {
          return count.get();
      }
      
      // å¤åˆåŸå­æ“ä½œ
      public void addToTotal(long value) {
          total.addAndGet(value); // åŸå­åŠ æ³•ï¼Œè¿”å›æ–°å€¼
      }
      
      public boolean setFlagIfNot(boolean expect, boolean update) {
          return flag.compareAndSet(expect, update); // æ¯”è¾ƒå¹¶è®¾ç½®
      }
      
      // æ›´å¤æ‚çš„åŸå­æ“ä½œ
      public int incrementAndGetWithLimit(int limit) {
          return count.updateAndGet(current -> Math.min(current + 1, limit));
      }
      
      // çº¿ç¨‹å®‰å…¨çš„ç»Ÿè®¡æ“ä½œ
      public void updateStatistics(int value) {
          // æ›´æ–°æœ€å¤§å€¼
          count.accumulateAndGet(value, Math::max);
          
          // æ›´æ–°æ€»å’Œ
          total.addAndGet(value);
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_reference" label="å¼•ç”¨ç±»å‹åŸå­ç±»">
  ```java
  import java.util.concurrent.atomic.AtomicReference;
  import java.util.concurrent.atomic.AtomicStampedReference;
  
  /**
   * å¼•ç”¨ç±»å‹åŸå­ç±»
   */
  public static class AtomicReferenceExample {
      // ä½¿ç”¨AtomicReferenceå­˜å‚¨å¯¹è±¡å¼•ç”¨
      private final AtomicReference<String> message = new AtomicReference<>("åˆå§‹æ¶ˆæ¯");
      
      // ä½¿ç”¨AtomicStampedReferenceå¤„ç†ABAé—®é¢˜
      private final AtomicStampedReference<Integer> account = 
          new AtomicStampedReference<>(100, 0); // åˆå§‹å€¼100ï¼Œç‰ˆæœ¬å·0
      
      public void updateMessage(String newMessage) {
          message.set(newMessage);
      }
      
      public String getMessage() {
          return message.get();
      }
      
      // åŸå­æ–¹å¼æ›´æ–°å¯¹è±¡å¼•ç”¨
      public boolean compareAndSetMessage(String expect, String update) {
          return message.compareAndSet(expect, update);
      }
      
      // å¤„ç†ABAé—®é¢˜çš„åŸå­æ“ä½œ
      public boolean withdraw(int amount) {
          int[] stampHolder = new int[1]; // ç”¨äºä¿å­˜å½“å‰ç‰ˆæœ¬å·
          Integer currentBalance = account.get(stampHolder);
          int currentStamp = stampHolder[0];
          
          if (currentBalance >= amount) {
              // ç¡®ä¿ä½™é¢å’Œç‰ˆæœ¬å·éƒ½æ²¡æœ‰å˜åŒ–
              return account.compareAndSet(
                  currentBalance, 
                  currentBalance - amount,
                  currentStamp, 
                  currentStamp + 1 // ç‰ˆæœ¬å·+1
              );
          }
          
          return false;
      }
      
      // æ›´å¤æ‚çš„åŸå­å¼•ç”¨æ›´æ–°
      public void updateMessageIfNecessary(String newMessageIfEmpty) {
          message.updateAndGet(current -> 
              (current == null || current.isEmpty()) ? newMessageIfEmpty : current
          );
      }
  }
  ```
  </TabItem>
  <TabItem value="atomic_array" label="æ•°ç»„åŸå­ç±»">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerArray;
  
  /**
   * æ•°ç»„åŸå­ç±»
   */
  public static class AtomicArrayExample {
      // çº¿ç¨‹å®‰å…¨çš„æ•´æ•°æ•°ç»„
      private final AtomicIntegerArray counters;
      
      public AtomicArrayExample(int size) {
          this.counters = new AtomicIntegerArray(size);
      }
      
      // åŸå­æ–¹å¼é€’å¢æ•°ç»„æŒ‡å®šä½ç½®çš„å€¼
      public int incrementAndGet(int index) {
          return counters.incrementAndGet(index);
      }
      
      // è·å–æ•°ç»„å…ƒç´ 
      public int get(int index) {
          return counters.get(index);
      }
      
      // åŸå­æ–¹å¼æ›´æ–°æ•°ç»„å…ƒç´ 
      public boolean compareAndSet(int index, int expect, int update) {
          return counters.compareAndSet(index, expect, update);
      }
      
      // åŸå­æ–¹å¼æ·»åŠ å€¼
      public int addAndGet(int index, int delta) {
          return counters.addAndGet(index, delta);
      }
      
      // è·å–å¹¶é‡ç½®æŸä¸ªä½ç½®çš„è®¡æ•°å™¨
      public int getAndReset(int index) {
          return counters.getAndSet(index, 0);
      }
      
      // æ‰“å°æ‰€æœ‰è®¡æ•°å™¨å€¼
      public void printAll() {
          for (int i = 0; i < counters.length(); i++) {
              System.out.println("Counter[" + i + "] = " + counters.get(i));
          }
      }
  }
  ```
  </TabItem>
  <TabItem value="field_updater" label="å­—æ®µæ›´æ–°å™¨">
  ```java
  import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
  import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
  
  /**
   * å­—æ®µæ›´æ–°å™¨ - ä¸åˆ›å»ºæ–°å¯¹è±¡çš„æƒ…å†µä¸‹å®ç°åŸå­æ›´æ–°å­—æ®µ
   */
  public static class FieldUpdaterExample {
      // éœ€è¦æ›´æ–°çš„ç±»
      public static class User {
          // å¿…é¡»æ˜¯volatileä¸”è®¿é—®çº§åˆ«å¯¹æ›´æ–°å™¨å¯è§
          public volatile int score;
          public volatile String name;
          
          public User(String name, int score) {
              this.name = name;
              this.score = score;
          }
          
          @Override
          public String toString() {
              return "User{name='" + name + "', score=" + score + '}';
          }
      }
      
      // åˆ›å»ºåŸå­æ›´æ–°å™¨
      private static final AtomicIntegerFieldUpdater<User> SCORE_UPDATER = 
          AtomicIntegerFieldUpdater.newUpdater(User.class, "score");
      
      private static final AtomicReferenceFieldUpdater<User, String> NAME_UPDATER =
          AtomicReferenceFieldUpdater.newUpdater(User.class, String.class, "name");
      
      // åŸå­æ–¹å¼å¢åŠ åˆ†æ•°
      public static void incrementScore(User user) {
          SCORE_UPDATER.incrementAndGet(user);
      }
      
      // åŸå­æ–¹å¼æ›´æ–°åç§°
      public static boolean updateName(User user, String expect, String update) {
          return NAME_UPDATER.compareAndSet(user, expect, update);
      }
      
      public static void main(String[] args) {
          User user = new User("Alice", 100);
          System.out.println("Initial: " + user);
          
          incrementScore(user);
          System.out.println("After increment: " + user);
          
          updateName(user, "Alice", "Alice_Updated");
          System.out.println("After name update: " + user);
      }
  }
  ```
  </TabItem>
</Tabs>

### 2.4 çº¿ç¨‹æœ¬åœ°å­˜å‚¨ç­–ç•¥

```mermaid
graph TD
    A[ThreadLocal] --> B[çº¿ç¨‹éš”ç¦»]
    A --> C[é¿å…å…±äº«]
    A --> D[ä¸Šä¸‹æ–‡ä¼ é€’]
    
    B --> B1[æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹å‰¯æœ¬]
    C --> C1[æ¶ˆé™¤ç«äº‰æ¡ä»¶]
    D --> D1[çº¿ç¨‹å†…æ•°æ®å…±äº«]
    
    subgraph åº”ç”¨åœºæ™¯
        E[ä¼šè¯ä¿¡æ¯]
        F[æ•°æ®åº“è¿æ¥]
        G[ç”¨æˆ·è®¤è¯]
        H[è¯·æ±‚ä¸Šä¸‹æ–‡]
    end
    
    A --> E
    A --> F
    A --> G
    A --> H
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
```

<div className="card">
<div className="card__header">
<h4>ThreadLocalåŸºæœ¬æ¦‚å¿µ</h4>
</div>
<div className="card__body">

**ThreadLocal**æ˜¯Javaä¸­çš„ä¸€ç§çº¿ç¨‹éš”ç¦»æœºåˆ¶ï¼Œå®ƒä¸ºæ¯ä¸ªçº¿ç¨‹æä¾›äº†ä¸€ä¸ªç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œä½¿å¾—æ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥ç‹¬ç«‹åœ°æ”¹å˜è‡ªå·±çš„å‰¯æœ¬ï¼Œè€Œä¸ä¼šå½±å“å…¶ä»–çº¿ç¨‹æ‰€å¯¹åº”çš„å‰¯æœ¬ã€‚

**ä¸»è¦ç‰¹ç‚¹ï¼š**

1. **çº¿ç¨‹éš”ç¦»**ï¼šæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„ç‹¬ç«‹å‰¯æœ¬
2. **é¿å…åŒæ­¥**ï¼šä¸éœ€è¦åŠ é”å°±èƒ½ä¿è¯çº¿ç¨‹å®‰å…¨
3. **ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šæ–¹ä¾¿åœ°åœ¨åŒä¸€çº¿ç¨‹å†…çš„ä¸åŒæ–¹æ³•ä¹‹é—´ä¼ é€’æ•°æ®
4. **å‡å°‘å‚æ•°ä¼ é€’**ï¼šç®€åŒ–æ–¹æ³•è°ƒç”¨ï¼Œå‡å°‘å‚æ•°ä¼ é€’

**ä½¿ç”¨åœºæ™¯ï¼š**

- å­˜å‚¨ç”¨æˆ·èº«ä»½ä¿¡æ¯
- æ•°æ®åº“è¿æ¥ç®¡ç†
- äº‹åŠ¡ç®¡ç†
- è¯·æ±‚ä¸Šä¸‹æ–‡
- çº¿ç¨‹çº§åˆ«ç¼“å­˜

</div>
</div>

<Tabs>
  <TabItem value="basic_threadlocal" label="åŸºæœ¬ç”¨æ³•" default>
  ```java
  /**
   * åŸºæœ¬ThreadLocalä½¿ç”¨
   */
  public static class ThreadLocalCounter {
      // å®šä¹‰ä¸€ä¸ªThreadLocalå˜é‡ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ç‹¬ç«‹çš„è®¡æ•°å™¨
      private static final ThreadLocal<Integer> counter = new ThreadLocal<>();
      
      public static void setCounter(int value) {
          counter.set(value);
      }
      
      public static int getCounter() {
          // å¤„ç†nullå€¼æƒ…å†µ
          Integer value = counter.get();
          return value != null ? value : 0;
      }
      
      public static void increment() {
          // è·å–å½“å‰çº¿ç¨‹çš„è®¡æ•°å™¨å€¼
          Integer current = counter.get();
          if (current == null) {
              current = 0;
          }
          // æ›´æ–°å½“å‰çº¿ç¨‹çš„è®¡æ•°å™¨å€¼
          counter.set(current + 1);
      }
      
      // éå¸¸é‡è¦ï¼šæ¸…é™¤ThreadLocalå€¼ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
      public static void remove() {
          counter.remove();
      }
      
      public static void main(String[] args) {
          // çº¿ç¨‹1
          new Thread(() -> {
              ThreadLocalCounter.setCounter(10);
              ThreadLocalCounter.increment();
              System.out.println("çº¿ç¨‹1è®¡æ•°å™¨: " + ThreadLocalCounter.getCounter()); // 11
              ThreadLocalCounter.remove(); // é˜²æ­¢å†…å­˜æ³„æ¼
          }).start();
          
          // çº¿ç¨‹2
          new Thread(() -> {
              ThreadLocalCounter.setCounter(20);
              ThreadLocalCounter.increment();
              System.out.println("çº¿ç¨‹2è®¡æ•°å™¨: " + ThreadLocalCounter.getCounter()); // 21
              ThreadLocalCounter.remove(); // é˜²æ­¢å†…å­˜æ³„æ¼
          }).start();
      }
  }
  ```
  </TabItem>
  <TabItem value="initial_value" label="åˆå§‹å€¼">
  ```java
  /**
   * å¸¦åˆå§‹å€¼çš„ThreadLocal
   */
  public static class ThreadLocalWithInitial {
      // å®šä¹‰å¸¦åˆå§‹å€¼çš„ThreadLocalï¼Œé¿å…ç©ºæŒ‡é’ˆå¼‚å¸¸
      private static final ThreadLocal<Integer> counter = 
          ThreadLocal.withInitial(() -> 0);
      
      private static final ThreadLocal<List<String>> itemList =
          ThreadLocal.withInitial(ArrayList::new);
      
      public static void increment() {
          // æ— éœ€å¤„ç†nullå€¼æƒ…å†µï¼Œå› ä¸ºæœ‰åˆå§‹å€¼
          counter.set(counter.get() + 1);
      }
      
      public static int getCounter() {
          return counter.get();
      }
      
      public static void addItem(String item) {
          // ç›´æ¥ä½¿ç”¨çº¿ç¨‹æœ¬åœ°çš„Listï¼Œæ— éœ€æ£€æŸ¥null
          itemList.get().add(item);
      }
      
      public static List<String> getItems() {
          return itemList.get();
      }
      
      public static void clear() {
          counter.remove();
          itemList.remove();
      }
  }
  ```
  </TabItem>
  <TabItem value="user_context" label="ç”¨æˆ·ä¸Šä¸‹æ–‡">
  ```java
  /**
   * ç”¨æˆ·ä¸Šä¸‹æ–‡ThreadLocal
   */
  public static class UserContext {
      // å­˜å‚¨å½“å‰çº¿ç¨‹å…³è”çš„ç”¨æˆ·ä¿¡æ¯
      private static final ThreadLocal<User> userHolder = new ThreadLocal<>();
      
      public static void setUser(User user) {
          userHolder.set(user);
      }
      
      public static User getUser() {
          return userHolder.get();
      }
      
      public static void clear() {
          userHolder.remove();
      }
      
      // ä¾¿æ·æ–¹æ³•ï¼Œè·å–ç”¨æˆ·ID
      public static String getUserId() {
          User user = getUser();
          return user != null ? user.getId() : null;
      }
      
      // ä¾¿æ·æ–¹æ³•ï¼Œæ£€æŸ¥ç”¨æˆ·æƒé™
      public static boolean hasPermission(String permission) {
          User user = getUser();
          return user != null && user.hasPermission(permission);
      }
      
      // ä¸Šä¸‹æ–‡ç®¡ç†ï¼Œä½¿ç”¨try-with-resourcesæ¨¡å¼
      public static class UserContextHolder implements AutoCloseable {
          public UserContextHolder(User user) {
              setUser(user);
          }
          
          @Override
          public void close() {
              clear();
          }
      }
      
      // ä½¿ç”¨ç¤ºä¾‹
      public static void processUserRequest(User user) {
          try (UserContextHolder holder = new UserContextHolder(user)) {
              // åœ¨æ•´ä¸ªæ–¹æ³•è°ƒç”¨é“¾ä¸­éƒ½å¯ä»¥è®¿é—®ç”¨æˆ·ä¿¡æ¯
              service1();
              service2();
              service3();
          }
      }
      
      private static void service1() {
          System.out.println("Service1å¤„ç†ç”¨æˆ·: " + getUserId());
      }
      
      private static void service2() {
          if (hasPermission("ADMIN")) {
              System.out.println("æ‰§è¡Œç®¡ç†å‘˜æ“ä½œ");
          }
      }
      
      private static void service3() {
          System.out.println("Service3å¤„ç†ç”¨æˆ·: " + getUser().getName());
      }
  }
  ```
  </TabItem>
  <TabItem value="inheritable" label="ç»§æ‰¿ThreadLocal">
  ```java
  /**
   * å¯ç»§æ‰¿çš„ThreadLocal
   * å­çº¿ç¨‹å¯ä»¥ç»§æ‰¿çˆ¶çº¿ç¨‹çš„å€¼
   */
  public static class InheritableThreadLocalExample {
      // æ™®é€šThreadLocal - ä¸ä¼šä¼ é€’ç»™å­çº¿ç¨‹
      private static final ThreadLocal<String> threadLocal = 
          ThreadLocal.withInitial(() -> "åˆå§‹å€¼");
      
      // InheritableThreadLocal - ä¼šä¼ é€’ç»™å­çº¿ç¨‹
      private static final InheritableThreadLocal<String> inheritableThreadLocal = 
          new InheritableThreadLocal<String>() {
              @Override
              protected String initialValue() {
                  return "å¯ç»§æ‰¿çš„åˆå§‹å€¼";
              }
              
              @Override
              protected String childValue(String parentValue) {
                  // å¯ä»¥è‡ªå®šä¹‰å­çº¿ç¨‹çš„åˆå§‹å€¼
                  return parentValue + " (å­çº¿ç¨‹ç»§æ‰¿)";
              }
          };
      
      public static void main(String[] args) {
          // è®¾ç½®çˆ¶çº¿ç¨‹çš„å€¼
          threadLocal.set("çˆ¶çº¿ç¨‹å€¼");
          inheritableThreadLocal.set("çˆ¶çº¿ç¨‹å¯ç»§æ‰¿å€¼");
          
          // åˆ›å»ºå­çº¿ç¨‹
          new Thread(() -> {
              // æ™®é€šThreadLocalæ— æ³•ç»§æ‰¿çˆ¶çº¿ç¨‹çš„å€¼
              System.out.println("å­çº¿ç¨‹ threadLocal: " + threadLocal.get());
              // InheritableThreadLocalå¯ä»¥ç»§æ‰¿çˆ¶çº¿ç¨‹çš„å€¼
              System.out.println("å­çº¿ç¨‹ inheritableThreadLocal: " + inheritableThreadLocal.get());
          }).start();
          
          // çˆ¶çº¿ç¨‹è¾“å‡º
          System.out.println("çˆ¶çº¿ç¨‹ threadLocal: " + threadLocal.get());
          System.out.println("çˆ¶çº¿ç¨‹ inheritableThreadLocal: " + inheritableThreadLocal.get());
      }
  }
  ```
  </TabItem>
  <TabItem value="memory_leak" label="å†…å­˜æ³„æ¼é—®é¢˜">
  <div className="card">
  <div className="card__body">
  
  **ThreadLocalæ½œåœ¨çš„å†…å­˜æ³„æ¼é—®é¢˜:**
  
  1. **é—®é¢˜åŸå› **
     - ThreadLocalå˜é‡å­˜å‚¨åœ¨Threadå¯¹è±¡çš„ThreadLocalMapä¸­
     - ThreadLocalMapä½¿ç”¨ThreadLocalä½œä¸ºkeyçš„å¼±å¼•ç”¨
     - å¦‚æœThreadLocalæ²¡æœ‰å¼ºå¼•ç”¨ï¼Œä½†Threadä»å­˜æ´»ï¼Œåˆ™å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
  
  2. **é˜²æ­¢å†…å­˜æ³„æ¼çš„æœ€ä½³å®è·µ**
     - åœ¨ä¸éœ€è¦ThreadLocalå˜é‡æ—¶ï¼Œ**åŠ¡å¿…è°ƒç”¨remove()æ–¹æ³•**
     - ä½¿ç”¨try-finallyç¡®ä¿remove()è¢«è°ƒç”¨
     - å¯¹äºçº¿ç¨‹æ± åœºæ™¯ï¼Œç‰¹åˆ«è¦æ³¨æ„æ¸…ç†ThreadLocalå˜é‡
  
  ```java
  // æ­£ç¡®ä½¿ç”¨ThreadLocalçš„æ¨¡å¼
  ThreadLocal<Resource> resourceHolder = new ThreadLocal<>();
  try {
      resourceHolder.set(createResource());
      // ä½¿ç”¨èµ„æº
      useResource();
  } finally {
      // å…³é”®: ä¸å†éœ€è¦æ—¶ç§»é™¤ThreadLocalå˜é‡
      resourceHolder.remove();
  }
  ```
  
  </div>
  </div>
  </TabItem>
</Tabs>

## 3. å¸¸è§çº¿ç¨‹å®‰å…¨é—®é¢˜

### 3.1 ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰

ç«æ€æ¡ä»¶æ˜¯æŒ‡å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å’Œä¿®æ”¹å…±äº«æ•°æ®æ—¶å‡ºç°çš„é—®é¢˜ã€‚

```java title="ç«æ€æ¡ä»¶ç¤ºä¾‹"
public class RaceConditionExamples {
    
    /**
     * ä¸å®‰å…¨çš„è®¡æ•°å™¨ - å­˜åœ¨ç«æ€æ¡ä»¶
     */
    public static class UnsafeCounter {
    private int count = 0;
    
    public void increment() {
            // éåŸå­æ“ä½œï¼šè¯»å– -> ä¿®æ”¹ -> å†™å…¥
            count++;
        }
        
        public void decrement() {
            count--;
    }
    
    public int getCount() {
        return count;
    }
}

    /**
     * å®‰å…¨çš„è®¡æ•°å™¨ - ä½¿ç”¨åŒæ­¥è§£å†³ç«æ€æ¡ä»¶
     */
    public static class SafeCounter {
        private int count = 0;
        private final Object lock = new Object();
        
        public void increment() {
            synchronized (lock) {
                count++;
            }
        }
        
        public void decrement() {
            synchronized (lock) {
                count--;
            }
        }
        
        public int getCount() {
            synchronized (lock) {
                return count;
            }
        }
    }
    
    /**
     * ä½¿ç”¨åŸå­ç±»è§£å†³ç«æ€æ¡ä»¶
     */
    public static class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();
    }
        
        public void decrement() {
            count.decrementAndGet();
    }
    
    public int getCount() {
        return count.get();
        }
    }
    
    /**
     * å¤åˆæ“ä½œçš„ç«æ€æ¡ä»¶
     */
    public static class UnsafeBankAccount {
        private double balance = 1000.0;
        
        public void withdraw(double amount) {
            if (balance >= amount) {
                // æ£€æŸ¥å’Œå–æ¬¾ä¹‹é—´å­˜åœ¨ç«æ€æ¡ä»¶
                try {
                    Thread.sleep(100); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                balance -= amount;
                System.out.println("å–æ¬¾æˆåŠŸ: " + amount + ", ä½™é¢: " + balance);
            } else {
                System.out.println("ä½™é¢ä¸è¶³");
            }
        }
        
        public double getBalance() {
            return balance;
        }
    }
    
    /**
     * è§£å†³å¤åˆæ“ä½œç«æ€æ¡ä»¶
     */
    public static class SafeBankAccount {
        private double balance = 1000.0;
        private final Object lock = new Object();
        
        public void withdraw(double amount) {
            synchronized (lock) {
                if (balance >= amount) {
                    try {
                        Thread.sleep(100); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    balance -= amount;
                    System.out.println("å–æ¬¾æˆåŠŸ: " + amount + ", ä½™é¢: " + balance);
                } else {
                    System.out.println("ä½™é¢ä¸è¶³");
                }
            }
        }
        
        public double getBalance() {
            synchronized (lock) {
                return balance;
            }
        }
    }
}
```

### 3.2 å†…å­˜å¯è§æ€§é—®é¢˜

ä¸€ä¸ªçº¿ç¨‹å¯¹å…±äº«å˜é‡çš„ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹ä¸å¯è§ã€‚

```java title="å†…å­˜å¯è§æ€§é—®é¢˜ç¤ºä¾‹"
public class VisibilityProblemExamples {
    
    /**
     * å¯è§æ€§é—®é¢˜ç¤ºä¾‹
     */
    public static class VisibilityProblem {
    private boolean flag = false;
    
    public void setFlag() {
        flag = true;
    }
    
    public boolean getFlag() {
        return flag;
    }
}

    /**
     * ä½¿ç”¨volatileè§£å†³å¯è§æ€§é—®é¢˜
     */
    public static class VisibilitySolution {
    private volatile boolean flag = false;
    
    public void setFlag() {
        flag = true;
    }
    
    public boolean getFlag() {
        return flag;
        }
    }
    
    /**
     * ä½¿ç”¨synchronizedè§£å†³å¯è§æ€§é—®é¢˜
     */
    public static class SynchronizedVisibility {
        private boolean flag = false;
        private final Object lock = new Object();
        
        public void setFlag() {
            synchronized (lock) {
                flag = true;
            }
        }
        
        public boolean getFlag() {
            synchronized (lock) {
                return flag;
            }
        }
    }
    
    /**
     * ä½¿ç”¨åŸå­ç±»è§£å†³å¯è§æ€§é—®é¢˜
     */
    public static class AtomicVisibility {
        private AtomicBoolean flag = new AtomicBoolean(false);
        
        public void setFlag() {
            flag.set(true);
        }
        
        public boolean getFlag() {
            return flag.get();
        }
    }
    
    /**
     * åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼
     */
    public static class DoubleCheckedLocking {
        private volatile static DoubleCheckedLocking instance;
        
        private DoubleCheckedLocking() {}
        
        public static DoubleCheckedLocking getInstance() {
            if (instance == null) {
                synchronized (DoubleCheckedLocking.class) {
                    if (instance == null) {
                        instance = new DoubleCheckedLocking();
                    }
                }
            }
            return instance;
        }
    }
}
```

### 3.3 æ­»é”é—®é¢˜

å¤šä¸ªçº¿ç¨‹äº’ç›¸ç­‰å¾…å¯¹æ–¹é‡Šæ”¾èµ„æºã€‚

```java title="æ­»é”é—®é¢˜ç¤ºä¾‹"
public class DeadlockExamples {
    
    /**
     * ç»å…¸æ­»é”ç¤ºä¾‹
     */
    public static class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {
                System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”1");
            try {
                    Thread.sleep(100); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
            }
                
            synchronized (lock2) {
                    System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”2");
            }
        }
    }
    
    public void method2() {
        synchronized (lock2) {
                System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”2");
                try {
                    Thread.sleep(100); // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                synchronized (lock1) {
                    System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”1");
                }
            }
        }
    }
    
    /**
     * è§£å†³æ­»é” - å›ºå®šé”é¡ºåº
     */
    public static class SafeLockExample {
        private final Object lock1 = new Object();
        private final Object lock2 = new Object();
        
        public void method1() {
            synchronized (lock1) {
                System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”1");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                synchronized (lock2) {
                    System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”2");
                }
            }
        }
        
        public void method2() {
            // ä½¿ç”¨ç›¸åŒçš„é”é¡ºåº
            synchronized (lock1) {
                System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                synchronized (lock2) {
                    System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”2");
                }
            }
        }
    }
    
    /**
     * è§£å†³æ­»é” - ä½¿ç”¨è¶…æ—¶æœºåˆ¶
     */
    public static class TimeoutLockExample {
        private final ReentrantLock lock1 = new ReentrantLock();
        private final ReentrantLock lock2 = new ReentrantLock();
        
        public void method1() {
            if (lock1.tryLock()) {
                try {
                    System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”1");
                    Thread.sleep(100);
                    
                    if (lock2.tryLock(5, TimeUnit.SECONDS)) {
                        try {
                            System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”2");
                        } finally {
                            lock2.unlock();
                        }
                    } else {
                        System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å–é”2è¶…æ—¶");
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    lock1.unlock();
                }
            }
        }
        
        public void method2() {
            if (lock2.tryLock()) {
                try {
                    System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”2");
                    Thread.sleep(100);
                    
                    if (lock1.tryLock(5, TimeUnit.SECONDS)) {
                        try {
                            System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å¾—é”1");
                        } finally {
                            lock1.unlock();
                        }
                    } else {
                        System.out.println("çº¿ç¨‹ " + Thread.currentThread().getName() + " è·å–é”1è¶…æ—¶");
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    lock2.unlock();
                }
            }
        }
    }
}
```

## 4. çº¿ç¨‹å®‰å…¨æœ€ä½³å®è·µ

### 4.1 è®¾è®¡åŸåˆ™

:::tip æ ¸å¿ƒåŸåˆ™
è®¾è®¡çº¿ç¨‹å®‰å…¨ä»£ç æ—¶ï¼Œåº”éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
- **ä¼˜å…ˆä½¿ç”¨ä¸å¯å˜å¯¹è±¡**ï¼šé¿å…çŠ¶æ€å˜åŒ–å¸¦æ¥çš„å¤æ‚æ€§
- **æœ€å°åŒ–åŒæ­¥èŒƒå›´**ï¼šåªåŒæ­¥å¿…è¦çš„ä»£ç å—
- **ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„é›†åˆ**ï¼šé¿å…æ‰‹åŠ¨åŒæ­¥
- **é¿å…åµŒå¥—é”**ï¼šé˜²æ­¢æ­»é”
- **æ­£ç¡®ä½¿ç”¨volatile**ï¼šç†è§£å…¶å±€é™æ€§
:::

### 4.2 ä»£ç å®è·µ

```java title="çº¿ç¨‹å®‰å…¨æœ€ä½³å®è·µç¤ºä¾‹"
public class ThreadSafetyBestPractices {
    
    /**
     * 1. ä¼˜å…ˆä½¿ç”¨ä¸å¯å˜å¯¹è±¡
     */
    public static final class ImmutableConfiguration {
        private final Map<String, String> config;
        
        public ImmutableConfiguration(Map<String, String> config) {
            this.config = Collections.unmodifiableMap(new HashMap<>(config));
        }
        
        public String getValue(String key) {
            return config.get(key);
        }
        
        public ImmutableConfiguration withValue(String key, String value) {
            Map<String, String> newConfig = new HashMap<>(config);
            newConfig.put(key, value);
            return new ImmutableConfiguration(newConfig);
        }
    }
    
    /**
     * 2. ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„é›†åˆ
     */
    public static class ThreadSafeCollections {
// æ¨èï¼šä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„é›†åˆ
        private final Map<String, String> safeMap = new ConcurrentHashMap<>();
        private final List<String> safeList = Collections.synchronizedList(new ArrayList<>());
        private final Queue<String> safeQueue = new ConcurrentLinkedQueue<>();
        
        public void addToMap(String key, String value) {
            safeMap.put(key, value);
        }
        
        public void addToList(String item) {
            safeList.add(item);
        }
        
        public void addToQueue(String item) {
            safeQueue.offer(item);
        }
    }
    
    /**
     * 3. æœ€å°åŒ–åŒæ­¥èŒƒå›´
     */
    public static class MinimizedSynchronization {
        private final Object lock = new Object();
        private int counter = 0;
        
        // ä¸æ¨èï¼šåŒæ­¥æ•´ä¸ªæ–¹æ³•
public synchronized void badMethod() {
    // è€—æ—¶æ“ä½œ
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
    }
            // åªæœ‰è¿™ä¸€è¡Œéœ€è¦åŒæ­¥
            counter++;
}

// æ¨èï¼šåªåŒæ­¥å¿…è¦çš„éƒ¨åˆ†
public void goodMethod() {
            // è€—æ—¶æ“ä½œä¸éœ€è¦åŒæ­¥
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
    }
    
    // åªåŒæ­¥å…³é”®éƒ¨åˆ†
            synchronized (lock) {
                counter++;
            }
        }
    }
    
    /**
     * 4. ä½¿ç”¨åŸå­ç±»
     */
    public static class AtomicBestPractices {
        private final AtomicInteger counter = new AtomicInteger(0);
        private final AtomicReference<String> reference = new AtomicReference<>("initial");
    
    public void increment() {
        counter.incrementAndGet();
    }
    
    public void updateReference(String newValue) {
        reference.set(newValue);
        }
        
        public boolean compareAndSetReference(String expect, String update) {
            return reference.compareAndSet(expect, update);
        }
    }
    
    /**
     * 5. æ­£ç¡®çš„å¼‚å¸¸å¤„ç†
     */
    public static class ExceptionHandling {
        private final ReentrantLock lock = new ReentrantLock();
        private int value = 0;
        
        public void safeIncrement() {
            lock.lock();
            try {
                value++;
                // å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„æ“ä½œ
                if (value > 100) {
                    throw new RuntimeException("å€¼è¿‡å¤§");
                }
            } finally {
                lock.unlock(); // ç¡®ä¿é”è¢«é‡Šæ”¾
            }
        }
    }
}
```

## 5. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 5.1 å‡å°‘é”ç«äº‰

```java title="å‡å°‘é”ç«äº‰ç¤ºä¾‹"
public class LockContentionOptimization {
    
    /**
     * é”åˆ†æ®µæŠ€æœ¯
     */
    public static class StripedCounter {
        private final int segments = 16;
        private final Object[] locks = new Object[segments];
        private final int[] counters = new int[segments];
        
        public StripedCounter() {
            for (int i = 0; i < segments; i++) {
                locks[i] = new Object();
            }
        }
        
        public void increment(int key) {
            int segment = Math.abs(key % segments);
            synchronized (locks[segment]) {
                counters[segment]++;
            }
        }
        
        public int getTotal() {
            int total = 0;
            for (int i = 0; i < segments; i++) {
                synchronized (locks[i]) {
                    total += counters[i];
                }
            }
            return total;
        }
    }
    
    /**
     * è¯»å†™é”åˆ†ç¦»
     */
    public static class ReadWriteOptimizedCache {
        private final Map<String, String> cache = new HashMap<>();
        private final ReadWriteLock lock = new ReentrantReadWriteLock();
        private final Lock readLock = lock.readLock();
        private final Lock writeLock = lock.writeLock();
        
        public String get(String key) {
            readLock.lock();
            try {
                return cache.get(key);
            } finally {
                readLock.unlock();
            }
        }
        
        public void put(String key, String value) {
            writeLock.lock();
            try {
                cache.put(key, value);
            } finally {
                writeLock.unlock();
            }
        }
    }
}
```

### 5.2 æ— é”ç¼–ç¨‹

```java title="æ— é”ç¼–ç¨‹ç¤ºä¾‹"
public class LockFreeProgramming {
    
    /**
     * æ— é”æ ˆå®ç°
     */
    public static class LockFreeStack<T> {
        private AtomicReference<Node<T>> top = new AtomicReference<>();
        
        public void push(T item) {
            Node<T> newHead = new Node<>(item);
            Node<T> oldHead;
            do {
                oldHead = top.get();
                newHead.next = oldHead;
            } while (!top.compareAndSet(oldHead, newHead));
        }
        
        public T pop() {
            Node<T> oldHead;
            Node<T> newHead;
            do {
                oldHead = top.get();
                if (oldHead == null) {
                    return null;
                }
                newHead = oldHead.next;
            } while (!top.compareAndSet(oldHead, newHead));
            return oldHead.item;
        }
        
        private static class Node<T> {
            final T item;
            Node<T> next;
            
            Node(T item) {
                this.item = item;
            }
        }
    }
    
    /**
     * æ— é”é˜Ÿåˆ—å®ç°
     */
    public static class LockFreeQueue<T> {
        private AtomicReference<Node<T>> head = new AtomicReference<>();
        private AtomicReference<Node<T>> tail = new AtomicReference<>();
        
        public LockFreeQueue() {
            Node<T> dummy = new Node<>(null);
            head.set(dummy);
            tail.set(dummy);
        }
        
        public void enqueue(T item) {
            Node<T> newNode = new Node<>(item);
            while (true) {
                Node<T> last = tail.get();
                Node<T> next = last.next.get();
                if (last == tail.get()) {
                    if (next == null) {
                        if (last.next.compareAndSet(null, newNode)) {
                            tail.compareAndSet(last, newNode);
                            return;
                        }
                    } else {
                        tail.compareAndSet(last, next);
                    }
                }
            }
        }
        
        public T dequeue() {
            while (true) {
                Node<T> first = head.get();
                Node<T> last = tail.get();
                Node<T> next = first.next.get();
                if (first == head.get()) {
                    if (first == last) {
                        if (next == null) {
                            return null;
                        }
                        tail.compareAndSet(last, next);
                    } else {
                        T item = next.item;
                        if (head.compareAndSet(first, next)) {
                            return item;
                        }
                    }
                }
            }
        }
        
        private static class Node<T> {
            final T item;
            final AtomicReference<Node<T>> next = new AtomicReference<>();
            
            Node(T item) {
                this.item = item;
            }
        }
    }
}
```

## 6. æ€»ç»“

çº¿ç¨‹å®‰å…¨æ˜¯Javaå¹¶å‘ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µï¼ŒæŒæ¡çº¿ç¨‹å®‰å…¨çš„å®ç°ç­–ç•¥å’Œæœ€ä½³å®è·µå¯¹äºæ„å»ºé«˜è´¨é‡çš„å¹¶å‘åº”ç”¨è‡³å…³é‡è¦ã€‚

### 6.1 å…³é”®è¦ç‚¹

1. **çº¿ç¨‹å®‰å…¨ç­–ç•¥**ï¼šä¸å¯å˜å¯¹è±¡ã€åŒæ­¥æœºåˆ¶ã€åŸå­æ“ä½œã€çº¿ç¨‹æœ¬åœ°å­˜å‚¨
2. **å¸¸è§é—®é¢˜**ï¼šç«æ€æ¡ä»¶ã€å†…å­˜å¯è§æ€§ã€æ­»é”
3. **æœ€ä½³å®è·µ**ï¼šä¼˜å…ˆä½¿ç”¨ä¸å¯å˜å¯¹è±¡ã€æœ€å°åŒ–åŒæ­¥èŒƒå›´ã€ä½¿ç”¨çº¿ç¨‹å®‰å…¨é›†åˆ
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šå‡å°‘é”ç«äº‰ã€æ— é”ç¼–ç¨‹ã€è¯»å†™é”åˆ†ç¦»

### 6.2 å­¦ä¹ å»ºè®®

1. **ç†è§£åŸç†**ï¼šæ·±å…¥ç†è§£å„ç§çº¿ç¨‹å®‰å…¨æœºåˆ¶çš„å·¥ä½œåŸç†
2. **å®è·µéªŒè¯**ï¼šé€šè¿‡ç¼–å†™ä»£ç éªŒè¯ä¸åŒç­–ç•¥çš„æ•ˆæœ
3. **æ€§èƒ½æµ‹è¯•**ï¼šå¯¹æ¯”ä¸åŒå®ç°æ–¹å¼çš„æ€§èƒ½å·®å¼‚
4. **æŒç»­å­¦ä¹ **ï¼šå…³æ³¨æ–°çš„çº¿ç¨‹å®‰å…¨æŠ€æœ¯å’Œæœ€ä½³å®è·µ

é€šè¿‡æ·±å…¥ç†è§£å’Œç†Ÿç»ƒè¿ç”¨è¿™äº›çº¿ç¨‹å®‰å…¨æŠ€æœ¯ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå‡ºæ›´åŠ é«˜æ•ˆã€å¥å£®å’Œå¯ç»´æŠ¤çš„Javaå¹¶å‘åº”ç”¨ç¨‹åºã€‚ 