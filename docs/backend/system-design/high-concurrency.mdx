---
sidebar_position: 1
title: "高并发系统设计"
description: "深入理解高并发系统设计原理、架构模式与性能优化策略"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# 高并发系统设计

高并发系统设计是构建高性能、高可用系统的核心技术。通过合理的架构设计、缓存策略、异步处理和数据库优化，可以构建出能够处理大量并发请求的系统。

:::tip 核心价值
高并发 = 并发模型 + 缓存优化 + 异步处理 + 数据库优化 + 负载均衡
:::

## 1. 并发模型基础

### 1.1 并发与并行

并发和并行是处理多任务的不同方式：

| 概念 | 说明 | 特点 |
|------|------|------|
| **并发 (Concurrency)** | 多个任务交替执行 | 单核CPU上的多任务处理 |
| **并行 (Parallelism)** | 多个任务同时执行 | 多核CPU上的多任务处理 |

```java title="并发与并行示例"
// 并发处理 - 单线程异步
@RestController
public class ConcurrentController {
    
    @Autowired
    private AsyncTaskExecutor taskExecutor;
    
    @GetMapping("/concurrent")
    public CompletableFuture<String> handleConcurrent() {
        return CompletableFuture.supplyAsync(() -> {
            // 模拟耗时操作
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "并发处理完成";
        }, taskExecutor);
    }
}

// 并行处理 - 多线程
@Service
public class ParallelService {
    
    @Autowired
    private ThreadPoolTaskExecutor executor;
    
    public List<String> processParallel(List<String> items) {
        return items.parallelStream()
            .map(item -> {
                // 并行处理每个项目
                return processItem(item);
            })
            .collect(Collectors.toList());
    }
    
    private String processItem(String item) {
        // 处理单个项目的逻辑
        return "processed_" + item;
    }
}
```

### 1.2 线程模型

#### 线程池设计

```java title="线程池配置"
@Configuration
public class ThreadPoolConfig {
    
    @Bean("ioThreadPool")
    public ThreadPoolTaskExecutor ioThreadPool() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("IO-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Bean("cpuThreadPool")
    public ThreadPoolTaskExecutor cpuThreadPool() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 2);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("CPU-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        executor.initialize();
        return executor;
    }
}

// 线程池使用
@Service
public class ThreadPoolService {
    
    @Autowired
    @Qualifier("ioThreadPool")
    private ThreadPoolTaskExecutor ioExecutor;
    
    @Autowired
    @Qualifier("cpuThreadPool")
    private ThreadPoolTaskExecutor cpuExecutor;
    
    public CompletableFuture<String> handleIOBoundTask() {
        return CompletableFuture.supplyAsync(() -> {
            // IO密集型任务
            return performIOOperation();
        }, ioExecutor);
    }
    
    public CompletableFuture<String> handleCPUBoundTask() {
        return CompletableFuture.supplyAsync(() -> {
            // CPU密集型任务
            return performCPUOperation();
        }, cpuExecutor);
    }
}
```

#### 异步编程模型

```java title="异步编程示例"
@Service
public class AsyncService {
    
    @Async("ioThreadPool")
    public CompletableFuture<String> asyncOperation1() {
        // 异步操作1
        return CompletableFuture.completedFuture("操作1完成");
    }
    
    @Async("ioThreadPool")
    public CompletableFuture<String> asyncOperation2() {
        // 异步操作2
        return CompletableFuture.completedFuture("操作2完成");
    }
    
    public CompletableFuture<String> combinedOperation() {
        CompletableFuture<String> future1 = asyncOperation1();
        CompletableFuture<String> future2 = asyncOperation2();
        
        return CompletableFuture.allOf(future1, future2)
            .thenApply(v -> {
                String result1 = future1.join();
                String result2 = future2.join();
                return result1 + " + " + result2;
            });
    }
}
```

## 2. 缓存优化策略

### 2.1 多级缓存架构

```java title="多级缓存实现"
@Service
public class MultiLevelCacheService {
    
    // L1缓存：本地缓存
    private LoadingCache<String, Object> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(Duration.ofMinutes(5))
        .build(key -> getFromL2Cache(key));
    
    // L2缓存：Redis缓存
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // L3缓存：数据库
    @Autowired
    private UserRepository userRepository;
    
    public Object getData(String key) {
        try {
            // 从L1缓存获取
            return localCache.get(key);
        } catch (Exception e) {
            log.error("L1缓存获取失败", e);
            // 降级到L2缓存
            return getFromL2Cache(key);
        }
    }
    
    private Object getFromL2Cache(String key) {
        try {
            Object value = redisTemplate.opsForValue().get(key);
            if (value == null) {
                // L2缓存未命中，从L3获取
                value = getFromL3Cache(key);
                if (value != null) {
                    // 写入L2缓存
                    redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(30));
                }
            }
            return value;
        } catch (Exception e) {
            log.error("L2缓存获取失败", e);
            // 降级到L3缓存
            return getFromL3Cache(key);
        }
    }
    
    private Object getFromL3Cache(String key) {
        // 从数据库获取数据
        if (key.startsWith("user:")) {
            Long userId = Long.parseLong(key.substring(5));
            return userRepository.findById(userId).orElse(null);
        }
        return null;
    }
}
```

### 2.2 缓存更新策略

```java title="缓存更新策略"
@Service
public class CacheUpdateService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private LoadingCache<String, Object> localCache;
    
    // 写穿策略：先更新数据库，再更新缓存
    @Transactional
    public void writeThrough(String key, Object value) {
        // 1. 更新数据库
        updateDatabase(key, value);
        
        // 2. 更新缓存
        redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(30));
        localCache.invalidate(key);
    }
    
    // 写回策略：先更新缓存，异步更新数据库
    public void writeBack(String key, Object value) {
        // 1. 更新缓存
        redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(30));
        localCache.invalidate(key);
        
        // 2. 异步更新数据库
        CompletableFuture.runAsync(() -> {
            updateDatabase(key, value);
        });
    }
    
    // 失效策略：先更新数据库，再删除缓存
    @Transactional
    public void writeInvalidate(String key, Object value) {
        // 1. 更新数据库
        updateDatabase(key, value);
        
        // 2. 删除缓存
        redisTemplate.delete(key);
        localCache.invalidate(key);
    }
    
    private void updateDatabase(String key, Object value) {
        // 数据库更新逻辑
    }
}
```

### 2.3 缓存穿透防护

```java title="缓存穿透防护"
@Service
public class CachePenetrationProtection {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private BloomFilter bloomFilter;
    
    public Object getDataWithProtection(String key) {
        // 1. 布隆过滤器检查
        if (!bloomFilter.mightContain(key)) {
            return null;
        }
        
        // 2. 从缓存获取
        Object value = redisTemplate.opsForValue().get(key);
        if (value != null) {
            return value;
        }
        
        // 3. 缓存未命中，从数据库获取
        value = getFromDatabase(key);
        if (value != null) {
            // 写入缓存
            redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(30));
        } else {
            // 空值缓存，防止缓存穿透
            redisTemplate.opsForValue().set(key, "NULL", Duration.ofMinutes(5));
        }
        
        return value;
    }
}

// 布隆过滤器实现
@Component
public class BloomFilter {
    
    private BitSet bitSet;
    private int size;
    private int hashFunctions;
    
    public BloomFilter(int size, int hashFunctions) {
        this.bitSet = new BitSet(size);
        this.size = size;
        this.hashFunctions = hashFunctions;
    }
    
    public void add(String key) {
        for (int i = 0; i < hashFunctions; i++) {
            int hash = hash(key, i);
            bitSet.set(hash % size);
        }
    }
    
    public boolean mightContain(String key) {
        for (int i = 0; i < hashFunctions; i++) {
            int hash = hash(key, i);
            if (!bitSet.get(hash % size)) {
                return false;
            }
        }
        return true;
    }
    
    private int hash(String key, int seed) {
        int result = 0;
        for (int i = 0; i < key.length(); i++) {
            result = 31 * result + key.charAt(i) + seed;
        }
        return Math.abs(result);
    }
}
```

## 3. 异步处理机制

### 3.1 消息队列

```java title="消息队列使用"
@Service
public class MessageQueueService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    // 发送消息到RabbitMQ
    public void sendToRabbitMQ(String message) {
        rabbitTemplate.convertAndSend("exchange", "routing.key", message);
    }
    
    // 发送消息到Kafka
    public void sendToKafka(String topic, String message) {
        kafkaTemplate.send(topic, message);
    }
    
    // 异步处理订单
    public void processOrderAsync(Order order) {
        // 1. 创建订单
        Order savedOrder = orderRepository.save(order);
        
        // 2. 发送异步消息
        OrderEvent event = new OrderEvent(savedOrder.getId(), "CREATED");
        rabbitTemplate.convertAndSend("order.exchange", "order.created", event);
        
        // 3. 立即返回订单ID
        return savedOrder.getId();
    }
}

// 消息消费者
@Component
public class OrderMessageConsumer {
    
    @RabbitListener(queues = "order.queue")
    public void handleOrderCreated(OrderEvent event) {
        // 异步处理订单创建后的业务逻辑
        switch (event.getType()) {
            case "CREATED":
                processOrderCreated(event.getOrderId());
                break;
            case "PAID":
                processOrderPaid(event.getOrderId());
                break;
            case "SHIPPED":
                processOrderShipped(event.getOrderId());
                break;
        }
    }
    
    private void processOrderCreated(Long orderId) {
        // 处理订单创建逻辑
        // 1. 发送确认邮件
        // 2. 更新库存
        // 3. 生成物流单
    }
}
```

### 3.2 异步调用

```java title="异步调用示例"
@Service
public class AsyncCallService {
    
    @Autowired
    private ThreadPoolTaskExecutor executor;
    
    // 异步调用外部服务
    public CompletableFuture<ApiResponse> callExternalServiceAsync(String url) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 调用外部API
                RestTemplate restTemplate = new RestTemplate();
                return restTemplate.getForObject(url, ApiResponse.class);
            } catch (Exception e) {
                log.error("外部服务调用失败", e);
                return new ApiResponse("ERROR", e.getMessage());
            }
        }, executor);
    }
    
    // 批量异步处理
    public List<ApiResponse> batchProcessAsync(List<String> urls) {
        List<CompletableFuture<ApiResponse>> futures = urls.stream()
            .map(this::callExternalServiceAsync)
            .collect(Collectors.toList());
        
        return futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
    }
    
    // 超时控制
    public ApiResponse callWithTimeout(String url, long timeout) {
        try {
            return callExternalServiceAsync(url)
                .get(timeout, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            log.error("调用超时", e);
            return new ApiResponse("TIMEOUT", "请求超时");
        } catch (Exception e) {
            log.error("调用失败", e);
            return new ApiResponse("ERROR", e.getMessage());
        }
    }
}
```

## 4. 数据库优化

### 4.1 读写分离

```java title="读写分离配置"
@Configuration
public class DataSourceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public DataSource routingDataSource() {
        RoutingDataSource routingDataSource = new RoutingDataSource();
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("master", masterDataSource());
        targetDataSources.put("slave", slaveDataSource());
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(masterDataSource());
        return routingDataSource;
    }
}

// 数据源路由
public class RoutingDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}

// 数据源上下文
public class DataSourceContextHolder {
    
    private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();
    
    public static void setDataSourceType(String dataSourceType) {
        contextHolder.set(dataSourceType);
    }
    
    public static String getDataSourceType() {
        return contextHolder.get();
    }
    
    public static void clearDataSourceType() {
        contextHolder.remove();
    }
}

// AOP切面
@Aspect
@Component
public class DataSourceAspect {
    
    @Around("@annotation(readOnly)")
    public Object around(ProceedingJoinPoint point, ReadOnly readOnly) throws Throwable {
        DataSourceContextHolder.setDataSourceType("slave");
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clearDataSourceType();
        }
    }
}

// 只读注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ReadOnly {
}
```

### 4.2 分库分表

```java title="分库分表实现"
@Component
public class ShardingStrategy {
    
    private List<DataSource> dataSources = Arrays.asList(
        dataSource1, dataSource2, dataSource3, dataSource4
    );
    
    // 根据用户ID分库
    public DataSource getDataSourceByUserId(Long userId) {
        int dbIndex = (int) (userId % dataSources.size());
        return dataSources.get(dbIndex);
    }
    
    // 根据用户ID分表
    public String getTableNameByUserId(String baseTableName, Long userId) {
        int tableIndex = (int) (userId % 10);
        return baseTableName + "_" + tableIndex;
    }
    
    // 一致性哈希分片
    public DataSource getDataSourceByHash(String key) {
        int hash = Math.abs(key.hashCode());
        int index = hash % dataSources.size();
        return dataSources.get(index);
    }
}

// 分库分表服务
@Service
public class ShardingService {
    
    @Autowired
    private ShardingStrategy shardingStrategy;
    
    public User getUserById(Long userId) {
        DataSource dataSource = shardingStrategy.getDataSourceByUserId(userId);
        String tableName = shardingStrategy.getTableNameByUserId("users", userId);
        
        // 使用指定的数据源和表名查询
        return queryUserFromDataSource(dataSource, tableName, userId);
    }
    
    private User queryUserFromDataSource(DataSource dataSource, String tableName, Long userId) {
        // 实现具体的查询逻辑
        return null;
    }
}
```

## 5. 负载均衡

### 5.1 负载均衡算法

```java title="负载均衡实现"
@Component
public class LoadBalancer {
    
    private List<String> servers = Arrays.asList(
        "server1:8080", "server2:8080", "server3:8080", "server4:8080"
    );
    
    private AtomicInteger currentIndex = new AtomicInteger(0);
    private Map<String, Integer> serverWeights = new HashMap<>();
    private Map<String, Integer> connectionCounts = new ConcurrentHashMap<>();
    
    // 轮询算法
    public String getServerByRoundRobin() {
        int index = currentIndex.getAndIncrement() % servers.size();
        return servers.get(index);
    }
    
    // 权重轮询算法
    public String getServerByWeight() {
        int totalWeight = serverWeights.values().stream().mapToInt(Integer::intValue).sum();
        int random = new Random().nextInt(totalWeight);
        
        int currentWeight = 0;
        for (String server : servers) {
            currentWeight += serverWeights.getOrDefault(server, 1);
            if (random < currentWeight) {
                return server;
            }
        }
        return servers.get(0);
    }
    
    // 最少连接算法
    public String getServerByLeastConnections() {
        return connectionCounts.entrySet().stream()
            .min(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(servers.get(0));
    }
    
    // 一致性哈希算法
    public String getServerByConsistentHash(String key) {
        TreeMap<Integer, String> ring = new TreeMap<>();
        for (String server : servers) {
            for (int i = 0; i < 150; i++) { // 虚拟节点
                String virtualNode = server + "&VN" + i;
                int hash = hash(virtualNode);
                ring.put(hash, server);
            }
        }
        
        int hash = hash(key);
        Map.Entry<Integer, String> entry = ring.ceilingEntry(hash);
        if (entry == null) {
            entry = ring.firstEntry();
        }
        return entry.getValue();
    }
    
    private int hash(String key) {
        return Math.abs(key.hashCode());
    }
}
```

## 6. 面试题精选

### 6.1 基础概念题

**Q: 什么是高并发？如何设计高并发系统？**

A: 高并发是指系统能够同时处理大量并发请求的能力。设计高并发系统的方法：
- **架构层面**：采用分布式架构、微服务架构
- **缓存层面**：多级缓存、缓存预热、缓存更新策略
- **异步处理**：消息队列、异步调用、事件驱动
- **数据库优化**：读写分离、分库分表、索引优化
- **负载均衡**：应用层负载均衡、数据库负载均衡

**Q: 如何解决缓存穿透问题？**

A: 解决缓存穿透的方法：
- **布隆过滤器**：快速判断key是否存在
- **空值缓存**：将空结果也缓存，设置较短的过期时间
- **参数校验**：对请求参数进行严格校验
- **限流保护**：对异常请求进行限流

### 6.2 架构设计题

**Q: 如何设计一个秒杀系统？**

A: 秒杀系统设计要点：
- **前端优化**：页面静态化、CDN加速、按钮控制
- **接口优化**：限流、异步处理、缓存预热
- **库存控制**：预扣库存、库存锁定、超时释放
- **订单处理**：异步创建订单、消息队列、数据库优化
- **防刷机制**：用户限购、IP限流、验证码

**Q: 如何设计一个高并发的订单系统？**

A: 订单系统设计要点：
- **订单创建**：异步处理、消息队列、状态机
- **库存管理**：预扣库存、库存锁定、超时释放
- **支付处理**：异步支付、状态同步、幂等性
- **订单查询**：读写分离、缓存优化、分库分表
- **订单状态**：状态机、事件驱动、最终一致性

### 6.3 性能优化题

**Q: 如何优化系统性能？**

A: 系统性能优化方法：
- **缓存优化**：多级缓存、缓存策略、缓存穿透防护
- **数据库优化**：索引优化、查询优化、连接池优化
- **代码优化**：算法优化、内存管理、并发控制
- **架构优化**：异步处理、微服务、事件驱动
- **基础设施**：CDN、负载均衡、容器化部署

**Q: 如何处理高并发下的数据一致性问题？**

A: 数据一致性处理方法：
- **分布式事务**：2PC、3PC、TCC、Saga
- **最终一致性**：消息队列、补偿机制、幂等性
- **乐观锁**：版本号、时间戳、CAS操作
- **悲观锁**：数据库锁、分布式锁、Redis锁

:::tip 高并发学习要点
1. **理解并发模型**：掌握线程模型、异步编程、并发控制
2. **掌握缓存策略**：学会多级缓存、缓存更新、缓存穿透防护
3. **熟悉异步处理**：了解消息队列、异步调用、事件驱动
4. **学会数据库优化**：掌握读写分离、分库分表、索引优化
5. **了解负载均衡**：学会负载均衡算法、健康检查、故障转移
:::

---

通过本章的学习，你应该已经掌握了高并发系统设计的核心概念、架构模式和优化策略。高并发系统设计是构建高性能、高可用系统的重要技能，掌握这些技术可以帮助你设计出能够处理大量并发请求的系统。在实际项目中，合理运用这些技术可以大大提高系统的并发处理能力和用户体验。 