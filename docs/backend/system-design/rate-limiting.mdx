---
sidebar_position: 4
title: "é™æµç³»ç»Ÿè®¾è®¡"
description: "æ·±å…¥ç†è§£é™æµç®—æ³•ã€å®ç°ç­–ç•¥ä¸æœ€ä½³å®è·µ"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TOCInline from '@theme/TOCInline';

# é™æµç³»ç»Ÿè®¾è®¡

é™æµç³»ç»Ÿè®¾è®¡æ˜¯ä¿æŠ¤ç³»ç»Ÿå…å—æµé‡å†²å‡»ã€ç¡®ä¿ç³»ç»Ÿç¨³å®šè¿è¡Œçš„é‡è¦æŠ€æœ¯ã€‚é€šè¿‡åˆç†çš„é™æµç®—æ³•å’Œç­–ç•¥ï¼Œå¯ä»¥æœ‰æ•ˆæ§åˆ¶è¯·æ±‚æµé‡ï¼Œé˜²æ­¢ç³»ç»Ÿè¿‡è½½ã€‚

:::info æœ¬æ–‡å†…å®¹æ¦‚è§ˆ
<TOCInline toc={toc} />
:::

:::tip æ ¸å¿ƒä»·å€¼
**é™æµ = æµé‡æ§åˆ¶ + ç³»ç»Ÿä¿æŠ¤ + èµ„æºç®¡ç† + ç”¨æˆ·ä½“éªŒ + æˆæœ¬æ§åˆ¶**
- ğŸš¦ **æµé‡æ§åˆ¶**ï¼šè°ƒèŠ‚è¯·æ±‚æµé‡ï¼Œé¿å…ç³»ç»Ÿè¿‡è½½
- ğŸ›¡ï¸ **ç³»ç»Ÿä¿æŠ¤**ï¼šé˜²æ­¢ç³»ç»Ÿå´©æºƒï¼Œä¿è¯ç³»ç»Ÿç¨³å®šæ€§
- ğŸ“Š **èµ„æºç®¡ç†**ï¼šåˆç†åˆ†é…ç³»ç»Ÿèµ„æºï¼Œæé«˜èµ„æºåˆ©ç”¨ç‡
- ğŸ‘¤ **ç”¨æˆ·ä½“éªŒ**ï¼šä¿è¯æ ¸å¿ƒåŠŸèƒ½å¯ç”¨ï¼Œæå‡ç”¨æˆ·æ»¡æ„åº¦
- ğŸ’° **æˆæœ¬æ§åˆ¶**ï¼šé™ä½èµ„æºæˆæœ¬ï¼Œæé«˜ç³»ç»Ÿç»æµæ€§
:::

## 1. é™æµåŸºç¡€æ¦‚å¿µ

### 1.1 é™æµç›®çš„

```mermaid
mindmap
  root((é™æµç›®çš„))
    ä¿æŠ¤ç³»ç»Ÿ
      é˜²æ­¢è¿‡è½½
      èµ„æºè€—å°½ä¿æŠ¤
      å´©æºƒé¢„é˜²
    èµ„æºç®¡ç†
      åˆç†åˆ†é…
      ä¼˜å…ˆçº§å¤„ç†
      å…³é”®èµ„æºä¿æŠ¤
    æˆæœ¬æ§åˆ¶
      APIè°ƒç”¨æˆæœ¬
      è®¡ç®—èµ„æºæˆæœ¬
      å­˜å‚¨èµ„æºæˆæœ¬
    ç”¨æˆ·ä½“éªŒ
      ä¿è¯æ ¸å¿ƒåŠŸèƒ½
      é™çº§éæ ¸å¿ƒåŠŸèƒ½
      å“åº”æ—¶é—´ä¿éšœ
    å®‰å…¨é˜²æŠ¤
      é˜²æ­¢DDoSæ”»å‡»
      æ¶æ„è¯·æ±‚æ‹¦æˆª
      å¼‚å¸¸æµé‡æ£€æµ‹
```

é™æµç³»ç»Ÿçš„ä¸»è¦ç›®çš„ï¼š

| ç›®çš„ | è¯´æ˜ | å®ç°æ–¹å¼ |
|------|------|----------|
| **ä¿æŠ¤ç³»ç»Ÿ** | é˜²æ­¢ç³»ç»Ÿè¿‡è½½å´©æºƒ | é™åˆ¶è¯·æ±‚æ•°é‡ |
| **èµ„æºç®¡ç†** | åˆç†åˆ†é…ç³»ç»Ÿèµ„æº | æŒ‰ä¼˜å…ˆçº§åˆ†é… |
| **æˆæœ¬æ§åˆ¶** | æ§åˆ¶APIè°ƒç”¨æˆæœ¬ | é™åˆ¶è°ƒç”¨é¢‘ç‡ |
| **ç”¨æˆ·ä½“éªŒ** | ä¿è¯æ ¸å¿ƒåŠŸèƒ½å¯ç”¨ | é™çº§éæ ¸å¿ƒåŠŸèƒ½ |
| **å®‰å…¨é˜²æŠ¤** | é˜²æ­¢æ¶æ„æ”»å‡» | å¼‚å¸¸æµé‡æ£€æµ‹ |

<Tabs>
  <TabItem value="config" label="é™æµé…ç½®" default>
  ```java
  @Configuration
  public class RateLimitConfig {
      
      @Value("${rate.limit.enabled:true}")
      private boolean rateLimitEnabled;
      
      @Value("${rate.limit.default.qps:100}")
      private int defaultQps;
      
      @Value("${rate.limit.default.burst:200}")
      private int defaultBurst;
      
      @Bean
      public RateLimiter rateLimiter() {
          return RateLimiter.create(defaultQps);
      }
      
      @Bean
      public RateLimitProperties rateLimitProperties() {
          RateLimitProperties properties = new RateLimitProperties();
          properties.setEnabled(rateLimitEnabled);
          properties.setDefaultQps(defaultQps);
          properties.setDefaultBurst(defaultBurst);
          return properties;
      }
  }
  ```
  </TabItem>
  <TabItem value="properties" label="å±æ€§é…ç½®">
  ```java
  @Component
  public class RateLimitProperties {
      private boolean enabled;
      private int defaultQps;
      private int defaultBurst;
      private Map<String, Integer> userLimits = new HashMap<>();
      private Map<String, Integer> apiLimits = new HashMap<>();
      
      // getterå’Œsetteræ–¹æ³•
  }
  ```
  </TabItem>
</Tabs>

### 1.2 é™æµç»´åº¦

<div className="card">
<div className="card__body">

é™æµå¯ä»¥ä»ä¸åŒç»´åº¦è¿›è¡Œï¼š

1. **å…¨å±€é™æµ**ï¼šå¯¹æ•´ä¸ªç³»ç»Ÿè¿›è¡Œæ€»ä½“æµé‡æ§åˆ¶
2. **ç”¨æˆ·é™æµ**ï¼šå¯¹å•ä¸ªç”¨æˆ·çš„è¯·æ±‚é¢‘ç‡è¿›è¡Œé™åˆ¶
3. **IPé™æµ**ï¼šå¯¹æ¥è‡ªç‰¹å®šIPåœ°å€çš„è¯·æ±‚è¿›è¡Œé™åˆ¶
4. **APIé™æµ**ï¼šå¯¹ç‰¹å®šAPIæ¥å£çš„è°ƒç”¨é¢‘ç‡è¿›è¡Œé™åˆ¶
5. **æ¥å£é™æµ**ï¼šå¯¹ç‰¹å®šæ¥å£æ–¹æ³•çš„è°ƒç”¨é¢‘ç‡è¿›è¡Œé™åˆ¶
6. **èµ„æºé™æµ**ï¼šå¯¹ç‰¹å®šèµ„æºçš„è®¿é—®é¢‘ç‡è¿›è¡Œé™åˆ¶

</div>
</div>

```mermaid
graph TD
    A[é™æµç»´åº¦] --> B[å…¨å±€é™æµ]
    A --> C[ç”¨æˆ·é™æµ]
    A --> D[IPé™æµ]
    A --> E[APIé™æµ]
    A --> F[æ¥å£é™æµ]
    A --> G[èµ„æºé™æµ]
    
    B --> B1[ç³»ç»Ÿæ•´ä½“QPS]
    C --> C1[å•ç”¨æˆ·è¯·æ±‚é¢‘ç‡]
    D --> D1[å•IPè¯·æ±‚é¢‘ç‡]
    E --> E1[å•APIè¯·æ±‚é¢‘ç‡]
    F --> F1[å•æ–¹æ³•è°ƒç”¨é¢‘ç‡]
    G --> G1[å•èµ„æºè®¿é—®é¢‘ç‡]
```

<Tabs>
  <TabItem value="enum" label="ç»´åº¦å®šä¹‰" default>
  ```java
  public enum RateLimitDimension {
      // å…¨å±€é™æµ
      GLOBAL("å…¨å±€é™æµ", "å¯¹æ•´ä¸ªç³»ç»Ÿè¿›è¡Œé™æµ"),
      
      // ç”¨æˆ·é™æµ
      USER("ç”¨æˆ·é™æµ", "å¯¹å•ä¸ªç”¨æˆ·è¿›è¡Œé™æµ"),
      
      // IPé™æµ
      IP("IPé™æµ", "å¯¹å•ä¸ªIPåœ°å€è¿›è¡Œé™æµ"),
      
      // APIé™æµ
      API("APIé™æµ", "å¯¹ç‰¹å®šAPIæ¥å£è¿›è¡Œé™æµ"),
      
      // æ¥å£é™æµ
      INTERFACE("æ¥å£é™æµ", "å¯¹ç‰¹å®šæ¥å£æ–¹æ³•è¿›è¡Œé™æµ"),
      
      // èµ„æºé™æµ
      RESOURCE("èµ„æºé™æµ", "å¯¹ç‰¹å®šèµ„æºè¿›è¡Œé™æµ");
      
      private final String name;
      private final String description;
      
      RateLimitDimension(String name, String description) {
          this.name = name;
          this.description = description;
      }
  }
  ```
  </TabItem>
  <TabItem value="manager" label="é™æµç®¡ç†å™¨">
  ```java
  @Component
  public class RateLimitManager {
      
      private final Map<RateLimitDimension, RateLimiter> limiters = new ConcurrentHashMap<>();
      
      public boolean isAllowed(RateLimitDimension dimension, String key) {
          RateLimiter limiter = getOrCreateLimiter(dimension, key);
          return limiter.tryAcquire();
      }
      
      private RateLimiter getOrCreateLimiter(RateLimitDimension dimension, String key) {
          String limiterKey = dimension.name() + ":" + key;
          return limiters.computeIfAbsent(dimension, k -> RateLimiter.create(100.0));
      }
  }
  ```
  </TabItem>
</Tabs>

## 2. é™æµç®—æ³•

:::info
é™æµç®—æ³•æ˜¯é™æµç³»ç»Ÿçš„æ ¸å¿ƒï¼Œä¸åŒç®—æ³•æœ‰ä¸åŒçš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯ã€‚å¸¸è§çš„é™æµç®—æ³•åŒ…æ‹¬å›ºå®šçª—å£ã€æ»‘åŠ¨çª—å£ã€ä»¤ç‰Œæ¡¶å’Œæ¼æ¡¶ç®—æ³•ã€‚
:::

<div className="card">
<div className="card__header">
<h4>é™æµç®—æ³•å¯¹æ¯”</h4>
</div>
<div className="card__body">

| ç®—æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|-----|-----|-----|---------|
| **å›ºå®šçª—å£** | ç®€å•æ˜“å®ç°ã€å†…å­˜æ¶ˆè€—å°‘ | è¾¹ç•Œçªå‘æµé‡é—®é¢˜ | ç®€å•åœºæ™¯ã€ä½ç²¾åº¦è¦æ±‚ |
| **æ»‘åŠ¨çª—å£** | å¹³æ»‘é™æµæ•ˆæœã€é¿å…è¾¹ç•Œé—®é¢˜ | å®ç°å¤æ‚ã€å†…å­˜æ¶ˆè€—å¤§ | éœ€è¦ç²¾ç¡®é™æµçš„åœºæ™¯ |
| **ä»¤ç‰Œæ¡¶** | å…è®¸çªå‘æµé‡ã€çµæ´»é…ç½® | å®ç°è¾ƒå¤æ‚ | å…è®¸çªå‘æµé‡çš„åœºæ™¯ |
| **æ¼æ¡¶** | å›ºå®šé€Ÿç‡å¤„ç†ã€æµé‡æ•´å½¢ | æ— æ³•åº”å¯¹çªå‘æµé‡ | éœ€è¦å›ºå®šå¤„ç†é€Ÿç‡çš„åœºæ™¯ |

</div>
</div>

### 2.1 å›ºå®šçª—å£ç®—æ³•

å›ºå®šçª—å£ç®—æ³•å°†æ—¶é—´åˆ†ä¸ºå›ºå®šé•¿åº¦çš„çª—å£ï¼Œåœ¨æ¯ä¸ªçª—å£å†…é™åˆ¶è¯·æ±‚æ•°é‡ã€‚

```mermaid
graph LR
    A[è¯·æ±‚] --> B{å½“å‰çª—å£è¯·æ±‚æ•°<é˜ˆå€¼?}
    B -- æ˜¯ --> C[å…è®¸è¯·æ±‚]
    B -- å¦ --> D[æ‹’ç»è¯·æ±‚]
    
    subgraph æ—¶é—´è½´
    E[çª—å£1] --> F[çª—å£2] --> G[çª—å£3]
    end
```

<Tabs>
  <TabItem value="fixed" label="å›ºå®šçª—å£å®ç°" default>
  ```java
  @Component
  public class FixedWindowRateLimiter {
      
      private final Map<String, WindowInfo> windows = new ConcurrentHashMap<>();
      private final int limit;
      private final long windowSize;
      
      public FixedWindowRateLimiter(int limit, long windowSize) {
          this.limit = limit;
          this.windowSize = windowSize;
      }
      
      public boolean isAllowed(String key) {
          long currentTime = System.currentTimeMillis();
          long windowStart = currentTime - (currentTime % windowSize);
          
          WindowInfo window = windows.compute(key, (k, v) -> {
              if (v == null || v.getWindowStart() != windowStart) {
                  return new WindowInfo(windowStart, 1);
              } else {
                  v.incrementCount();
                  return v;
              }
          });
          
          return window.getCount() <= limit;
      }
      
      public void reset(String key) {
          windows.remove(key);
      }
  }
  ```
  </TabItem>
  <TabItem value="window" label="çª—å£ä¿¡æ¯ç±»">
  ```java
  class WindowInfo {
      private final long windowStart;
      private final AtomicInteger count;
      
      public WindowInfo(long windowStart, int initialCount) {
          this.windowStart = windowStart;
          this.count = new AtomicInteger(initialCount);
      }
      
      public long getWindowStart() { return windowStart; }
      public int getCount() { return count.get(); }
      public void incrementCount() { count.incrementAndGet(); }
  }
  ```
  </TabItem>
</Tabs>

:::caution å›ºå®šçª—å£ç®—æ³•çš„å±€é™æ€§
å›ºå®šçª—å£ç®—æ³•åœ¨çª—å£è¾¹ç•Œå¯èƒ½å¯¼è‡´çªå‘æµé‡é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªçª—å£çš„æœ«å°¾å’Œä¸‹ä¸€ä¸ªçª—å£çš„å¼€å¤´ï¼Œå¯èƒ½åœ¨çŸ­æ—¶é—´å†…é€šè¿‡ä¸¤å€äºé˜ˆå€¼çš„è¯·æ±‚ã€‚
:::

### 2.2 æ»‘åŠ¨çª—å£ç®—æ³•

æ»‘åŠ¨çª—å£ç®—æ³•é€šè¿‡å°†æ—¶é—´çª—å£åˆ†ä¸ºå¤šä¸ªå°å—ï¼Œå¹¶éšç€æ—¶é—´æ¨ç§»æ»‘åŠ¨ï¼Œæä¾›æ›´å¹³æ»‘çš„é™æµæ•ˆæœã€‚

```mermaid
graph TD
    A[è¯·æ±‚] --> B[è®¡ç®—å½“å‰çª—å£è¯·æ±‚æ€»æ•°]
    B --> C{æ€»æ•°<é˜ˆå€¼?}
    C -- æ˜¯ --> D[å…è®¸è¯·æ±‚]
    C -- å¦ --> E[æ‹’ç»è¯·æ±‚]
    
    subgraph æ»‘åŠ¨çª—å£
    F[æ¡¶1] --- G[æ¡¶2] --- H[æ¡¶3] --- I[æ¡¶4]
    end
```

<details>
<summary>æ»‘åŠ¨çª—å£å·¥ä½œåŸç†</summary>

1. **çª—å£åˆ†å‰²**ï¼šå°†æ—¶é—´çª—å£åˆ†ä¸ºå¤šä¸ªå°æ¡¶
2. **è¯·æ±‚è®¡æ•°**ï¼šæ¯ä¸ªè¯·æ±‚è½å…¥å¯¹åº”çš„æ—¶é—´æ¡¶
3. **çª—å£æ»‘åŠ¨**ï¼šéšç€æ—¶é—´æ¨ç§»ï¼Œæ—§æ¡¶æ·˜æ±°ï¼Œæ–°æ¡¶åŠ å…¥
4. **æµé‡æ§åˆ¶**ï¼šæ ¹æ®æ‰€æœ‰æ¡¶çš„è¯·æ±‚æ€»æ•°å†³å®šæ˜¯å¦å…è®¸è¯·æ±‚

ä¼˜ç‚¹ï¼š
- å¹³æ»‘å¤„ç†è¯·æ±‚ï¼Œé¿å…è¾¹ç•Œçªå‘é—®é¢˜
- æä¾›æ›´ç²¾ç¡®çš„æµé‡æ§åˆ¶
- é€‚åº”æ€§å¼ºï¼Œå¯æ ¹æ®éœ€æ±‚è°ƒæ•´æ¡¶çš„æ•°é‡å’Œå¤§å°

</details>

<Tabs>
  <TabItem value="sliding" label="æ»‘åŠ¨çª—å£å®ç°" default>
  ```java
  @Component
  public class SlidingWindowRateLimiter {
      
      private final Map<String, SlidingWindow> windows = new ConcurrentHashMap<>();
      private final int limit;
      private final long windowSize;
      private final int bucketCount;
      
      public SlidingWindowRateLimiter(int limit, long windowSize, int bucketCount) {
          this.limit = limit;
          this.windowSize = windowSize;
          this.bucketCount = bucketCount;
      }
      
      public boolean isAllowed(String key) {
          long currentTime = System.currentTimeMillis();
          SlidingWindow window = windows.computeIfAbsent(key, k -> 
              new SlidingWindow(windowSize, bucketCount));
          
          return window.isAllowed(currentTime, limit);
      }
      
      public void reset(String key) {
          windows.remove(key);
      }
  }
  ```
  </TabItem>
  <TabItem value="window-class" label="æ»‘åŠ¨çª—å£ç±»">
  ```java
  class SlidingWindow {
      private final long windowSize;
      private final int bucketCount;
      private final long bucketSize;
      private final AtomicLong[] buckets;
      private final AtomicLong lastUpdateTime;
      
      public SlidingWindow(long windowSize, int bucketCount) {
          this.windowSize = windowSize;
          this.bucketCount = bucketCount;
          this.bucketSize = windowSize / bucketCount;
          this.buckets = new AtomicLong[bucketCount];
          this.lastUpdateTime = new AtomicLong(System.currentTimeMillis());
          
          for (int i = 0; i < bucketCount; i++) {
              buckets[i] = new AtomicLong(0);
          }
      }
      
      public boolean isAllowed(long currentTime, int limit) {
          updateBuckets(currentTime);
          
          long totalCount = 0;
          for (AtomicLong bucket : buckets) {
              totalCount += bucket.get();
          }
          
          if (totalCount < limit) {
              int bucketIndex = (int) ((currentTime / bucketSize) % bucketCount);
              buckets[bucketIndex].incrementAndGet();
              return true;
          }
          
          return false;
      }
      
      private void updateBuckets(long currentTime) {
          long lastTime = lastUpdateTime.get();
          if (currentTime - lastTime >= bucketSize) {
              long bucketIndex = (currentTime / bucketSize) % bucketCount;
              long lastBucketIndex = (lastTime / bucketSize) % bucketCount;
              
              // æ¸…ç©ºè¿‡æœŸçš„æ¡¶
              for (long i = (lastBucketIndex + 1) % bucketCount; i != bucketIndex; 
                   i = (i + 1) % bucketCount) {
                  buckets[(int) i].set(0);
              }
              
              lastUpdateTime.set(currentTime);
          }
      }
  }
  ```
  </TabItem>
</Tabs>

### 2.3 ä»¤ç‰Œæ¡¶ç®—æ³•

ä»¤ç‰Œæ¡¶ç®—æ³•é€šè¿‡ä»¥å›ºå®šé€Ÿç‡å‘æ¡¶ä¸­æ·»åŠ ä»¤ç‰Œï¼Œè¯·æ±‚åˆ°è¾¾æ—¶éœ€è¦è·å–ä»¤ç‰Œæ‰èƒ½è¢«å¤„ç†ã€‚

```mermaid
graph TD
    A[è¯·æ±‚] --> B{æ¡¶ä¸­æœ‰è¶³å¤Ÿä»¤ç‰Œ?}
    B -- æ˜¯ --> C[è·å–ä»¤ç‰Œ]
    B -- å¦ --> D[æ‹’ç»è¯·æ±‚]
    C --> E[å¤„ç†è¯·æ±‚]
    F[å›ºå®šé€Ÿç‡äº§ç”Ÿä»¤ç‰Œ] --> G[ä»¤ç‰Œæ¡¶]
    G --> B
```

<Tabs>
  <TabItem value="token" label="ä»¤ç‰Œæ¡¶å®ç°" default>
  ```java
  @Component
  public class TokenBucketRateLimiter {
      
      private final Map<String, TokenBucket> buckets = new ConcurrentHashMap<>();
      private final double rate;
      private final int capacity;
      
      public TokenBucketRateLimiter(double rate, int capacity) {
          this.rate = rate;
          this.capacity = capacity;
      }
      
      public boolean isAllowed(String key) {
          TokenBucket bucket = buckets.computeIfAbsent(key, k -> new TokenBucket(rate, capacity));
          return bucket.tryConsume(1);
      }
      
      public boolean isAllowed(String key, int tokens) {
          TokenBucket bucket = buckets.computeIfAbsent(key, k -> new TokenBucket(rate, capacity));
          return bucket.tryConsume(tokens);
      }
      
      public void reset(String key) {
          buckets.remove(key);
      }
  }
  ```
  </TabItem>
  <TabItem value="bucket" label="ä»¤ç‰Œæ¡¶ç±»">
  ```java
  class TokenBucket {
      private final double rate;
      private final int capacity;
      private final AtomicInteger tokens;
      private final AtomicLong lastRefillTime;
      
      public TokenBucket(double rate, int capacity) {
          this.rate = rate;
          this.capacity = capacity;
          this.tokens = new AtomicInteger(capacity);
          this.lastRefillTime = new AtomicLong(System.currentTimeMillis());
      }
      
      public boolean tryConsume(int requestedTokens) {
          refill();
          
          while (true) {
              int currentTokens = tokens.get();
              if (currentTokens < requestedTokens) {
                  return false;
              }
              
              if (tokens.compareAndSet(currentTokens, currentTokens - requestedTokens)) {
                  return true;
              }
          }
      }
      
      private void refill() {
          long now = System.currentTimeMillis();
          long lastRefill = lastRefillTime.get();
          long timePassed = now - lastRefill;
          
          if (timePassed > 0) {
              int newTokens = (int) (timePassed * rate / 1000);
              if (newTokens > 0) {
                  while (true) {
                      int currentTokens = tokens.get();
                      int newTotal = Math.min(currentTokens + newTokens, capacity);
                      
                      if (tokens.compareAndSet(currentTokens, newTotal)) {
                          lastRefillTime.addAndGet(timePassed);
                          break;
                      }
                  }
              }
          }
      }
  }
  ```
  </TabItem>
</Tabs>

:::tip ä»¤ç‰Œæ¡¶ç‰¹ç‚¹
ä»¤ç‰Œæ¡¶ç®—æ³•çš„å…³é”®ç‰¹ç‚¹æ˜¯èƒ½å¤Ÿå¤„ç†çªå‘æµé‡ã€‚é€šè¿‡é¢„å…ˆå­˜å‚¨çš„ä»¤ç‰Œï¼Œå¯ä»¥å…è®¸çŸ­æ—¶é—´å†…çš„è¯·æ±‚çªå‘ï¼ŒåŒæ—¶é€šè¿‡å›ºå®šé€Ÿç‡çš„ä»¤ç‰Œäº§ç”Ÿæ¥é™åˆ¶é•¿æœŸçš„è¯·æ±‚é€Ÿç‡ã€‚
:::

### 2.4 æ¼æ¡¶ç®—æ³•

æ¼æ¡¶ç®—æ³•ä»¥å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚ï¼Œå¤šä½™çš„è¯·æ±‚å­˜å‚¨åœ¨æ¡¶ä¸­ï¼Œå¦‚æœæ¡¶æ»¡åˆ™æ‹’ç»æ–°è¯·æ±‚ã€‚

```mermaid
graph TD
    A[è¯·æ±‚] --> B[æ¼æ¡¶]
    B --> C{æ¡¶å·²æ»¡?}
    C -- æ˜¯ --> D[æ‹’ç»è¯·æ±‚]
    C -- å¦ --> E[åŠ å…¥æ¡¶]
    B --> F[å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚]
```

<details>
<summary>æ¼æ¡¶ä¸ä»¤ç‰Œæ¡¶çš„åŒºåˆ«</summary>

**æ¼æ¡¶ç®—æ³•**ï¼š
- è¯·æ±‚ä»¥å›ºå®šé€Ÿç‡å¤„ç†
- ä¸å…è®¸çªå‘æµé‡
- èµ·åˆ°æµé‡æ•´å½¢(Traffic Shaping)ä½œç”¨
- ç¡®ä¿ç³»ç»Ÿä»¥ç¨³å®šçš„é€Ÿç‡å¤„ç†è¯·æ±‚

**ä»¤ç‰Œæ¡¶ç®—æ³•**ï¼š
- å¯ä»¥å¤„ç†çŸ­æ—¶é—´çš„çªå‘æµé‡
- é•¿æœŸå¹³å‡é€Ÿç‡å—ä»¤ç‰Œäº§ç”Ÿé€Ÿç‡é™åˆ¶
- æ›´åŠ çµæ´»ï¼Œå¯ä»¥é€šè¿‡å‚æ•°è°ƒæ•´åº”å¯¹ä¸åŒåœºæ™¯
- é€‚ç”¨äºéœ€è¦å¤„ç†çªå‘æµé‡çš„åœºæ™¯

</details>

<Tabs>
  <TabItem value="leaky" label="æ¼æ¡¶å®ç°" default>
  ```java
  @Component
  public class LeakyBucketRateLimiter {
      
      private final Map<String, LeakyBucket> buckets = new ConcurrentHashMap<>();
      private final double rate;
      private final int capacity;
      
      public LeakyBucketRateLimiter(double rate, int capacity) {
          this.rate = rate;
          this.capacity = capacity;
      }
      
      public boolean isAllowed(String key) {
          LeakyBucket bucket = buckets.computeIfAbsent(key, k -> new LeakyBucket(rate, capacity));
          return bucket.tryConsume();
      }
      
      public void reset(String key) {
          buckets.remove(key);
      }
  }
  ```
  </TabItem>
  <TabItem value="leaky-bucket" label="æ¼æ¡¶ç±»">
  ```java
  class LeakyBucket {
      private final double rate;
      private final int capacity;
      private final AtomicInteger water;
      private final AtomicLong lastLeakTime;
      
      public LeakyBucket(double rate, int capacity) {
          this.rate = rate;
          this.capacity = capacity;
          this.water = new AtomicInteger(0);
          this.lastLeakTime = new AtomicLong(System.currentTimeMillis());
      }
      
      public boolean tryConsume() {
          leak();
          
          while (true) {
              int currentWater = water.get();
              if (currentWater >= capacity) {
                  return false;
              }
              
              if (water.compareAndSet(currentWater, currentWater + 1)) {
                  return true;
              }
          }
      }
      
      private void leak() {
          long now = System.currentTimeMillis();
          long lastLeak = lastLeakTime.get();
          long timePassed = now - lastLeak;
          
          if (timePassed > 0) {
              int leakedWater = (int) (timePassed * rate / 1000);
              if (leakedWater > 0) {
                  while (true) {
                      int currentWater = water.get();
                      int newWater = Math.max(0, currentWater - leakedWater);
                      
                      if (water.compareAndSet(currentWater, newWater)) {
                          lastLeakTime.set(now);
                          break;
                      }
                  }
              }
          }
      }
  }
  ```
  </TabItem>
</Tabs>

## 3. é™æµç­–ç•¥

### 3.1 åˆ†çº§é™æµ

```java title="åˆ†çº§é™æµå®ç°"
@Component
public class TieredRateLimiter {
    
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    private final RateLimitProperties properties;
    
    public TieredRateLimiter(RateLimitProperties properties) {
        this.properties = properties;
    }
    
    public boolean isAllowed(String key, RateLimitTier tier) {
        RateLimiter limiter = getOrCreateLimiter(key, tier);
        return limiter.tryAcquire();
    }
    
    private RateLimiter getOrCreateLimiter(String key, RateLimitTier tier) {
        String limiterKey = key + ":" + tier.name();
        return limiters.computeIfAbsent(limiterKey, k -> {
            double rate = getRateForTier(tier);
            return RateLimiter.create(rate);
        });
    }
    
    private double getRateForTier(RateLimitTier tier) {
        switch (tier) {
            case VIP:
                return 1000.0; // VIPç”¨æˆ·ï¼š1000 QPS
            case PREMIUM:
                return 500.0;  // é«˜çº§ç”¨æˆ·ï¼š500 QPS
            case STANDARD:
                return 100.0;  // æ™®é€šç”¨æˆ·ï¼š100 QPS
            case FREE:
                return 10.0;   // å…è´¹ç”¨æˆ·ï¼š10 QPS
            default:
                return 10.0;
        }
    }
}

enum RateLimitTier {
    VIP,      // VIPç”¨æˆ·
    PREMIUM,  // é«˜çº§ç”¨æˆ·
    STANDARD, // æ™®é€šç”¨æˆ·
    FREE      // å…è´¹ç”¨æˆ·
}
```

### 3.2 åŠ¨æ€é™æµ

```java title="åŠ¨æ€é™æµå®ç°"
@Component
public class DynamicRateLimiter {
    
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    private final AtomicReference<Double> globalRate = new AtomicReference<>(100.0);
    
    @Scheduled(fixedRate = 5000)
    public void updateRateLimits() {
        // æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´é™æµ
        double cpuUsage = getCpuUsage();
        double memoryUsage = getMemoryUsage();
        
        double newRate = calculateNewRate(cpuUsage, memoryUsage);
        globalRate.set(newRate);
        
        // æ›´æ–°æ‰€æœ‰é™æµå™¨
        limiters.values().forEach(limiter -> {
            // æ³¨æ„ï¼šGuavaçš„RateLimiterä¸æ”¯æŒåŠ¨æ€ä¿®æ”¹é€Ÿç‡
            // è¿™é‡Œéœ€è¦é‡æ–°åˆ›å»ºé™æµå™¨
        });
    }
    
    private double calculateNewRate(double cpuUsage, double memoryUsage) {
        double baseRate = 100.0;
        
        // CPUä½¿ç”¨ç‡è¶…è¿‡80%ï¼Œé™ä½é™æµ
        if (cpuUsage > 80) {
            baseRate *= 0.5;
        }
        
        // å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡80%ï¼Œé™ä½é™æµ
        if (memoryUsage > 80) {
            baseRate *= 0.5;
        }
        
        return Math.max(baseRate, 10.0); // æœ€ä½10 QPS
    }
    
    private double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        if (osBean instanceof com.sun.management.OperatingSystemMXBean) {
            return ((com.sun.management.OperatingSystemMXBean) osBean).getCpuLoad() * 100;
        }
        return 0.0;
    }
    
    private double getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        return (double) usedMemory / maxMemory * 100;
    }
}
```

## 4. é™æµå®ç°

### 4.1 æ³¨è§£å¼é™æµ

```java title="é™æµæ³¨è§£å®ç°"
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    String key() default "";           // é™æµé”®
    double qps() default 100.0;        // QPSé™åˆ¶
    int burst() default 200;           // çªå‘æµé‡é™åˆ¶
    RateLimitDimension dimension() default RateLimitDimension.API;
    String fallback() default "";      // é™çº§æ–¹æ³•
}

@Aspect
@Component
public class RateLimitAspect {
    
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    
    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        String key = getRateLimitKey(point, rateLimit);
        RateLimiter limiter = getOrCreateLimiter(key, rateLimit.qps());
        
        if (limiter.tryAcquire()) {
            return point.proceed();
        } else {
            // é™æµè§¦å‘ï¼Œæ‰§è¡Œé™çº§é€»è¾‘
            return executeFallback(point, rateLimit);
        }
    }
    
    private String getRateLimitKey(ProceedingJoinPoint point, RateLimit rateLimit) {
        if (!rateLimit.key().isEmpty()) {
            return rateLimit.key();
        }
        
        // è‡ªåŠ¨ç”Ÿæˆkey
        String methodName = point.getSignature().getName();
        String className = point.getTarget().getClass().getSimpleName();
        return className + ":" + methodName;
    }
    
    private RateLimiter getOrCreateLimiter(String key, double qps) {
        return limiters.computeIfAbsent(key, k -> RateLimiter.create(qps));
    }
    
    private Object executeFallback(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        if (!rateLimit.fallback().isEmpty()) {
            // è°ƒç”¨é™çº§æ–¹æ³•
            Method fallbackMethod = findFallbackMethod(point, rateLimit.fallback());
            if (fallbackMethod != null) {
                return fallbackMethod.invoke(point.getTarget(), point.getArgs());
            }
        }
        
        // é»˜è®¤é™çº§ï¼šæŠ›å‡ºé™æµå¼‚å¸¸
        throw new RateLimitExceededException("è¯·æ±‚é¢‘ç‡è¶…é™");
    }
    
    private Method findFallbackMethod(ProceedingJoinPoint point, String fallbackMethodName) {
        try {
            return point.getTarget().getClass().getMethod(fallbackMethodName);
        } catch (NoSuchMethodException e) {
            return null;
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
@RestController
public class UserController {
    
    @RateLimit(qps = 100, dimension = RateLimitDimension.USER)
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
    
    @RateLimit(qps = 10, fallback = "getUserFallback")
    @GetMapping("/users/{id}/detail")
    public UserDetail getUserDetail(@PathVariable Long id) {
        return userService.getUserDetail(id);
    }
    
    public UserDetail getUserFallback(Long id) {
        // é™çº§é€»è¾‘ï¼šè¿”å›åŸºæœ¬ä¿¡æ¯
        return new UserDetail(id, "ç”¨æˆ·" + id, "åŸºæœ¬ä¿¡æ¯");
    }
}
```

### 4.2 è¿‡æ»¤å™¨é™æµ

```java title="è¿‡æ»¤å™¨é™æµå®ç°"
@Component
public class RateLimitFilter implements Filter {
    
    private final RateLimiter rateLimiter;
    private final ObjectMapper objectMapper;
    
    public RateLimitFilter() {
        this.rateLimiter = RateLimiter.create(100.0); // 100 QPS
        this.objectMapper = new ObjectMapper();
    }
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // è·å–é™æµé”®
        String key = getRateLimitKey(httpRequest);
        
        if (rateLimiter.tryAcquire()) {
            chain.doFilter(request, response);
        } else {
            // é™æµå“åº”
            sendRateLimitResponse(httpResponse);
        }
    }
    
    private String getRateLimitKey(HttpServletRequest request) {
        // åŸºäºIPçš„é™æµ
        String ip = getClientIp(request);
        
        // åŸºäºç”¨æˆ·çš„é™æµ
        String userId = getUserId(request);
        
        // åŸºäºAPIçš„é™æµ
        String api = request.getRequestURI();
        
        return String.format("%s:%s:%s", ip, userId, api);
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }
    
    private String getUserId(HttpServletRequest request) {
        // ä»è¯·æ±‚å¤´æˆ–å‚æ•°ä¸­è·å–ç”¨æˆ·ID
        String userId = request.getHeader("X-User-ID");
        if (userId == null) {
            userId = request.getParameter("userId");
        }
        return userId != null ? userId : "anonymous";
    }
    
    private void sendRateLimitResponse(HttpServletResponse response) throws IOException {
        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
        response.setContentType("application/json");
        
        Map<String, Object> result = new HashMap<>();
        result.put("code", 429);
        result.put("message", "è¯·æ±‚é¢‘ç‡è¶…é™ï¼Œè¯·ç¨åé‡è¯•");
        result.put("timestamp", System.currentTimeMillis());
        
        response.getWriter().write(objectMapper.writeValueAsString(result));
    }
}
```

## 5. é™æµç›‘æ§

### 5.1 é™æµç»Ÿè®¡

```java title="é™æµç»Ÿè®¡å®ç°"
@Component
public class RateLimitStatistics {
    
    private final Map<String, AtomicLong> requestCounts = new ConcurrentHashMap<>();
    private final Map<String, AtomicLong> limitCounts = new ConcurrentHashMap<>();
    private final Map<String, AtomicLong> totalCounts = new ConcurrentHashMap<>();
    
    public void recordRequest(String key, boolean limited) {
        requestCounts.computeIfAbsent(key, k -> new AtomicLong()).incrementAndGet();
        totalCounts.computeIfAbsent(key, k -> new AtomicLong()).incrementAndGet();
        
        if (limited) {
            limitCounts.computeIfAbsent(key, k -> new AtomicLong()).incrementAndGet();
        }
    }
    
    public RateLimitStats getStats(String key) {
        long requests = requestCounts.getOrDefault(key, new AtomicLong()).get();
        long limits = limitCounts.getOrDefault(key, new AtomicLong()).get();
        long total = totalCounts.getOrDefault(key, new AtomicLong()).get();
        
        double limitRate = total > 0 ? (double) limits / total * 100 : 0;
        
        return new RateLimitStats(key, requests, limits, total, limitRate);
    }
    
    public Map<String, RateLimitStats> getAllStats() {
        Map<String, RateLimitStats> stats = new HashMap<>();
        
        for (String key : totalCounts.keySet()) {
            stats.put(key, getStats(key));
        }
        
        return stats;
    }
    
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿé‡ç½®è®¡æ•°å™¨
    public void resetCounters() {
        requestCounts.clear();
        limitCounts.clear();
    }
}

class RateLimitStats {
    private final String key;
    private final long requests;
    private final long limits;
    private final long total;
    private final double limitRate;
    
    // æ„é€ å‡½æ•°å’Œgetteræ–¹æ³•
}
```

### 5.2 é™æµå‘Šè­¦

```java title="é™æµå‘Šè­¦å®ç°"
@Component
public class RateLimitAlert {
    
    @Autowired
    private RateLimitStatistics statistics;
    
    @Autowired
    private EmailService emailService;
    
    @Value("${rate.limit.alert.threshold:80}")
    private double alertThreshold;
    
    @Scheduled(fixedRate = 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void checkRateLimitAlert() {
        Map<String, RateLimitStats> stats = statistics.getAllStats();
        
        for (RateLimitStats stat : stats.values()) {
            if (stat.getLimitRate() > alertThreshold) {
                sendAlert(stat);
            }
        }
    }
    
    private void sendAlert(RateLimitStats stat) {
        String subject = "é™æµå‘Šè­¦";
        String message = String.format(
            "é™æµé”®: %s\n" +
            "è¯·æ±‚æ€»æ•°: %d\n" +
            "é™æµæ¬¡æ•°: %d\n" +
            "é™æµç‡: %.2f%%\n" +
            "æ—¶é—´: %s",
            stat.getKey(),
            stat.getTotal(),
            stat.getLimits(),
            stat.getLimitRate(),
            new Date()
        );
        
        try {
            emailService.sendAlertEmail(subject, message);
        } catch (Exception e) {
            log.error("å‘é€é™æµå‘Šè­¦å¤±è´¥", e);
        }
    }
}
```

## 6. é¢è¯•é¢˜ç²¾é€‰

### 6.1 åŸºç¡€æ¦‚å¿µé¢˜

**Q: ä»€ä¹ˆæ˜¯é™æµï¼Ÿä¸ºä»€ä¹ˆéœ€è¦é™æµï¼Ÿ**

A: é™æµæ˜¯æŒ‡æ§åˆ¶ç³»ç»Ÿè®¿é—®é¢‘ç‡çš„æŠ€æœ¯ã€‚éœ€è¦é™æµçš„åŸå› ï¼š
- **ä¿æŠ¤ç³»ç»Ÿ**ï¼šé˜²æ­¢ç³»ç»Ÿè¿‡è½½å´©æºƒ
- **èµ„æºç®¡ç†**ï¼šåˆç†åˆ†é…ç³»ç»Ÿèµ„æº
- **æˆæœ¬æ§åˆ¶**ï¼šæ§åˆ¶APIè°ƒç”¨æˆæœ¬
- **ç”¨æˆ·ä½“éªŒ**ï¼šä¿è¯æ ¸å¿ƒåŠŸèƒ½å¯ç”¨
- **å®‰å…¨é˜²æŠ¤**ï¼šé˜²æ­¢æ¶æ„æ”»å‡»

**Q: å¸¸è§çš„é™æµç®—æ³•æœ‰å“ªäº›ï¼Ÿå„æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ**

A: å¸¸è§çš„é™æµç®—æ³•ï¼š
- **å›ºå®šçª—å£**ï¼šç®€å•æ˜“å®ç°ï¼Œä½†å­˜åœ¨ä¸´ç•Œé—®é¢˜
- **æ»‘åŠ¨çª—å£**ï¼šè§£å†³ä¸´ç•Œé—®é¢˜ï¼Œä½†å®ç°å¤æ‚
- **ä»¤ç‰Œæ¡¶**ï¼šæ”¯æŒçªå‘æµé‡ï¼Œé€‚åˆæµé‡æ•´å½¢
- **æ¼æ¡¶**ï¼šå¹³æ»‘æµé‡ï¼Œä½†ä¸æ”¯æŒçªå‘æµé‡

### 6.2 ç®—æ³•å®ç°é¢˜

**Q: å¦‚ä½•å®ç°ä»¤ç‰Œæ¡¶ç®—æ³•ï¼Ÿ**

A: ä»¤ç‰Œæ¡¶ç®—æ³•å®ç°æ­¥éª¤ï¼š
- **åˆå§‹åŒ–**ï¼šè®¾ç½®ä»¤ç‰Œç”Ÿæˆé€Ÿç‡å’Œæ¡¶å®¹é‡
- **ä»¤ç‰Œç”Ÿæˆ**ï¼šæŒ‰é€Ÿç‡å‘æ¡¶ä¸­æ·»åŠ ä»¤ç‰Œ
- **è¯·æ±‚å¤„ç†**ï¼šä»æ¡¶ä¸­å–å‡ºä»¤ç‰Œå¤„ç†è¯·æ±‚
- **é™æµåˆ¤æ–­**ï¼šæ¡¶ä¸­ä»¤ç‰Œä¸è¶³æ—¶æ‹’ç»è¯·æ±‚

**Q: å¦‚ä½•å®ç°æ»‘åŠ¨çª—å£ç®—æ³•ï¼Ÿ**

A: æ»‘åŠ¨çª—å£ç®—æ³•å®ç°æ­¥éª¤ï¼š
- **åˆ†æ¡¶**ï¼šå°†æ—¶é—´çª—å£åˆ†ä¸ºå¤šä¸ªå°æ¡¶
- **è®¡æ•°**ï¼šåœ¨æ¯ä¸ªæ¡¶ä¸­è®°å½•è¯·æ±‚æ•°é‡
- **æ»‘åŠ¨**ï¼šæ ¹æ®å½“å‰æ—¶é—´æ›´æ–°çª—å£
- **ç»Ÿè®¡**ï¼šç»Ÿè®¡çª—å£å†…æ‰€æœ‰æ¡¶çš„è¯·æ±‚æ€»æ•°

### 6.3 å®é™…åº”ç”¨é¢˜

**Q: å¦‚ä½•è®¾è®¡ä¸€ä¸ªåˆ†å¸ƒå¼é™æµç³»ç»Ÿï¼Ÿ**

A: åˆ†å¸ƒå¼é™æµç³»ç»Ÿè®¾è®¡ï¼š
- **é›†ä¸­å¼å­˜å‚¨**ï¼šä½¿ç”¨Rediså­˜å‚¨é™æµçŠ¶æ€
- **åˆ†å¸ƒå¼åè°ƒ**ï¼šä½¿ç”¨Zookeeperæˆ–Consul
- **ä¸€è‡´æ€§ä¿è¯**ï¼šä½¿ç”¨åˆ†å¸ƒå¼é”æˆ–åŸå­æ“ä½œ
- **æ•…éšœå¤„ç†**ï¼šé™çº§åˆ°æœ¬åœ°é™æµ
- **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§é™æµçŠ¶æ€

**Q: å¦‚ä½•å®ç°åŠ¨æ€é™æµï¼Ÿ**

A: åŠ¨æ€é™æµå®ç°æ–¹æ³•ï¼š
- **ç³»ç»Ÿç›‘æ§**ï¼šç›‘æ§CPUã€å†…å­˜ã€ç½‘ç»œç­‰æŒ‡æ ‡
- **åŠ¨æ€è°ƒæ•´**ï¼šæ ¹æ®ç³»ç»Ÿè´Ÿè½½è°ƒæ•´é™æµå‚æ•°
- **é…ç½®ä¸­å¿ƒ**ï¼šä½¿ç”¨é…ç½®ä¸­å¿ƒåŠ¨æ€ä¿®æ”¹é™æµè§„åˆ™
- **æœºå™¨å­¦ä¹ **ï¼šä½¿ç”¨MLç®—æ³•é¢„æµ‹å’Œè°ƒæ•´é™æµ

:::tip é™æµå­¦ä¹ è¦ç‚¹
1. **ç†è§£é™æµæ¦‚å¿µ**ï¼šæŒæ¡é™æµçš„ç›®çš„ã€ç»´åº¦å’Œç­–ç•¥
2. **æŒæ¡é™æµç®—æ³•**ï¼šå­¦ä¼šå›ºå®šçª—å£ã€æ»‘åŠ¨çª—å£ã€ä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ç®—æ³•
3. **ç†Ÿæ‚‰å®ç°æ–¹å¼**ï¼šäº†è§£æ³¨è§£å¼ã€è¿‡æ»¤å™¨å¼ã€ä¸­é—´ä»¶å¼é™æµ
4. **å­¦ä¼šç›‘æ§å‘Šè­¦**ï¼šæŒæ¡é™æµç»Ÿè®¡ã€ç›‘æ§ã€å‘Šè­¦æœºåˆ¶
5. **äº†è§£æœ€ä½³å®è·µ**ï¼šå­¦ä¹ ä¸šç•Œæˆç†Ÿçš„é™æµæ–¹æ¡ˆ
:::

---

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ åº”è¯¥å·²ç»æŒæ¡äº†é™æµç³»ç»Ÿè®¾è®¡çš„æ ¸å¿ƒæ¦‚å¿µã€ç®—æ³•å®ç°å’Œæœ€ä½³å®è·µã€‚é™æµç³»ç»Ÿè®¾è®¡æ˜¯ä¿æŠ¤ç³»ç»Ÿç¨³å®šè¿è¡Œçš„é‡è¦æŠ€æœ¯ï¼ŒæŒæ¡è¿™äº›æŠ€æœ¯å¯ä»¥å¸®åŠ©ä½ æ„å»ºå‡ºå¥å£®çš„ç³»ç»Ÿã€‚åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œåˆç†è¿ç”¨é™æµæŠ€æœ¯å¯ä»¥æœ‰æ•ˆé˜²æ­¢ç³»ç»Ÿè¿‡è½½ï¼Œä¿è¯æœåŠ¡è´¨é‡ã€‚ 