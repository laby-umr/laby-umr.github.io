---
sidebar_position: 5
title: Nettyç½‘ç»œç¼–ç¨‹æ¡†æ¶è¯¦è§£
description: æ·±å…¥ç†è§£Nettyæ¶æ„è®¾è®¡ã€æ ¸å¿ƒç»„ä»¶ã€çº¿ç¨‹æ¨¡å‹ä¸é«˜æ€§èƒ½ç½‘ç»œç¼–ç¨‹å®è·µ
authors: [Laby]
tags: [Netty, ç½‘ç»œæ¡†æ¶, EventLoop, Pipeline, ByteBuf, é«˜æ€§èƒ½]
last_update:
  date: 2025-08-15
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Nettyç½‘ç»œç¼–ç¨‹æ¡†æ¶è¯¦è§£

Nettyæ˜¯ä¸€ä¸ªé«˜æ€§èƒ½ã€å¼‚æ­¥äº‹ä»¶é©±åŠ¨çš„ç½‘ç»œåº”ç”¨æ¡†æ¶ï¼Œç”¨äºå¿«é€Ÿå¼€å‘å¯ç»´æŠ¤çš„é«˜æ€§èƒ½åè®®æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ã€‚å®ƒç®€åŒ–äº†ç½‘ç»œç¼–ç¨‹çš„å¤æ‚æ€§ï¼Œæ˜¯æ„å»ºåˆ†å¸ƒå¼ç³»ç»Ÿçš„é‡è¦åŸºç¡€è®¾æ–½ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**Netty = é«˜æ€§èƒ½ç½‘ç»œæ¡†æ¶ + å¼‚æ­¥äº‹ä»¶é©±åŠ¨ + ä¸°å¯Œçš„ç¼–è§£ç å™¨ + ç”Ÿäº§çº§ç‰¹æ€§**
- ğŸš€ **é«˜æ€§èƒ½**ï¼šåŸºäºNIOçš„Reactoræ¨¡å¼ï¼Œæ”¯æŒç™¾ä¸‡çº§å¹¶å‘è¿æ¥
- ğŸ¯ **æ˜“ç”¨æ€§**ï¼šç®€åŒ–ç½‘ç»œç¼–ç¨‹å¤æ‚æ€§ï¼Œæä¾›ä¸°å¯Œçš„å¼€ç®±å³ç”¨ç»„ä»¶
- ğŸ”§ **å¯æ‰©å±•**ï¼šçµæ´»çš„Pipelineè®¾è®¡ï¼Œæ”¯æŒè‡ªå®šä¹‰åè®®å’Œç¼–è§£ç å™¨
- ğŸ›¡ï¸ **ç”Ÿäº§çº§**ï¼šå†…å­˜ç®¡ç†ã€æµé‡æ§åˆ¶ã€å¿ƒè·³æ£€æµ‹ç­‰ä¼ä¸šçº§ç‰¹æ€§
- ğŸŒ **å¹¿æ³›åº”ç”¨**ï¼šDubboã€Spring Cloud Gatewayã€Elasticsearchç­‰çŸ¥åé¡¹ç›®çš„ç½‘ç»œå±‚åŸºç¡€
:::

## 1. Nettyæ¶æ„è®¾è®¡

### 1.1 æ ¸å¿ƒç»„ä»¶æ¶æ„

```mermaid
graph TB
    A[Nettyæ¶æ„] --> B[Bootstrapå¯åŠ¨å™¨]
    A --> C[EventLoopGroupäº‹ä»¶å¾ªç¯ç»„]
    A --> D[Channelé€šé“]
    A --> E[ChannelPipelineå¤„ç†é“¾]
    A --> F[ChannelHandlerå¤„ç†å™¨]
    A --> G[ByteBufç¼“å†²åŒº]
    
    B --> B1[ServerBootstrap]
    B --> B2[Bootstrap]
    
    C --> C1[BossGroup]
    C --> C2[WorkerGroup]
    
    D --> D1[NioServerSocketChannel]
    D --> D2[NioSocketChannel]
    
    E --> E1[Inboundå¤„ç†é“¾]
    E --> E2[Outboundå¤„ç†é“¾]
    
    F --> F1[ChannelInboundHandler]
    F --> F2[ChannelOutboundHandler]
    
    G --> G1[å †å†…å­˜]
    G --> G2[ç›´æ¥å†…å­˜]
    G --> G3[å†…å­˜æ± ]
```

### 1.2 Reactorçº¿ç¨‹æ¨¡å‹

<Tabs>
<TabItem value="reactor-model" label="Reactoræ¨¡å‹">

**Nettyçº¿ç¨‹æ¨¡å‹æ¼”è¿›**

```mermaid
graph TB
    subgraph "å•Reactorå•çº¿ç¨‹"
        A1[Reactor] --> A2[Acceptor]
        A1 --> A3[Handler1]
        A1 --> A4[Handler2]
    end
    
    subgraph "å•Reactorå¤šçº¿ç¨‹"
        B1[Reactor] --> B2[Acceptor]
        B1 --> B3[Handler Pool]
        B3 --> B4[Handler1]
        B3 --> B5[Handler2]
        B3 --> B6[HandlerN]
    end
    
    subgraph "ä¸»ä»Reactorå¤šçº¿ç¨‹"
        C1[MainReactor] --> C2[Acceptor]
        C1 --> C3[SubReactor1]
        C1 --> C4[SubReactor2]
        C3 --> C5[Handler1]
        C3 --> C6[Handler2]
        C4 --> C7[Handler3]
        C4 --> C8[Handler4]
    end
```

**Nettyçº¿ç¨‹æ¨¡å‹ç‰¹ç‚¹**
- **BossGroup**ï¼šå¤„ç†å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚
- **WorkerGroup**ï¼šå¤„ç†IOè¯»å†™æ“ä½œ
- **EventLoop**ï¼šå•çº¿ç¨‹æ‰§è¡Œå™¨ï¼Œå¤„ç†Channelçš„æ‰€æœ‰IOäº‹ä»¶
- **çº¿ç¨‹å®‰å…¨**ï¼šåŒä¸€ä¸ªChannelçš„æ‰€æœ‰æ“ä½œéƒ½åœ¨åŒä¸€ä¸ªEventLoopä¸­æ‰§è¡Œ

</TabItem>
<TabItem value="eventloop" label="EventLoopè¯¦è§£">

**EventLoopå·¥ä½œåŸç†**

```mermaid
graph LR
    A[EventLoop] --> B[ä»»åŠ¡é˜Ÿåˆ—]
    A --> C[å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—]
    A --> D[IOäº‹ä»¶å¤„ç†]
    
    B --> B1[æ™®é€šä»»åŠ¡]
    B --> B2[ç³»ç»Ÿä»»åŠ¡]
    
    C --> C1[å»¶æ—¶ä»»åŠ¡]
    C --> C2[å‘¨æœŸä»»åŠ¡]
    
    D --> D1[Acceptäº‹ä»¶]
    D --> D2[Readäº‹ä»¶]
    D --> D3[Writeäº‹ä»¶]
```

**EventLoopæ ¸å¿ƒç‰¹æ€§**
```java title="EventLoopç‰¹æ€§ç¤ºä¾‹"
// 1. çº¿ç¨‹å®‰å…¨ï¼šåŒä¸€ä¸ªChannelçš„æ“ä½œéƒ½åœ¨åŒä¸€ä¸ªEventLoopä¸­
Channel channel = ...;
EventLoop eventLoop = channel.eventLoop();

// 2. ä»»åŠ¡æäº¤ï¼šå¯ä»¥æäº¤ä»»åŠ¡åˆ°EventLoopæ‰§è¡Œ
eventLoop.execute(() -> {
    // åœ¨EventLoopçº¿ç¨‹ä¸­æ‰§è¡Œ
    System.out.println("Task executed in EventLoop");
});

// 3. å®šæ—¶ä»»åŠ¡ï¼šæ”¯æŒå»¶æ—¶å’Œå‘¨æœŸæ€§ä»»åŠ¡
eventLoop.schedule(() -> {
    System.out.println("Scheduled task");
}, 5, TimeUnit.SECONDS);

// 4. åˆ¤æ–­æ˜¯å¦åœ¨EventLoopçº¿ç¨‹ä¸­
if (eventLoop.inEventLoop()) {
    // ç›´æ¥æ‰§è¡Œ
    doSomething();
} else {
    // æäº¤åˆ°EventLoopæ‰§è¡Œ
    eventLoop.execute(() -> doSomething());
}
```

</TabItem>
<TabItem value="thread-model-comparison" label="çº¿ç¨‹æ¨¡å‹å¯¹æ¯”">

| æ¨¡å‹ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ | Nettyå®ç° |
|------|------|------|----------|-----------|
| å•Reactorå•çº¿ç¨‹ | ç®€å•ï¼Œæ— çº¿ç¨‹ç«äº‰ | æ€§èƒ½æœ‰é™ï¼Œå•ç‚¹æ•…éšœ | è¿æ¥æ•°å°‘ï¼Œå¤„ç†ç®€å• | EventLoopGroup(1) |
| å•Reactorå¤šçº¿ç¨‹ | å……åˆ†åˆ©ç”¨å¤šæ ¸CPU | Reactoræˆä¸ºç“¶é¢ˆ | ä¸­ç­‰å¹¶å‘ï¼ŒCPUå¯†é›† | EventLoopGroup(1) + ä¸šåŠ¡çº¿ç¨‹æ±  |
| ä¸»ä»Reactorå¤šçº¿ç¨‹ | é«˜å¹¶å‘ï¼ŒèŒè´£åˆ†ç¦» | å®ç°å¤æ‚ | é«˜å¹¶å‘åœºæ™¯ | BossGroup + WorkerGroup |
| å¤šReactorå¤šçº¿ç¨‹ | æœ€é«˜æ€§èƒ½ | æœ€å¤æ‚ | è¶…é«˜å¹¶å‘ | å¤šä¸ªEventLoopGroup |

**Nettyæ¨èé…ç½®**
```java title="çº¿ç¨‹æ¨¡å‹æœ€ä½³å®è·µ"
// æ¨èé…ç½®ï¼šCPUæ ¸å¿ƒæ•°çš„1-2å€
int bossThreads = 1; // é€šå¸¸1ä¸ªçº¿ç¨‹è¶³å¤Ÿå¤„ç†è¿æ¥
int workerThreads = Runtime.getRuntime().availableProcessors() * 2;

EventLoopGroup bossGroup = new NioEventLoopGroup(bossThreads);
EventLoopGroup workerGroup = new NioEventLoopGroup(workerThreads);

// ä¸šåŠ¡å¤„ç†çº¿ç¨‹æ± ï¼ˆé¿å…é˜»å¡EventLoopï¼‰
ExecutorService businessExecutor = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors() * 4);
```

</TabItem>
</Tabs>

## 2. Nettyæ ¸å¿ƒç»„ä»¶è¯¦è§£

### 2.1 Bootstrapå¯åŠ¨å™¨

<Tabs>
<TabItem value="server-bootstrap" label="æœåŠ¡ç«¯å¯åŠ¨">

```java title="NettyæœåŠ¡ç«¯å®Œæ•´ç¤ºä¾‹"
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.Delimiters;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;

public class NettyServer {
    private final int port;
    
    public NettyServer(int port) {
        this.port = port;
    }
    
    public void start() throws InterruptedException {
        // åˆ›å»ºEventLoopGroup
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 1024)
                    .option(ChannelOption.SO_REUSEADDR, true)
                    .childOption(ChannelOption.SO_KEEPALIVE, true)
                    .childOption(ChannelOption.TCP_NODELAY, true)
                    .handler(new LoggingHandler(LogLevel.INFO))
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ChannelPipeline pipeline = ch.pipeline();
                            
                            // æ·»åŠ ç¼–è§£ç å™¨
                            pipeline.addLast(new DelimiterBasedFrameDecoder(
                                8192, Delimiters.lineDelimiter()));
                            pipeline.addLast(new StringDecoder());
                            pipeline.addLast(new StringEncoder());
                            
                            // æ·»åŠ ä¸šåŠ¡å¤„ç†å™¨
                            pipeline.addLast(new ServerHandler());
                        }
                    });
            
            // ç»‘å®šç«¯å£å¹¶å¯åŠ¨æœåŠ¡å™¨
            ChannelFuture future = bootstrap.bind(port).sync();
            System.out.println("NettyæœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œç›‘å¬ç«¯å£: " + port);
            
            // ç­‰å¾…æœåŠ¡å™¨å…³é—­
            future.channel().closeFuture().sync();
            
        } finally {
            // ä¼˜é›…å…³é—­
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        new NettyServer(8080).start();
    }
}

/**
 * æœåŠ¡ç«¯ä¸šåŠ¡å¤„ç†å™¨
 */
class ServerHandler extends ChannelInboundHandlerAdapter {
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        System.out.println("å®¢æˆ·ç«¯è¿æ¥: " + ctx.channel().remoteAddress());
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String message = (String) msg;
        System.out.println("æ”¶åˆ°æ¶ˆæ¯: " + message);
        
        // å›æ˜¾æ¶ˆæ¯
        ctx.writeAndFlush("Echo: " + message + "\n");
    }
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        System.out.println("å®¢æˆ·ç«¯æ–­å¼€: " + ctx.channel().remoteAddress());
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        System.err.println("å¤„ç†å¼‚å¸¸: " + cause.getMessage());
        ctx.close();
    }
}
```

</TabItem>
<TabItem value="client-bootstrap" label="å®¢æˆ·ç«¯å¯åŠ¨">

```java title="Nettyå®¢æˆ·ç«¯å®Œæ•´ç¤ºä¾‹"
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;
import io.netty.handler.codec.Delimiters;

import java.util.Scanner;

public class NettyClient {
    private final String host;
    private final int port;
    
    public NettyClient(String host, int port) {
        this.host = host;
        this.port = port;
    }
    
    public void start() throws InterruptedException {
        EventLoopGroup group = new NioEventLoopGroup();
        
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group)
                    .channel(NioSocketChannel.class)
                    .option(ChannelOption.SO_KEEPALIVE, true)
                    .option(ChannelOption.TCP_NODELAY, true)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ChannelPipeline pipeline = ch.pipeline();
                            
                            // æ·»åŠ ç¼–è§£ç å™¨
                            pipeline.addLast(new DelimiterBasedFrameDecoder(
                                8192, Delimiters.lineDelimiter()));
                            pipeline.addLast(new StringDecoder());
                            pipeline.addLast(new StringEncoder());
                            
                            // æ·»åŠ ä¸šåŠ¡å¤„ç†å™¨
                            pipeline.addLast(new ClientHandler());
                        }
                    });
            
            // è¿æ¥æœåŠ¡å™¨
            ChannelFuture future = bootstrap.connect(host, port).sync();
            System.out.println("è¿æ¥æœåŠ¡å™¨æˆåŠŸ: " + host + ":" + port);
            
            Channel channel = future.channel();
            
            // ç”¨æˆ·è¾“å…¥å¤„ç†
            Scanner scanner = new Scanner(System.in);
            System.out.println("è¾“å…¥æ¶ˆæ¯ï¼ˆè¾“å…¥'quit'é€€å‡ºï¼‰:");
            
            String input;
            while ((input = scanner.nextLine()) != null) {
                if ("quit".equalsIgnoreCase(input)) {
                    break;
                }
                
                channel.writeAndFlush(input + "\n");
            }
            
        } finally {
            group.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        new NettyClient("localhost", 8080).start();
    }
}

/**
 * å®¢æˆ·ç«¯ä¸šåŠ¡å¤„ç†å™¨
 */
class ClientHandler extends ChannelInboundHandlerAdapter {
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        System.out.println("è¿æ¥å»ºç«‹æˆåŠŸ");
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        String response = (String) msg;
        System.out.println("æœåŠ¡å™¨å“åº”: " + response);
    }
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        System.out.println("è¿æ¥æ–­å¼€");
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        System.err.println("å®¢æˆ·ç«¯å¼‚å¸¸: " + cause.getMessage());
        ctx.close();
    }
}
```

</TabItem>
<TabItem value="bootstrap-options" label="å¯åŠ¨å‚æ•°é…ç½®">

**é‡è¦çš„Channelé€‰é¡¹**

```java title="Channelé€‰é¡¹è¯¦è§£"
// æœåŠ¡ç«¯é€‰é¡¹
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap
    // TCPè¿æ¥é˜Ÿåˆ—å¤§å°
    .option(ChannelOption.SO_BACKLOG, 1024)
    
    // åœ°å€é‡ç”¨
    .option(ChannelOption.SO_REUSEADDR, true)
    
    // æ¥æ”¶ç¼“å†²åŒºå¤§å°
    .option(ChannelOption.SO_RCVBUF, 32 * 1024)
    
    // å­Channelé€‰é¡¹
    .childOption(ChannelOption.SO_KEEPALIVE, true)    // ä¿æ´»æœºåˆ¶
    .childOption(ChannelOption.TCP_NODELAY, true)     // ç¦ç”¨Nagleç®—æ³•
    .childOption(ChannelOption.SO_SNDBUF, 32 * 1024) // å‘é€ç¼“å†²åŒº
    .childOption(ChannelOption.SO_RCVBUF, 32 * 1024) // æ¥æ”¶ç¼“å†²åŒº
    
    // Nettyç‰¹æœ‰é€‰é¡¹
    .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, 
        new WriteBufferWaterMark(8 * 1024, 32 * 1024)) // å†™ç¼“å†²åŒºæ°´ä½çº¿
    .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT); // å†…å­˜åˆ†é…å™¨
```

**å®¢æˆ·ç«¯é€‰é¡¹**
```java title="å®¢æˆ·ç«¯é€‰é¡¹é…ç½®"
Bootstrap bootstrap = new Bootstrap();
bootstrap
    .option(ChannelOption.SO_KEEPALIVE, true)
    .option(ChannelOption.TCP_NODELAY, true)
    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000) // è¿æ¥è¶…æ—¶
    .option(ChannelOption.SO_TIMEOUT, 10000);           // è¯»å–è¶…æ—¶
```

**æ€§èƒ½è°ƒä¼˜å‚æ•°**
```java title="æ€§èƒ½è°ƒä¼˜é…ç½®"
// 1. å†…å­˜åˆ†é…å™¨
.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)

// 2. å†™ç¼“å†²åŒºæ°´ä½çº¿
.option(ChannelOption.WRITE_BUFFER_WATER_MARK, 
    new WriteBufferWaterMark(32 * 1024, 64 * 1024))

// 3. æ¥æ”¶å­—èŠ‚ç¼“å†²åŒºåˆ†é…å™¨
.option(ChannelOption.RCVBUF_ALLOCATOR, 
    new AdaptiveRecvByteBufAllocator(64, 1024, 65536))

// 4. æ¶ˆæ¯å¤§å°ä¼°ç®—å™¨
.option(ChannelOption.MESSAGE_SIZE_ESTIMATOR, 
    DefaultMessageSizeEstimator.DEFAULT)
```

</TabItem>
</Tabs>

### 2.2 ChannelPipelineå¤„ç†é“¾

<Tabs>
<TabItem value="pipeline-concept" label="Pipelineæ¦‚å¿µ">

**Pipelineå¤„ç†æµç¨‹**

```mermaid
graph LR
    A[å®¢æˆ·ç«¯æ•°æ®] --> B[Inbound Handler 1]
    B --> C[Inbound Handler 2]
    C --> D[Inbound Handler 3]
    D --> E[ä¸šåŠ¡å¤„ç†]
    
    E --> F[Outbound Handler 3]
    F --> G[Outbound Handler 2]
    G --> H[Outbound Handler 1]
    H --> I[ç½‘ç»œå‘é€]
    
    subgraph "å…¥ç«™å¤„ç†é“¾"
        B
        C
        D
    end
    
    subgraph "å‡ºç«™å¤„ç†é“¾"
        F
        G
        H
    end
```

**Pipelineæ ¸å¿ƒç‰¹æ€§**
- **åŒå‘é“¾è¡¨**ï¼šHandleræŒ‰é¡ºåºç»„ç»‡æˆåŒå‘é“¾è¡¨
- **å…¥ç«™å¤„ç†**ï¼šæ•°æ®ä»ç½‘ç»œåˆ°åº”ç”¨çš„å¤„ç†é“¾
- **å‡ºç«™å¤„ç†**ï¼šæ•°æ®ä»åº”ç”¨åˆ°ç½‘ç»œçš„å¤„ç†é“¾
- **åŠ¨æ€ä¿®æ”¹**ï¼šè¿è¡Œæ—¶å¯ä»¥åŠ¨æ€æ·»åŠ ã€åˆ é™¤Handler

</TabItem>
<TabItem value="handler-types" label="Handlerç±»å‹">

**Handleråˆ†ç±»**

```java title="ä¸åŒç±»å‹çš„Handler"
// 1. å…¥ç«™å¤„ç†å™¨
public class MyInboundHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // å¤„ç†å…¥ç«™æ•°æ®
        System.out.println("Inbound: " + msg);
        
        // ä¼ é€’ç»™ä¸‹ä¸€ä¸ªHandler
        ctx.fireChannelRead(msg);
    }
}

// 2. å‡ºç«™å¤„ç†å™¨
public class MyOutboundHandler extends ChannelOutboundHandlerAdapter {
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        // å¤„ç†å‡ºç«™æ•°æ®
        System.out.println("Outbound: " + msg);
        
        // ä¼ é€’ç»™ä¸‹ä¸€ä¸ªHandler
        ctx.write(msg, promise);
    }
}

// 3. åŒå‘å¤„ç†å™¨
public class MyDuplexHandler extends ChannelDuplexHandler {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // å…¥ç«™å¤„ç†
        ctx.fireChannelRead(msg);
    }
    
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        // å‡ºç«™å¤„ç†
        ctx.write(msg, promise);
    }
}

// 4. ç®€åŒ–çš„å…¥ç«™å¤„ç†å™¨
public class MySimpleHandler extends SimpleChannelInboundHandler<String> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, String msg) {
        // è‡ªåŠ¨ç±»å‹è½¬æ¢å’Œèµ„æºé‡Šæ”¾
        System.out.println("Message: " + msg);
    }
}
```

**Handlerç”Ÿå‘½å‘¨æœŸ**
```java title="Handlerç”Ÿå‘½å‘¨æœŸæ–¹æ³•"
public class LifecycleHandler extends ChannelInboundHandlerAdapter {
    
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        System.out.println("Handleræ·»åŠ åˆ°Pipeline");
    }
    
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) {
        System.out.println("Channelæ³¨å†Œåˆ°EventLoop");
    }
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        System.out.println("Channelæ¿€æ´»");
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        System.out.println("è¯»å–æ•°æ®: " + msg);
        ctx.fireChannelRead(msg);
    }
    
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        System.out.println("è¯»å–å®Œæˆ");
        ctx.fireChannelReadComplete();
    }
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        System.out.println("Channeléæ¿€æ´»");
    }
    
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) {
        System.out.println("Channelä»EventLoopæ³¨é”€");
    }
    
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        System.out.println("Handlerä»Pipelineç§»é™¤");
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        System.err.println("å¼‚å¸¸å¤„ç†: " + cause.getMessage());
        ctx.close();
    }
}
```

</TabItem>
<TabItem value="pipeline-operations" label="Pipelineæ“ä½œ">

**åŠ¨æ€ä¿®æ”¹Pipeline**

```java title="PipelineåŠ¨æ€æ“ä½œ"
public class DynamicPipelineHandler extends ChannelInboundHandlerAdapter {
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        ChannelPipeline pipeline = ctx.pipeline();
        
        // 1. æ·»åŠ Handler
        pipeline.addFirst("first", new FirstHandler());
        pipeline.addLast("last", new LastHandler());
        pipeline.addBefore("existing", "new", new NewHandler());
        pipeline.addAfter("existing", "another", new AnotherHandler());
        
        // 2. æ›¿æ¢Handler
        pipeline.replace("old", "new", new NewHandler());
        
        // 3. ç§»é™¤Handler
        pipeline.remove("unwanted");
        pipeline.remove(UnwantedHandler.class);
        
        // 4. è·å–Handler
        ChannelHandler handler = pipeline.get("handlerName");
        FirstHandler first = pipeline.get(FirstHandler.class);
        
        // 5. æ£€æŸ¥Handleræ˜¯å¦å­˜åœ¨
        if (pipeline.names().contains("handlerName")) {
            // Handlerå­˜åœ¨
        }
        
        ctx.fireChannelActive();
    }
}
```

**æ¡ä»¶åŒ–Pipelineé…ç½®**
```java title="æ¡ä»¶åŒ–é…ç½®ç¤ºä¾‹"
public class ConditionalPipelineInitializer extends ChannelInitializer<SocketChannel> {
    
    private final boolean enableSsl;
    private final boolean enableCompression;
    
    public ConditionalPipelineInitializer(boolean enableSsl, boolean enableCompression) {
        this.enableSsl = enableSsl;
        this.enableCompression = enableCompression;
    }
    
    @Override
    protected void initChannel(SocketChannel ch) {
        ChannelPipeline pipeline = ch.pipeline();
        
        // SSLæ”¯æŒ
        if (enableSsl) {
            SslContext sslContext = createSslContext();
            pipeline.addLast("ssl", sslContext.newHandler(ch.alloc()));
        }
        
        // å‹ç¼©æ”¯æŒ
        if (enableCompression) {
            pipeline.addLast("deflater", ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));
            pipeline.addLast("inflater", ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
        }
        
        // åŸºç¡€ç¼–è§£ç å™¨
        pipeline.addLast("frameDecoder", new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
        pipeline.addLast("frameEncoder", new LengthFieldPrepender(4));
        pipeline.addLast("stringDecoder", new StringDecoder());
        pipeline.addLast("stringEncoder", new StringEncoder());
        
        // ä¸šåŠ¡å¤„ç†å™¨
        pipeline.addLast("businessHandler", new BusinessHandler());
    }
    
    private SslContext createSslContext() {
        // SSLä¸Šä¸‹æ–‡åˆ›å»ºé€»è¾‘
        return null;
    }
}
```

</TabItem>
</Tabs>

### 2.3 ByteBufç¼“å†²åŒº

<Tabs>
<TabItem value="bytebuf-concept" label="ByteBufæ¦‚å¿µ">

**ByteBuf vs ByteBuffer**

| ç‰¹æ€§ | ByteBuf | ByteBuffer | ä¼˜åŠ¿ |
|------|---------|------------|------|
| è¯»å†™æŒ‡é’ˆ | ç‹¬ç«‹çš„è¯»å†™æŒ‡é’ˆ | å•ä¸€positionæŒ‡é’ˆ | ByteBufæ›´çµæ´»ï¼Œæ— éœ€flipæ“ä½œ |
| å®¹é‡æ‰©å±• | æ”¯æŒåŠ¨æ€æ‰©å®¹ | å›ºå®šå®¹é‡ | ByteBufå¯ä»¥æ ¹æ®éœ€è¦è‡ªåŠ¨æ‰©å®¹ |
| å†…å­˜ç®¡ç† | å¼•ç”¨è®¡æ•° | ä¾èµ–GC | ByteBufå¯ä»¥ç²¾ç¡®æ§åˆ¶å†…å­˜é‡Šæ”¾ |
| å†…å­˜ç±»å‹ | å †å†…å­˜/ç›´æ¥å†…å­˜ | å †å†…å­˜/ç›´æ¥å†…å­˜ | ä¸¤è€…éƒ½æ”¯æŒå¤šç§å†…å­˜ç±»å‹ |
| å†…å­˜æ±  | æ”¯æŒå†…å­˜æ±  | ä¸æ”¯æŒ | ByteBufå¯ä»¥å¤ç”¨å†…å­˜ï¼Œå‡å°‘GCå‹åŠ› |
| é›¶æ‹·è´ | æ”¯æŒ | æœ‰é™æ”¯æŒ | ByteBufæä¾›æ›´å¥½çš„é›¶æ‹·è´æ”¯æŒ |
| APIè®¾è®¡ | é“¾å¼è°ƒç”¨ | ä¼ ç»ŸAPI | ByteBuf APIæ›´åŠ å‹å¥½ |
| æ€§èƒ½ | æ›´é«˜ | è¾ƒä½ | ByteBufåœ¨å„æ–¹é¢æ€§èƒ½éƒ½æ›´ä¼˜ |

**ByteBufç»“æ„**
```mermaid
graph LR
    A[0] --> B[readerIndex]
    B --> C[writerIndex]
    C --> D[capacity]
    D --> E[maxCapacity]
    
    F[å¯ä¸¢å¼ƒå­—èŠ‚] --> B
    G[å¯è¯»å­—èŠ‚] --> C
    H[å¯å†™å­—èŠ‚] --> D
    I[å¯æ‰©å±•å­—èŠ‚] --> E
```

</TabItem>
<TabItem value="bytebuf-usage" label="ByteBufä½¿ç”¨">

```java title="ByteBufåŸºæœ¬æ“ä½œ"
import io.netty.buffer.*;

public class ByteBufExample {
    
    public static void main(String[] args) {
        // 1. åˆ›å»ºByteBuf
        ByteBuf buffer = Unpooled.buffer(10); // åˆå§‹å®¹é‡10
        ByteBuf directBuffer = Unpooled.directBuffer(10); // ç›´æ¥å†…å­˜
        ByteBuf pooledBuffer = PooledByteBufAllocator.DEFAULT.buffer(10); // æ± åŒ–
        
        // 2. å†™å…¥æ•°æ®
        buffer.writeInt(100);
        buffer.writeBytes("Hello".getBytes());
        buffer.writeBoolean(true);
        
        System.out.println("å†™å…¥å - å¯è¯»å­—èŠ‚æ•°: " + buffer.readableBytes());
        System.out.println("å†™å…¥å - å¯å†™å­—èŠ‚æ•°: " + buffer.writableBytes());
        
        // 3. è¯»å–æ•°æ®
        int intValue = buffer.readInt();
        byte[] bytes = new byte[5];
        buffer.readBytes(bytes);
        boolean boolValue = buffer.readBoolean();
        
        System.out.println("è¯»å–çš„int: " + intValue);
        System.out.println("è¯»å–çš„å­—ç¬¦ä¸²: " + new String(bytes));
        System.out.println("è¯»å–çš„boolean: " + boolValue);
        
        // 4. æ ‡è®°å’Œé‡ç½®
        buffer.markReaderIndex();
        buffer.readInt(); // è¯»å–ä¸€äº›æ•°æ®
        buffer.resetReaderIndex(); // é‡ç½®åˆ°æ ‡è®°ä½ç½®
        
        // 5. åˆ‡ç‰‡æ“ä½œï¼ˆé›¶æ‹·è´ï¼‰
        ByteBuf slice = buffer.slice(0, 5); // åˆ›å»ºåˆ‡ç‰‡
        ByteBuf duplicate = buffer.duplicate(); // åˆ›å»ºå‰¯æœ¬
        
        // 6. å¼•ç”¨è®¡æ•°
        System.out.println("å¼•ç”¨è®¡æ•°: " + buffer.refCnt());
        buffer.retain(); // å¢åŠ å¼•ç”¨è®¡æ•°
        System.out.println("å¢åŠ åå¼•ç”¨è®¡æ•°: " + buffer.refCnt());
        
        // 7. é‡Šæ”¾å†…å­˜
        buffer.release(); // å‡å°‘å¼•ç”¨è®¡æ•°
        buffer.release(); // å½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œé‡Šæ”¾å†…å­˜
    }
}
```

**ByteBufé«˜çº§æ“ä½œ**
```java title="ByteBufé«˜çº§ç‰¹æ€§"
public class AdvancedByteBufExample {
    
    public static void compositeByteBuf() {
        // ç»„åˆByteBuf - é›¶æ‹·è´åˆå¹¶å¤šä¸ªByteBuf
        CompositeByteBuf composite = Unpooled.compositeBuffer();
        
        ByteBuf header = Unpooled.copiedBuffer("Header", CharsetUtil.UTF_8);
        ByteBuf body = Unpooled.copiedBuffer("Body Content", CharsetUtil.UTF_8);
        
        composite.addComponents(true, header, body);
        
        // å¯ä»¥åƒå•ä¸ªByteBufä¸€æ ·ä½¿ç”¨
        System.out.println("ç»„åˆåå†…å®¹: " + composite.toString(CharsetUtil.UTF_8));
        
        composite.release();
    }
    
    public static void derivedByteBuf() {
        ByteBuf original = Unpooled.copiedBuffer("Hello World", CharsetUtil.UTF_8);
        
        // åˆ‡ç‰‡ - å…±äº«å†…å®¹ï¼Œç‹¬ç«‹ç´¢å¼•
        ByteBuf slice = original.slice(0, 5);
        System.out.println("åˆ‡ç‰‡å†…å®¹: " + slice.toString(CharsetUtil.UTF_8));
        
        // å‰¯æœ¬ - å…±äº«å†…å®¹ï¼Œå…±äº«ç´¢å¼•
        ByteBuf duplicate = original.duplicate();
        
        // æ‹·è´ - ç‹¬ç«‹å†…å®¹å’Œç´¢å¼•
        ByteBuf copy = original.copy();
        
        original.release();
    }
    
    public static void byteBufAllocator() {
        // ä¸åŒçš„åˆ†é…å™¨
        ByteBufAllocator allocator = PooledByteBufAllocator.DEFAULT;
        
        // å †å†…å­˜
        ByteBuf heapBuffer = allocator.heapBuffer(1024);
        
        // ç›´æ¥å†…å­˜
        ByteBuf directBuffer = allocator.directBuffer(1024);
        
        // ç»„åˆç¼“å†²åŒº
        CompositeByteBuf composite = allocator.compositeBuffer();
        
        // æ ¹æ®å¹³å°é€‰æ‹©æœ€ä¼˜ç±»å‹
        ByteBuf buffer = allocator.buffer(1024);
        
        // é‡Šæ”¾èµ„æº
        heapBuffer.release();
        directBuffer.release();
        composite.release();
        buffer.release();
    }
}
```

</TabItem>
<TabItem value="memory-management" label="å†…å­˜ç®¡ç†">

**å¼•ç”¨è®¡æ•°æœºåˆ¶**
```java title="å¼•ç”¨è®¡æ•°æœ€ä½³å®è·µ"
public class ReferenceCountingExample {
    
    public void correctUsage(ChannelHandlerContext ctx, ByteBuf msg) {
        try {
            // å¤„ç†æ¶ˆæ¯
            processMessage(msg);
            
            // ä¼ é€’ç»™ä¸‹ä¸€ä¸ªHandler
            ctx.fireChannelRead(msg.retain()); // å¢åŠ å¼•ç”¨è®¡æ•°
            
        } finally {
            // ç¡®ä¿é‡Šæ”¾
            msg.release();
        }
    }
    
    public void simpleHandlerUsage() {
        // ä½¿ç”¨SimpleChannelInboundHandlerè‡ªåŠ¨ç®¡ç†å¼•ç”¨è®¡æ•°
        class AutoReleaseHandler extends SimpleChannelInboundHandler<ByteBuf> {
            @Override
            protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {
                // æ–¹æ³•ç»“æŸåè‡ªåŠ¨è°ƒç”¨msg.release()
                processMessage(msg);
            }
        }
    }
    
    public void manualManagement() {
        ByteBuf buffer = Unpooled.buffer(1024);
        
        try {
            // ä½¿ç”¨buffer
            buffer.writeInt(42);
            
            // å¦‚æœéœ€è¦ä¼ é€’ç»™å…¶ä»–åœ°æ–¹ä½¿ç”¨
            ByteBuf retained = buffer.retain();
            someAsyncMethod(retained); // å¼‚æ­¥æ–¹æ³•è´Ÿè´£é‡Šæ”¾
            
        } finally {
            // é‡Šæ”¾å½“å‰å¼•ç”¨
            buffer.release();
        }
    }
    
    private void processMessage(ByteBuf msg) {
        // å¤„ç†æ¶ˆæ¯é€»è¾‘
    }
    
    private void someAsyncMethod(ByteBuf buffer) {
        // å¼‚æ­¥å¤„ç†ï¼Œå®Œæˆåéœ€è¦è°ƒç”¨buffer.release()
    }
}
```

**å†…å­˜æ³„æ¼æ£€æµ‹**
```java title="å†…å­˜æ³„æ¼æ£€æµ‹é…ç½®"
// JVMå¯åŠ¨å‚æ•°
// -Dio.netty.leakDetection.level=ADVANCED
// -Dio.netty.leakDetectionTargetRecords=10

public class LeakDetectionExample {
    
    static {
        // ä»£ç ä¸­è®¾ç½®æ£€æµ‹çº§åˆ«
        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);
    }
    
    public void detectLeak() {
        ByteBuf buffer = Unpooled.buffer(1024);
        
        // æ¨¡æ‹Ÿå†…å­˜æ³„æ¼ - å¿˜è®°è°ƒç”¨release()
        buffer.writeInt(42);
        
        // æ­£ç¡®åšæ³•ï¼š
        // buffer.release();
    }
}
```

**å†…å­˜æ± é…ç½®**
```java title="å†…å­˜æ± ä¼˜åŒ–é…ç½®"
// ç³»ç»Ÿå±æ€§é…ç½®
System.setProperty("io.netty.allocator.type", "pooled"); // ä½¿ç”¨æ± åŒ–åˆ†é…å™¨
System.setProperty("io.netty.allocator.directMemoryCacheAlignment", "64"); // ç›´æ¥å†…å­˜å¯¹é½
System.setProperty("io.netty.allocator.pageSize", "8192"); // é¡µå¤§å°
System.setProperty("io.netty.allocator.maxOrder", "11"); // æœ€å¤§å—å¤§å°

// ä»£ç é…ç½®
PooledByteBufAllocator allocator = new PooledByteBufAllocator(
    true,  // preferDirect - ä¼˜å…ˆä½¿ç”¨ç›´æ¥å†…å­˜
    2,     // nHeapArena - å †å†…å­˜åŒºåŸŸæ•°é‡
    2,     // nDirectArena - ç›´æ¥å†…å­˜åŒºåŸŸæ•°é‡
    8192,  // pageSize - é¡µå¤§å°
    11     // maxOrder - æœ€å¤§å—å¤§å°
);
```

</TabItem>
</Tabs>

## 3. ç¼–è§£ç å™¨è¯¦è§£

### 3.1 å†…ç½®ç¼–è§£ç å™¨

<Tabs>
<TabItem value="frame-decoders" label="å¸§è§£ç å™¨">

**è§£å†³ç²˜åŒ…æ‹†åŒ…é—®é¢˜çš„è§£ç å™¨**

```java title="å¸¸ç”¨å¸§è§£ç å™¨"
// 1. å›ºå®šé•¿åº¦å¸§è§£ç å™¨
FixedLengthFrameDecoder fixedDecoder = new FixedLengthFrameDecoder(10);

// 2. åˆ†éš”ç¬¦å¸§è§£ç å™¨
DelimiterBasedFrameDecoder delimiterDecoder = new DelimiterBasedFrameDecoder(
    1024, // æœ€å¤§å¸§é•¿åº¦
    Delimiters.lineDelimiter() // ä½¿ç”¨æ¢è¡Œç¬¦ä½œä¸ºåˆ†éš”ç¬¦
);

// 3. é•¿åº¦å­—æ®µå¸§è§£ç å™¨
LengthFieldBasedFrameDecoder lengthDecoder = new LengthFieldBasedFrameDecoder(
    1024,  // æœ€å¤§å¸§é•¿åº¦
    0,     // é•¿åº¦å­—æ®µåç§»é‡
    4,     // é•¿åº¦å­—æ®µé•¿åº¦
    0,     // é•¿åº¦è°ƒæ•´å€¼
    4      // è·³è¿‡çš„å­—èŠ‚æ•°
);

// 4. è¡Œè§£ç å™¨
LineBasedFrameDecoder lineDecoder = new LineBasedFrameDecoder(1024);
```

**è‡ªå®šä¹‰åè®®è§£ç å™¨**
```java title="è‡ªå®šä¹‰åè®®è§£ç å™¨"
public class CustomProtocolDecoder extends ByteToMessageDecoder {
    
    private static final int HEADER_LENGTH = 8;
    private static final int MAGIC_NUMBER = 0xCAFEBABE;
    
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å­—èŠ‚è¯»å–å¤´éƒ¨
        if (in.readableBytes() < HEADER_LENGTH) {
            return;
        }
        
        // æ ‡è®°è¯»å–ä½ç½®
        in.markReaderIndex();
        
        // è¯»å–é­”æ•°
        int magic = in.readInt();
        if (magic != MAGIC_NUMBER) {
            // é­”æ•°ä¸åŒ¹é…ï¼Œå…³é—­è¿æ¥
            ctx.close();
            return;
        }
        
        // è¯»å–æ¶ˆæ¯é•¿åº¦
        int length = in.readInt();
        
        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å­—èŠ‚è¯»å–å®Œæ•´æ¶ˆæ¯
        if (in.readableBytes() < length) {
            // é‡ç½®è¯»å–ä½ç½®ï¼Œç­‰å¾…æ›´å¤šæ•°æ®
            in.resetReaderIndex();
            return;
        }
        
        // è¯»å–æ¶ˆæ¯ä½“
        ByteBuf messageBody = in.readBytes(length);
        
        // åˆ›å»ºè‡ªå®šä¹‰æ¶ˆæ¯å¯¹è±¡
        CustomMessage message = new CustomMessage(magic, length, messageBody);
        out.add(message);
    }
}

// è‡ªå®šä¹‰æ¶ˆæ¯ç±»
class CustomMessage {
    private final int magic;
    private final int length;
    private final ByteBuf body;
    
    public CustomMessage(int magic, int length, ByteBuf body) {
        this.magic = magic;
        this.length = length;
        this.body = body;
    }
    
    // getteræ–¹æ³•...
}
```

</TabItem>
<TabItem value="codec-examples" label="ç¼–è§£ç å™¨ç¤ºä¾‹">

**å­—ç¬¦ä¸²ç¼–è§£ç å™¨**
```java title="å­—ç¬¦ä¸²ç¼–è§£ç å™¨ä½¿ç”¨"
public class StringCodecExample {
    
    public void setupPipeline(ChannelPipeline pipeline) {
        // å­—ç¬¦ä¸²ç¼–è§£ç å™¨
        pipeline.addLast("stringDecoder", new StringDecoder(CharsetUtil.UTF_8));
        pipeline.addLast("stringEncoder", new StringEncoder(CharsetUtil.UTF_8));
        
        // ä¸šåŠ¡å¤„ç†å™¨
        pipeline.addLast("stringHandler", new SimpleChannelInboundHandler<String>() {
            @Override
            protected void channelRead0(ChannelHandlerContext ctx, String msg) {
                System.out.println("æ”¶åˆ°å­—ç¬¦ä¸²: " + msg);
                ctx.writeAndFlush("Echo: " + msg);
            }
        });
    }
}
```

**JSONç¼–è§£ç å™¨**
```java title="JSONç¼–è§£ç å™¨å®ç°"
public class JsonEncoder extends MessageToByteEncoder<Object> {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
        byte[] jsonBytes = objectMapper.writeValueAsBytes(msg);
        out.writeInt(jsonBytes.length); // å†™å…¥é•¿åº¦
        out.writeBytes(jsonBytes);      // å†™å…¥JSONæ•°æ®
    }
}

public class JsonDecoder extends LengthFieldBasedFrameDecoder {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    private final Class<?> targetClass;
    
    public JsonDecoder(Class<?> targetClass) {
        super(1024, 0, 4, 0, 4); // é•¿åº¦å­—æ®µè§£ç 
        this.targetClass = targetClass;
    }
    
    @Override
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        ByteBuf frame = (ByteBuf) super.decode(ctx, in);
        if (frame == null) {
            return null;
        }
        
        try {
            byte[] jsonBytes = new byte[frame.readableBytes()];
            frame.readBytes(jsonBytes);
            return objectMapper.readValue(jsonBytes, targetClass);
        } finally {
            frame.release();
        }
    }
}
```

**Protobufç¼–è§£ç å™¨**
```java title="Protobufç¼–è§£ç å™¨ä½¿ç”¨"
public class ProtobufCodecExample {
    
    public void setupPipeline(ChannelPipeline pipeline) {
        // Protobufç¼–è§£ç å™¨
        pipeline.addLast("frameDecoder", new ProtobufVarint32FrameDecoder());
        pipeline.addLast("protobufDecoder", new ProtobufDecoder(MessageProto.Message.getDefaultInstance()));
        
        pipeline.addLast("frameEncoder", new ProtobufVarint32LengthFieldPrepender());
        pipeline.addLast("protobufEncoder", new ProtobufEncoder());
        
        // ä¸šåŠ¡å¤„ç†å™¨
        pipeline.addLast("protobufHandler", new SimpleChannelInboundHandler<MessageProto.Message>() {
            @Override
            protected void channelRead0(ChannelHandlerContext ctx, MessageProto.Message msg) {
                System.out.println("æ”¶åˆ°Protobufæ¶ˆæ¯: " + msg.getContent());
                
                MessageProto.Message response = MessageProto.Message.newBuilder()
                    .setContent("Echo: " + msg.getContent())
                    .build();
                
                ctx.writeAndFlush(response);
            }
        });
    }
}
```

</TabItem>
<TabItem value="custom-codec" label="è‡ªå®šä¹‰ç¼–è§£ç å™¨">

**å®Œæ•´çš„è‡ªå®šä¹‰åè®®å®ç°**
```java title="è‡ªå®šä¹‰åè®®å®Œæ•´å®ç°"
// åè®®æ ¼å¼ï¼šé­”æ•°(4) + ç‰ˆæœ¬(1) + ç±»å‹(1) + é•¿åº¦(4) + æ•°æ®(N)
public class CustomProtocol {
    public static final int MAGIC_NUMBER = 0xABCDEF00;
    public static final byte VERSION = 1;
    
    public static class Message {
        private byte version;
        private byte type;
        private byte[] data;
        
        // æ„é€ å‡½æ•°å’Œgetter/setter...
    }
}

// ç¼–ç å™¨
public class CustomProtocolEncoder extends MessageToByteEncoder<CustomProtocol.Message> {
    
    @Override
    protected void encode(ChannelHandlerContext ctx, CustomProtocol.Message msg, ByteBuf out) {
        out.writeInt(CustomProtocol.MAGIC_NUMBER);  // é­”æ•°
        out.writeByte(msg.getVersion());            // ç‰ˆæœ¬
        out.writeByte(msg.getType());               // ç±»å‹
        out.writeInt(msg.getData().length);         // æ•°æ®é•¿åº¦
        out.writeBytes(msg.getData());              // æ•°æ®
    }
}

// è§£ç å™¨
public class CustomProtocolDecoder extends ByteToMessageDecoder {
    
    private static final int HEADER_LENGTH = 10; // 4 + 1 + 1 + 4
    
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        if (in.readableBytes() < HEADER_LENGTH) {
            return;
        }
        
        in.markReaderIndex();
        
        // éªŒè¯é­”æ•°
        int magic = in.readInt();
        if (magic != CustomProtocol.MAGIC_NUMBER) {
            in.resetReaderIndex();
            ctx.close();
            return;
        }
        
        byte version = in.readByte();
        byte type = in.readByte();
        int dataLength = in.readInt();
        
        // æ£€æŸ¥æ•°æ®æ˜¯å¦å®Œæ•´
        if (in.readableBytes() < dataLength) {
            in.resetReaderIndex();
            return;
        }
        
        // è¯»å–æ•°æ®
        byte[] data = new byte[dataLength];
        in.readBytes(data);
        
        // åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
        CustomProtocol.Message message = new CustomProtocol.Message();
        message.setVersion(version);
        message.setType(type);
        message.setData(data);
        
        out.add(message);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class CustomProtocolServer {
    
    public void start() throws InterruptedException {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ChannelPipeline pipeline = ch.pipeline();
                            
                            // æ·»åŠ è‡ªå®šä¹‰ç¼–è§£ç å™¨
                            pipeline.addLast("decoder", new CustomProtocolDecoder());
                            pipeline.addLast("encoder", new CustomProtocolEncoder());
                            
                            // æ·»åŠ ä¸šåŠ¡å¤„ç†å™¨
                            pipeline.addLast("handler", new CustomProtocolHandler());
                        }
                    });
            
            ChannelFuture future = bootstrap.bind(8080).sync();
            future.channel().closeFuture().sync();
            
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

</TabItem>
</Tabs>

## 4. å¸¸è§é¢è¯•é—®é¢˜ä¸è§£ç­”

### 4.1 åŸºç¡€æ¦‚å¿µé—®é¢˜

<Tabs>
<TabItem value="basic-qa" label="åŸºç¡€é—®ç­”">

**Q1: Nettyçš„æ ¸å¿ƒç»„ä»¶æœ‰å“ªäº›ï¼Ÿå®ƒä»¬çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ**

A: Nettyçš„æ ¸å¿ƒç»„ä»¶åŒ…æ‹¬ï¼š
- **Bootstrap/ServerBootstrap**ï¼šå¯åŠ¨å™¨ï¼Œç”¨äºé…ç½®å’Œå¯åŠ¨å®¢æˆ·ç«¯/æœåŠ¡ç«¯
- **EventLoopGroup**ï¼šäº‹ä»¶å¾ªç¯ç»„ï¼Œç®¡ç†EventLoopçš„ç”Ÿå‘½å‘¨æœŸ
- **EventLoop**ï¼šäº‹ä»¶å¾ªç¯ï¼Œå¤„ç†IOäº‹ä»¶å’Œä»»åŠ¡
- **Channel**ï¼šç½‘ç»œé€šé“ï¼Œä»£è¡¨ä¸€ä¸ªç½‘ç»œè¿æ¥
- **ChannelPipeline**ï¼šå¤„ç†é“¾ï¼Œç®¡ç†ChannelHandlerçš„æ‰§è¡Œé¡ºåº
- **ChannelHandler**ï¼šå¤„ç†å™¨ï¼Œå¤„ç†IOäº‹ä»¶å’Œä¸šåŠ¡é€»è¾‘
- **ByteBuf**ï¼šç¼“å†²åŒºï¼ŒNettyçš„æ•°æ®å®¹å™¨

**Q2: Nettyçš„çº¿ç¨‹æ¨¡å‹æ˜¯æ€æ ·çš„ï¼Ÿ**

A: Nettyé‡‡ç”¨Reactorçº¿ç¨‹æ¨¡å‹ï¼š
- **BossGroup**ï¼šè´Ÿè´£æ¥å—å®¢æˆ·ç«¯è¿æ¥ï¼Œé€šå¸¸åªéœ€è¦1ä¸ªçº¿ç¨‹
- **WorkerGroup**ï¼šè´Ÿè´£å¤„ç†IOè¯»å†™ï¼Œçº¿ç¨‹æ•°é€šå¸¸ä¸ºCPUæ ¸å¿ƒæ•°çš„1-2å€
- **EventLoop**ï¼šå•çº¿ç¨‹æ‰§è¡Œå™¨ï¼Œä¸€ä¸ªEventLoopå¯ä»¥å¤„ç†å¤šä¸ªChannel
- **çº¿ç¨‹å®‰å…¨**ï¼šåŒä¸€ä¸ªChannelçš„æ‰€æœ‰æ“ä½œéƒ½åœ¨åŒä¸€ä¸ªEventLoopä¸­æ‰§è¡Œ

**Q3: ByteBufç›¸æ¯”ByteBufferæœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ**

A: ByteBufçš„ä¸»è¦ä¼˜åŠ¿ï¼š
- **ç‹¬ç«‹çš„è¯»å†™æŒ‡é’ˆ**ï¼šæ— éœ€flipæ“ä½œï¼Œä½¿ç”¨æ›´ç®€å•
- **åŠ¨æ€æ‰©å®¹**ï¼šå¯ä»¥æ ¹æ®éœ€è¦è‡ªåŠ¨æ‰©å±•å®¹é‡
- **å¼•ç”¨è®¡æ•°**ï¼šç²¾ç¡®æ§åˆ¶å†…å­˜é‡Šæ”¾ï¼Œé¿å…å†…å­˜æ³„æ¼
- **å†…å­˜æ± **ï¼šæ”¯æŒå†…å­˜æ± åŒ–ï¼Œå‡å°‘GCå‹åŠ›
- **é›¶æ‹·è´**ï¼šæä¾›æ›´å¥½çš„é›¶æ‹·è´æ”¯æŒ
- **é“¾å¼API**ï¼šæ›´å‹å¥½çš„APIè®¾è®¡

</TabItem>
<TabItem value="advanced-qa" label="æ·±å…¥é—®ç­”">

**Q4: Nettyæ˜¯å¦‚ä½•è§£å†³ç²˜åŒ…æ‹†åŒ…é—®é¢˜çš„ï¼Ÿ**

A: Nettyæä¾›äº†å¤šç§è§£å†³æ–¹æ¡ˆï¼š
1. **å›ºå®šé•¿åº¦**ï¼šFixedLengthFrameDecoder
2. **åˆ†éš”ç¬¦**ï¼šDelimiterBasedFrameDecoder
3. **é•¿åº¦å­—æ®µ**ï¼šLengthFieldBasedFrameDecoder
4. **è‡ªå®šä¹‰åè®®**ï¼šç»§æ‰¿ByteToMessageDecoderå®ç°

**Q5: Nettyçš„é›¶æ‹·è´æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ**

A: Nettyçš„é›¶æ‹·è´å®ç°ï¼š
- **DirectByteBuffer**ï¼šä½¿ç”¨ç›´æ¥å†…å­˜ï¼Œé¿å…ç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„æ•°æ®æ‹·è´
- **CompositeByteBuf**ï¼šç»„åˆå¤šä¸ªByteBufï¼Œé¿å…å†…å­˜æ‹·è´
- **slice()å’Œduplicate()**ï¼šåˆ›å»ºè§†å›¾ï¼Œå…±äº«åº•å±‚æ•°æ®
- **FileRegion**ï¼šæ–‡ä»¶ä¼ è¾“æ—¶ä½¿ç”¨sendfileç³»ç»Ÿè°ƒç”¨

**Q6: å¦‚ä½•å¤„ç†Nettyä¸­çš„å†…å­˜æ³„æ¼ï¼Ÿ**

A: å†…å­˜æ³„æ¼å¤„ç†ç­–ç•¥ï¼š
- **å¼•ç”¨è®¡æ•°**ï¼šæ­£ç¡®ä½¿ç”¨retain()å’Œrelease()
- **SimpleChannelInboundHandler**ï¼šè‡ªåŠ¨ç®¡ç†å¼•ç”¨è®¡æ•°
- **å†…å­˜æ³„æ¼æ£€æµ‹**ï¼šå¯ç”¨ResourceLeakDetector
- **æœ€ä½³å®è·µ**ï¼šåœ¨finallyå—ä¸­é‡Šæ”¾èµ„æº

</TabItem>
</Tabs>

### 4.2 å®é™…åº”ç”¨é—®é¢˜

**Nettyç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ**

1. **çº¿ç¨‹é…ç½®**
   - BossGroupçº¿ç¨‹æ•°ï¼š1ä¸ªå³å¯
   - WorkerGroupçº¿ç¨‹æ•°ï¼šCPUæ ¸å¿ƒæ•°çš„1-2å€
   - ä¸šåŠ¡å¤„ç†ä½¿ç”¨ç‹¬ç«‹çº¿ç¨‹æ± 

2. **å†…å­˜ç®¡ç†**
   - å¯ç”¨å†…å­˜æ± ï¼šPooledByteBufAllocator
   - è®¾ç½®åˆç†çš„æ°´ä½çº¿
   - ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ

3. **æ€§èƒ½ä¼˜åŒ–**
   - ä½¿ç”¨ç›´æ¥å†…å­˜
   - åˆç†è®¾ç½®Channelé€‰é¡¹
   - å¯ç”¨TCP_NODELAY
   - è®¾ç½®åˆé€‚çš„ç¼“å†²åŒºå¤§å°

4. **ç›‘æ§å’Œè°ƒè¯•**
   - å¯ç”¨å†…å­˜æ³„æ¼æ£€æµ‹
   - ç›‘æ§è¿æ¥æ•°å’Œååé‡
   - è®°å½•å…³é”®äº‹ä»¶æ—¥å¿—

é€šè¿‡æ·±å…¥ç†è§£Nettyæ¡†æ¶ï¼Œä½ å°†èƒ½å¤Ÿï¼š
- æ„å»ºé«˜æ€§èƒ½çš„ç½‘ç»œåº”ç”¨
- è§£å†³å¤æ‚çš„ç½‘ç»œç¼–ç¨‹é—®é¢˜
- ä¼˜åŒ–ç½‘ç»œåº”ç”¨çš„æ€§èƒ½å’Œç¨³å®šæ€§
- è®¾è®¡å¯æ‰©å±•çš„åˆ†å¸ƒå¼ç³»ç»Ÿæ¶æ„
