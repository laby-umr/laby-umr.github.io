---
sidebar_position: 4
title: Socketç½‘ç»œç¼–ç¨‹è¯¦è§£
description: æ·±å…¥ç†è§£Java Socketç¼–ç¨‹ã€BIO/NIO/AIOæ¨¡å‹ã€å¤šè·¯å¤ç”¨ä¸é«˜å¹¶å‘ç½‘ç»œç¼–ç¨‹å®è·µ
authors: [Laby]
tags: [Socket, BIO, NIO, AIO, ç½‘ç»œç¼–ç¨‹, å¤šè·¯å¤ç”¨, é«˜å¹¶å‘]
last_update:
  date: 2025-08-15
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Socketç½‘ç»œç¼–ç¨‹è¯¦è§£

Socketæ˜¯ç½‘ç»œç¼–ç¨‹çš„åŸºç¡€ï¼Œæä¾›äº†è¿›ç¨‹é—´ç½‘ç»œé€šä¿¡çš„æ¥å£ã€‚ç†è§£ä¸åŒçš„IOæ¨¡å‹å¯¹äºæ„å»ºé«˜æ€§èƒ½ç½‘ç»œåº”ç”¨è‡³å…³é‡è¦ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**Socketç¼–ç¨‹ = ç½‘ç»œé€šä¿¡åŸºç¡€ + IOæ¨¡å‹é€‰æ‹© + æ€§èƒ½ä¼˜åŒ– + å¹¶å‘å¤„ç†**
- ğŸ”Œ **é€šä¿¡åŸºç¡€**ï¼šTCP/UDP Socketæä¾›ç½‘ç»œé€šä¿¡èƒ½åŠ›
- âš¡ **IOæ¨¡å‹**ï¼šBIOã€NIOã€AIOé€‚åº”ä¸åŒå¹¶å‘éœ€æ±‚
- ğŸš€ **é«˜æ€§èƒ½**ï¼šå¤šè·¯å¤ç”¨ã€é›¶æ‹·è´ã€ç›´æ¥å†…å­˜ä¼˜åŒ–
- ğŸ¯ **å¹¶å‘å¤„ç†**ï¼šçº¿ç¨‹æ¨¡å‹ã€äº‹ä»¶é©±åŠ¨ã€å¼‚æ­¥å›è°ƒ
- ğŸ› ï¸ **å®ç”¨æŠ€å·§**ï¼šç²˜åŒ…æ‹†åŒ…ã€è¿æ¥ç®¡ç†ã€å¼‚å¸¸å¤„ç†
:::

## 1. Socketç¼–ç¨‹åŸºç¡€

### 1.1 Socketæ¦‚å¿µä¸åˆ†ç±»

```mermaid
graph TB
    A[Socketå¥—æ¥å­—] --> B[TCP Socket]
    A --> C[UDP Socket]
    
    B --> B1[é¢å‘è¿æ¥]
    B --> B2[å¯é ä¼ è¾“]
    B --> B3[æµå¼æ•°æ®]
    
    C --> C1[æ— è¿æ¥]
    C --> C2[ä¸å¯é ä¼ è¾“]
    C --> C3[æ•°æ®æŠ¥]
    
    D[Socket API] --> E[æœåŠ¡ç«¯API]
    D --> F[å®¢æˆ·ç«¯API]
    
    E --> E1[socket()]
    E --> E2[bind()]
    E --> E3[listen()]
    E --> E4[accept()]
    
    F --> F1[socket()]
    F --> F2[connect()]
    F --> F3[send()/recv()]
    F --> F4[close()]
```

### 1.2 TCP Socketé€šä¿¡æµç¨‹

```mermaid
sequenceDiagram
    participant S as æœåŠ¡ç«¯
    participant C as å®¢æˆ·ç«¯
    
    Note over S: socket() åˆ›å»ºå¥—æ¥å­—
    Note over S: bind() ç»‘å®šåœ°å€
    Note over S: listen() ç›‘å¬è¿æ¥
    
    Note over C: socket() åˆ›å»ºå¥—æ¥å­—
    C->>S: connect() è¿æ¥è¯·æ±‚
    S->>C: accept() æ¥å—è¿æ¥
    
    Note over S,C: è¿æ¥å»ºç«‹æˆåŠŸ
    
    C->>S: send() å‘é€æ•°æ®
    S->>C: recv() æ¥æ”¶æ•°æ®
    S->>C: send() å‘é€å“åº”
    C->>S: recv() æ¥æ”¶å“åº”
    
    Note over S,C: æ•°æ®ä¼ è¾“
    
    C->>S: close() å…³é—­è¿æ¥
    Note over S: close() å…³é—­è¿æ¥
```

## 2. Java IOæ¨¡å‹è¯¦è§£

### 2.1 IOæ¨¡å‹å¯¹æ¯”

| ç‰¹æ€§ | BIO | NIO | AIO | é€‚ç”¨åœºæ™¯ |
|------|-----|-----|-----|----------|
| é˜»å¡æ€§ | é˜»å¡ | éé˜»å¡ | å¼‚æ­¥ | BIOé€‚åˆè¿æ¥æ•°å°‘ï¼ŒNIOé€‚åˆé«˜å¹¶å‘ï¼ŒAIOé€‚åˆå¼‚æ­¥å¤„ç† |
| çº¿ç¨‹æ¨¡å‹ | ä¸€è¿æ¥ä¸€çº¿ç¨‹ | ä¸€çº¿ç¨‹å¤šè¿æ¥ | å›è°ƒå¤„ç† | BIOç®€å•ä½†èµ„æºæ¶ˆè€—å¤§ |
| å†…å­˜æ‹·è´ | å¤šæ¬¡æ‹·è´ | é›¶æ‹·è´ | é›¶æ‹·è´ | NIO/AIOæ€§èƒ½æ›´å¥½ |
| ç¼–ç¨‹å¤æ‚åº¦ | ç®€å• | å¤æ‚ | ä¸­ç­‰ | BIOæœ€ç®€å•ï¼ŒNIOæœ€å¤æ‚ |
| ååé‡ | ä½ | é«˜ | é«˜ | NIO/AIOé€‚åˆé«˜åååœºæ™¯ |
| å»¶è¿Ÿ | é«˜ | ä½ | ä½ | NIO/AIOå»¶è¿Ÿæ›´ä½ |

### 2.2 BIOï¼ˆé˜»å¡IOï¼‰ç¼–ç¨‹

<Tabs>
<TabItem value="bio-server" label="BIOæœåŠ¡ç«¯">

```java title="BIOæœåŠ¡ç«¯å®ç°"
import java.io.*;
import java.net.*;
import java.util.concurrent.*;

public class BIOServer {
    private final int port;
    private final ExecutorService threadPool;
    
    public BIOServer(int port) {
        this.port = port;
        // ä½¿ç”¨çº¿ç¨‹æ± é¿å…æ— é™åˆ›å»ºçº¿ç¨‹
        this.threadPool = Executors.newFixedThreadPool(100);
    }
    
    public void start() throws IOException {
        ServerSocket serverSocket = new ServerSocket(port);
        System.out.println("BIOæœåŠ¡å™¨å¯åŠ¨ï¼Œç›‘å¬ç«¯å£: " + port);
        
        try {
            while (!Thread.currentThread().isInterrupted()) {
                // accept()æ–¹æ³•é˜»å¡ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥
                Socket clientSocket = serverSocket.accept();
                
                // ä¸ºæ¯ä¸ªè¿æ¥åˆ†é…çº¿ç¨‹å¤„ç†
                threadPool.submit(new ClientHandler(clientSocket));
            }
        } finally {
            serverSocket.close();
            threadPool.shutdown();
        }
    }
    
    /**
     * å®¢æˆ·ç«¯è¿æ¥å¤„ç†å™¨
     */
    private static class ClientHandler implements Runnable {
        private final Socket socket;
        
        public ClientHandler(Socket socket) {
            this.socket = socket;
        }
        
        @Override
        public void run() {
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(socket.getInputStream()));
                 PrintWriter writer = new PrintWriter(
                    socket.getOutputStream(), true)) {
                
                String inputLine;
                // è¯»å–å®¢æˆ·ç«¯æ•°æ®ï¼ˆé˜»å¡æ“ä½œï¼‰
                while ((inputLine = reader.readLine()) != null) {
                    System.out.println("æ”¶åˆ°æ¶ˆæ¯: " + inputLine);
                    
                    // å›æ˜¾æ¶ˆæ¯
                    writer.println("Echo: " + inputLine);
                    
                    // å¦‚æœæ”¶åˆ°"bye"åˆ™æ–­å¼€è¿æ¥
                    if ("bye".equalsIgnoreCase(inputLine)) {
                        break;
                    }
                }
            } catch (IOException e) {
                System.err.println("å¤„ç†å®¢æˆ·ç«¯è¿æ¥å¼‚å¸¸: " + e.getMessage());
            } finally {
                try {
                    socket.close();
                } catch (IOException e) {
                    System.err.println("å…³é—­è¿æ¥å¼‚å¸¸: " + e.getMessage());
                }
            }
        }
    }
    
    public static void main(String[] args) throws IOException {
        new BIOServer(8080).start();
    }
}
```

**BIOå®¢æˆ·ç«¯å®ç°**
```java title="BIOå®¢æˆ·ç«¯å®ç°"
public class BIOClient {
    public static void main(String[] args) {
        try (Socket socket = new Socket("localhost", 8080);
             BufferedReader reader = new BufferedReader(
                new InputStreamReader(socket.getInputStream()));
             PrintWriter writer = new PrintWriter(
                socket.getOutputStream(), true);
             Scanner scanner = new Scanner(System.in)) {
            
            System.out.println("è¿æ¥åˆ°æœåŠ¡å™¨æˆåŠŸï¼è¾“å…¥æ¶ˆæ¯ï¼ˆè¾“å…¥'bye'é€€å‡ºï¼‰:");
            
            String userInput;
            while ((userInput = scanner.nextLine()) != null) {
                // å‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
                writer.println(userInput);
                
                // è¯»å–æœåŠ¡å™¨å“åº”
                String response = reader.readLine();
                System.out.println("æœåŠ¡å™¨å“åº”: " + response);
                
                if ("bye".equalsIgnoreCase(userInput)) {
                    break;
                }
            }
        } catch (IOException e) {
            System.err.println("å®¢æˆ·ç«¯å¼‚å¸¸: " + e.getMessage());
        }
    }
}
```

</TabItem>
<TabItem value="bio-analysis" label="BIOç‰¹ç‚¹åˆ†æ">

**BIOä¼˜ç‚¹**
- **ç¼–ç¨‹ç®€å•**ï¼šåŒæ­¥é˜»å¡æ¨¡å‹ï¼Œé€»è¾‘æ¸…æ™°
- **æ˜“äºç†è§£**ï¼šä¸€ä¸ªè¿æ¥ä¸€ä¸ªçº¿ç¨‹ï¼Œæ¦‚å¿µç›´è§‚
- **è°ƒè¯•æ–¹ä¾¿**ï¼šçº¿æ€§æ‰§è¡Œæµç¨‹ï¼Œä¾¿äºè°ƒè¯•

**BIOç¼ºç‚¹**
- **èµ„æºæ¶ˆè€—å¤§**ï¼šæ¯ä¸ªè¿æ¥éœ€è¦ä¸€ä¸ªçº¿ç¨‹
- **æ‰©å±•æ€§å·®**ï¼šçº¿ç¨‹æ•°é‡é™åˆ¶äº†å¹¶å‘è¿æ¥æ•°
- **ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€**ï¼šå¤§é‡çº¿ç¨‹å¯¼è‡´é¢‘ç¹åˆ‡æ¢

**BIOé€‚ç”¨åœºæ™¯**
- è¿æ¥æ•°è¾ƒå°‘ï¼ˆ< 1000ï¼‰
- è¿æ¥æ—¶é—´è¾ƒé•¿
- å¯¹å®æ—¶æ€§è¦æ±‚ä¸é«˜
- ç®€å•çš„è¯·æ±‚-å“åº”æ¨¡å¼

**æ€§èƒ½ç“¶é¢ˆåˆ†æ**
```java
// çº¿ç¨‹èµ„æºè®¡ç®—
int maxConnections = 1000;           // æœ€å¤§è¿æ¥æ•°
int threadStackSize = 1024 * 1024;  // æ¯ä¸ªçº¿ç¨‹æ ˆå¤§å° 1MB
long totalMemory = maxConnections * threadStackSize; // æ€»å†…å­˜æ¶ˆè€—

System.out.println("1000ä¸ªè¿æ¥éœ€è¦å†…å­˜: " + totalMemory / 1024 / 1024 + "MB");
// è¾“å‡º: 1000ä¸ªè¿æ¥éœ€è¦å†…å­˜: 1000MB
```

</TabItem>
</Tabs>

### 2.3 NIOï¼ˆéé˜»å¡IOï¼‰ç¼–ç¨‹

<Tabs>
<TabItem value="nio-server" label="NIOæœåŠ¡ç«¯">

```java title="NIOæœåŠ¡ç«¯å®ç°"
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NIOServer {
    private final int port;
    private Selector selector;
    private ServerSocketChannel serverChannel;
    
    public NIOServer(int port) {
        this.port = port;
    }
    
    public void start() throws IOException {
        // åˆ›å»ºé€‰æ‹©å™¨
        selector = Selector.open();
        
        // åˆ›å»ºæœåŠ¡ç«¯é€šé“
        serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false); // è®¾ç½®éé˜»å¡
        serverChannel.bind(new InetSocketAddress(port));
        
        // æ³¨å†Œæ¥å—è¿æ¥äº‹ä»¶
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        System.out.println("NIOæœåŠ¡å™¨å¯åŠ¨ï¼Œç›‘å¬ç«¯å£: " + port);
        
        // äº‹ä»¶å¾ªç¯
        while (true) {
            // é˜»å¡ç­‰å¾…äº‹ä»¶å‘ç”Ÿ
            int readyChannels = selector.select();
            
            if (readyChannels == 0) {
                continue;
            }
            
            // è·å–å°±ç»ªçš„äº‹ä»¶é›†åˆ
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
            
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                keyIterator.remove(); // å¿…é¡»æ‰‹åŠ¨ç§»é™¤
                
                try {
                    handleKey(key);
                } catch (IOException e) {
                    System.err.println("å¤„ç†äº‹ä»¶å¼‚å¸¸: " + e.getMessage());
                    closeChannel(key);
                }
            }
        }
    }
    
    /**
     * å¤„ç†é€‰æ‹©é”®äº‹ä»¶
     */
    private void handleKey(SelectionKey key) throws IOException {
        if (key.isAcceptable()) {
            // å¤„ç†è¿æ¥äº‹ä»¶
            handleAccept(key);
        } else if (key.isReadable()) {
            // å¤„ç†è¯»äº‹ä»¶
            handleRead(key);
        } else if (key.isWritable()) {
            // å¤„ç†å†™äº‹ä»¶
            handleWrite(key);
        }
    }
    
    /**
     * å¤„ç†å®¢æˆ·ç«¯è¿æ¥
     */
    private void handleAccept(SelectionKey key) throws IOException {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept();
        
        if (clientChannel != null) {
            clientChannel.configureBlocking(false);
            
            // æ³¨å†Œè¯»äº‹ä»¶
            SelectionKey clientKey = clientChannel.register(
                selector, SelectionKey.OP_READ);
            
            // ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯åˆ†é…ç¼“å†²åŒº
            clientKey.attach(ByteBuffer.allocate(1024));
            
            System.out.println("æ–°å®¢æˆ·ç«¯è¿æ¥: " + 
                clientChannel.getRemoteAddress());
        }
    }
    
    /**
     * å¤„ç†è¯»äº‹ä»¶
     */
    private void handleRead(SelectionKey key) throws IOException {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();
        
        int bytesRead = clientChannel.read(buffer);
        
        if (bytesRead > 0) {
            buffer.flip(); // åˆ‡æ¢åˆ°è¯»æ¨¡å¼
            
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);
            String message = new String(data, "UTF-8");
            
            System.out.println("æ”¶åˆ°æ¶ˆæ¯: " + message);
            
            // å‡†å¤‡å›å†™æ•°æ®
            String response = "Echo: " + message;
            ByteBuffer writeBuffer = ByteBuffer.wrap(response.getBytes("UTF-8"));
            key.attach(writeBuffer);
            
            // æ³¨å†Œå†™äº‹ä»¶
            key.interestOps(SelectionKey.OP_WRITE);
            
        } else if (bytesRead < 0) {
            // å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
            System.out.println("å®¢æˆ·ç«¯æ–­å¼€è¿æ¥: " + 
                clientChannel.getRemoteAddress());
            closeChannel(key);
        }
    }
    
    /**
     * å¤„ç†å†™äº‹ä»¶
     */
    private void handleWrite(SelectionKey key) throws IOException {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();
        
        clientChannel.write(buffer);
        
        if (!buffer.hasRemaining()) {
            // å†™å®Œæˆï¼Œé‡æ–°æ³¨å†Œè¯»äº‹ä»¶
            key.attach(ByteBuffer.allocate(1024));
            key.interestOps(SelectionKey.OP_READ);
        }
    }
    
    /**
     * å…³é—­é€šé“
     */
    private void closeChannel(SelectionKey key) {
        try {
            key.channel().close();
        } catch (IOException e) {
            System.err.println("å…³é—­é€šé“å¼‚å¸¸: " + e.getMessage());
        }
        key.cancel();
    }
    
    public static void main(String[] args) throws IOException {
        new NIOServer(8080).start();
    }
}
```

</TabItem>
<TabItem value="nio-client" label="NIOå®¢æˆ·ç«¯">

```java title="NIOå®¢æˆ·ç«¯å®ç°"
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Scanner;

public class NIOClient {
    private SocketChannel socketChannel;
    private ByteBuffer buffer = ByteBuffer.allocate(1024);
    
    public void connect(String host, int port) throws IOException {
        socketChannel = SocketChannel.open();
        socketChannel.connect(new InetSocketAddress(host, port));
        
        System.out.println("è¿æ¥åˆ°æœåŠ¡å™¨: " + host + ":" + port);
    }
    
    public void sendMessage(String message) throws IOException {
        buffer.clear();
        buffer.put(message.getBytes("UTF-8"));
        buffer.flip();
        
        while (buffer.hasRemaining()) {
            socketChannel.write(buffer);
        }
    }
    
    public String receiveMessage() throws IOException {
        buffer.clear();
        int bytesRead = socketChannel.read(buffer);
        
        if (bytesRead > 0) {
            buffer.flip();
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);
            return new String(data, "UTF-8");
        }
        
        return null;
    }
    
    public void close() throws IOException {
        if (socketChannel != null) {
            socketChannel.close();
        }
    }
    
    public static void main(String[] args) {
        NIOClient client = new NIOClient();
        
        try {
            client.connect("localhost", 8080);
            
            Scanner scanner = new Scanner(System.in);
            System.out.println("è¾“å…¥æ¶ˆæ¯ï¼ˆè¾“å…¥'bye'é€€å‡ºï¼‰:");
            
            String userInput;
            while ((userInput = scanner.nextLine()) != null) {
                client.sendMessage(userInput);
                
                String response = client.receiveMessage();
                System.out.println("æœåŠ¡å™¨å“åº”: " + response);
                
                if ("bye".equalsIgnoreCase(userInput)) {
                    break;
                }
            }
        } catch (IOException e) {
            System.err.println("å®¢æˆ·ç«¯å¼‚å¸¸: " + e.getMessage());
        } finally {
            try {
                client.close();
            } catch (IOException e) {
                System.err.println("å…³é—­è¿æ¥å¼‚å¸¸: " + e.getMessage());
            }
        }
    }
}
```

</TabItem>
<TabItem value="selector-principle" label="SelectoråŸç†">

**Selectorå·¥ä½œåŸç†**

```mermaid
graph TB
    A[Selectoré€‰æ‹©å™¨] --> B[Channel1]
    A --> C[Channel2]
    A --> D[Channel3]
    A --> E[ChannelN]
    
    B --> B1[OP_READ]
    B --> B2[OP_WRITE]
    C --> C1[OP_ACCEPT]
    D --> D1[OP_CONNECT]
    E --> E1[OP_READ]
    
    F[select()æ–¹æ³•] --> G[é˜»å¡ç­‰å¾…äº‹ä»¶]
    G --> H[è¿”å›å°±ç»ªé€šé“æ•°]
    H --> I[å¤„ç†å°±ç»ªäº‹ä»¶]
```

**Selectoræ ¸å¿ƒæ¦‚å¿µ**
- **Channelï¼ˆé€šé“ï¼‰**ï¼šæ•°æ®ä¼ è¾“çš„ç®¡é“
- **Bufferï¼ˆç¼“å†²åŒºï¼‰**ï¼šæ•°æ®è¯»å†™çš„å®¹å™¨
- **Selectorï¼ˆé€‰æ‹©å™¨ï¼‰**ï¼šç›‘æ§å¤šä¸ªé€šé“çš„äº‹ä»¶
- **SelectionKeyï¼ˆé€‰æ‹©é”®ï¼‰**ï¼šé€šé“å’Œé€‰æ‹©å™¨çš„å…³ç³»

**äº‹ä»¶ç±»å‹**
```java
// å››ç§åŸºæœ¬äº‹ä»¶ç±»å‹
SelectionKey.OP_READ     // è¯»äº‹ä»¶ï¼šé€šé“æœ‰æ•°æ®å¯è¯»
SelectionKey.OP_WRITE    // å†™äº‹ä»¶ï¼šé€šé“å¯ä»¥å†™å…¥æ•°æ®
SelectionKey.OP_ACCEPT   // æ¥å—äº‹ä»¶ï¼šæœåŠ¡ç«¯æ¥å—å®¢æˆ·ç«¯è¿æ¥
SelectionKey.OP_CONNECT  // è¿æ¥äº‹ä»¶ï¼šå®¢æˆ·ç«¯è¿æ¥å®Œæˆ

// ç»„åˆäº‹ä»¶
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
```

**NIOä¼˜åŠ¿**
- **å•çº¿ç¨‹å¤„ç†å¤šè¿æ¥**ï¼šä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤„ç†æ•°åƒä¸ªè¿æ¥
- **å†…å­˜æ•ˆç‡é«˜**ï¼šé¿å…ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»ºçº¿ç¨‹
- **é›¶æ‹·è´**ï¼šDirectByteBufferå‡å°‘å†…å­˜æ‹·è´
- **äº‹ä»¶é©±åŠ¨**ï¼šåªå¤„ç†å°±ç»ªçš„é€šé“

</TabItem>
</Tabs>

### 2.4 AIOï¼ˆå¼‚æ­¥IOï¼‰ç¼–ç¨‹

<Tabs>
<TabItem value="aio-server" label="AIOæœåŠ¡ç«¯">

```java title="AIOæœåŠ¡ç«¯å®ç°"
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.CountDownLatch;

public class AIOServer {
    private final int port;
    private AsynchronousServerSocketChannel serverChannel;
    
    public AIOServer(int port) {
        this.port = port;
    }
    
    public void start() throws IOException, InterruptedException {
        // åˆ›å»ºå¼‚æ­¥æœåŠ¡ç«¯é€šé“
        serverChannel = AsynchronousServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(port));
        
        System.out.println("AIOæœåŠ¡å™¨å¯åŠ¨ï¼Œç›‘å¬ç«¯å£: " + port);
        
        // å¼€å§‹æ¥å—è¿æ¥
        serverChannel.accept(null, new AcceptHandler());
        
        // ä¿æŒä¸»çº¿ç¨‹è¿è¡Œ
        CountDownLatch latch = new CountDownLatch(1);
        latch.await();
    }
    
    /**
     * è¿æ¥æ¥å—å¤„ç†å™¨
     */
    private class AcceptHandler implements 
            CompletionHandler<AsynchronousSocketChannel, Void> {
        
        @Override
        public void completed(AsynchronousSocketChannel clientChannel, Void attachment) {
            // ç»§ç»­æ¥å—ä¸‹ä¸€ä¸ªè¿æ¥
            serverChannel.accept(null, this);
            
            try {
                System.out.println("æ–°å®¢æˆ·ç«¯è¿æ¥: " + 
                    clientChannel.getRemoteAddress());
                
                // å¼€å§‹è¯»å–å®¢æˆ·ç«¯æ•°æ®
                ByteBuffer buffer = ByteBuffer.allocate(1024);
                clientChannel.read(buffer, buffer, new ReadHandler(clientChannel));
                
            } catch (IOException e) {
                System.err.println("å¤„ç†å®¢æˆ·ç«¯è¿æ¥å¼‚å¸¸: " + e.getMessage());
            }
        }
        
        @Override
        public void failed(Throwable exc, Void attachment) {
            System.err.println("æ¥å—è¿æ¥å¤±è´¥: " + exc.getMessage());
        }
    }
    
    /**
     * è¯»å–æ•°æ®å¤„ç†å™¨
     */
    private class ReadHandler implements 
            CompletionHandler<Integer, ByteBuffer> {
        
        private final AsynchronousSocketChannel clientChannel;
        
        public ReadHandler(AsynchronousSocketChannel clientChannel) {
            this.clientChannel = clientChannel;
        }
        
        @Override
        public void completed(Integer bytesRead, ByteBuffer buffer) {
            if (bytesRead > 0) {
                buffer.flip();
                
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                String message = new String(data);
                
                System.out.println("æ”¶åˆ°æ¶ˆæ¯: " + message);
                
                // å›å†™æ•°æ®
                String response = "Echo: " + message;
                ByteBuffer writeBuffer = ByteBuffer.wrap(response.getBytes());
                
                clientChannel.write(writeBuffer, writeBuffer, 
                    new WriteHandler(clientChannel));
                
            } else if (bytesRead < 0) {
                // å®¢æˆ·ç«¯æ–­å¼€è¿æ¥
                try {
                    System.out.println("å®¢æˆ·ç«¯æ–­å¼€è¿æ¥: " + 
                        clientChannel.getRemoteAddress());
                    clientChannel.close();
                } catch (IOException e) {
                    System.err.println("å…³é—­è¿æ¥å¼‚å¸¸: " + e.getMessage());
                }
            }
        }
        
        @Override
        public void failed(Throwable exc, ByteBuffer buffer) {
            System.err.println("è¯»å–æ•°æ®å¤±è´¥: " + exc.getMessage());
            try {
                clientChannel.close();
            } catch (IOException e) {
                System.err.println("å…³é—­è¿æ¥å¼‚å¸¸: " + e.getMessage());
            }
        }
    }
    
    /**
     * å†™å…¥æ•°æ®å¤„ç†å™¨
     */
    private class WriteHandler implements 
            CompletionHandler<Integer, ByteBuffer> {
        
        private final AsynchronousSocketChannel clientChannel;
        
        public WriteHandler(AsynchronousSocketChannel clientChannel) {
            this.clientChannel = clientChannel;
        }
        
        @Override
        public void completed(Integer bytesWritten, ByteBuffer buffer) {
            if (buffer.hasRemaining()) {
                // ç»§ç»­å†™å…¥å‰©ä½™æ•°æ®
                clientChannel.write(buffer, buffer, this);
            } else {
                // å†™å…¥å®Œæˆï¼Œç»§ç»­è¯»å–
                ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                clientChannel.read(readBuffer, readBuffer, 
                    new ReadHandler(clientChannel));
            }
        }
        
        @Override
        public void failed(Throwable exc, ByteBuffer buffer) {
            System.err.println("å†™å…¥æ•°æ®å¤±è´¥: " + exc.getMessage());
            try {
                clientChannel.close();
            } catch (IOException e) {
                System.err.println("å…³é—­è¿æ¥å¼‚å¸¸: " + e.getMessage());
            }
        }
    }
    
    public static void main(String[] args) throws IOException, InterruptedException {
        new AIOServer(8080).start();
    }
}
```

</TabItem>
<TabItem value="aio-client" label="AIOå®¢æˆ·ç«¯">

```java title="AIOå®¢æˆ·ç«¯å®ç°"
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.Scanner;
import java.util.concurrent.CountDownLatch;

public class AIOClient {
    private AsynchronousSocketChannel clientChannel;
    private CountDownLatch latch;
    
    public void connect(String host, int port) throws IOException, InterruptedException {
        clientChannel = AsynchronousSocketChannel.open();
        latch = new CountDownLatch(1);
        
        clientChannel.connect(new InetSocketAddress(host, port), 
            null, new ConnectHandler());
        
        latch.await(); // ç­‰å¾…è¿æ¥å®Œæˆ
    }
    
    /**
     * è¿æ¥å¤„ç†å™¨
     */
    private class ConnectHandler implements CompletionHandler<Void, Void> {
        @Override
        public void completed(Void result, Void attachment) {
            System.out.println("è¿æ¥æœåŠ¡å™¨æˆåŠŸï¼");
            latch.countDown();
        }
        
        @Override
        public void failed(Throwable exc, Void attachment) {
            System.err.println("è¿æ¥æœåŠ¡å™¨å¤±è´¥: " + exc.getMessage());
            latch.countDown();
        }
    }
    
    public void sendMessage(String message) {
        ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());
        clientChannel.write(buffer, buffer, new WriteHandler());
    }
    
    /**
     * å†™å…¥å¤„ç†å™¨
     */
    private class WriteHandler implements CompletionHandler<Integer, ByteBuffer> {
        @Override
        public void completed(Integer bytesWritten, ByteBuffer buffer) {
            if (buffer.hasRemaining()) {
                clientChannel.write(buffer, buffer, this);
            } else {
                // å†™å…¥å®Œæˆï¼Œå¼€å§‹è¯»å–å“åº”
                ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                clientChannel.read(readBuffer, readBuffer, new ReadHandler());
            }
        }
        
        @Override
        public void failed(Throwable exc, ByteBuffer buffer) {
            System.err.println("å‘é€æ¶ˆæ¯å¤±è´¥: " + exc.getMessage());
        }
    }
    
    /**
     * è¯»å–å¤„ç†å™¨
     */
    private class ReadHandler implements CompletionHandler<Integer, ByteBuffer> {
        @Override
        public void completed(Integer bytesRead, ByteBuffer buffer) {
            if (bytesRead > 0) {
                buffer.flip();
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                String response = new String(data);
                System.out.println("æœåŠ¡å™¨å“åº”: " + response);
            }
        }
        
        @Override
        public void failed(Throwable exc, ByteBuffer buffer) {
            System.err.println("è¯»å–å“åº”å¤±è´¥: " + exc.getMessage());
        }
    }
    
    public void close() throws IOException {
        if (clientChannel != null) {
            clientChannel.close();
        }
    }
    
    public static void main(String[] args) {
        AIOClient client = new AIOClient();
        
        try {
            client.connect("localhost", 8080);
            
            Scanner scanner = new Scanner(System.in);
            System.out.println("è¾“å…¥æ¶ˆæ¯ï¼ˆè¾“å…¥'bye'é€€å‡ºï¼‰:");
            
            String userInput;
            while ((userInput = scanner.nextLine()) != null) {
                client.sendMessage(userInput);
                
                // ç»™å¼‚æ­¥æ“ä½œä¸€äº›æ—¶é—´
                Thread.sleep(1000);
                
                if ("bye".equalsIgnoreCase(userInput)) {
                    break;
                }
            }
        } catch (IOException | InterruptedException e) {
            System.err.println("å®¢æˆ·ç«¯å¼‚å¸¸: " + e.getMessage());
        } finally {
            try {
                client.close();
            } catch (IOException e) {
                System.err.println("å…³é—­è¿æ¥å¼‚å¸¸: " + e.getMessage());
            }
        }
    }
}
```

</TabItem>
<TabItem value="aio-features" label="AIOç‰¹æ€§åˆ†æ">

**AIOæ ¸å¿ƒç‰¹æ€§**
- **çœŸæ­£å¼‚æ­¥**ï¼šæ“ä½œç«‹å³è¿”å›ï¼Œé€šè¿‡å›è°ƒå¤„ç†ç»“æœ
- **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºProactoræ¨¡å¼
- **é«˜å¹¶å‘**ï¼šé€‚åˆå¤„ç†å¤§é‡å¹¶å‘è¿æ¥
- **é›¶æ‹·è´**ï¼šæ”¯æŒDirectByteBuffer

**AIO vs NIO**
```java
// NIO - åŒæ­¥éé˜»å¡
int bytesRead = channel.read(buffer);  // ç«‹å³è¿”å›
if (bytesRead > 0) {
    // å¤„ç†æ•°æ®
}

// AIO - å¼‚æ­¥éé˜»å¡
channel.read(buffer, attachment, new CompletionHandler<Integer, Object>() {
    @Override
    public void completed(Integer result, Object attachment) {
        // å¼‚æ­¥å›è°ƒå¤„ç†ç»“æœ
    }
    
    @Override
    public void failed(Throwable exc, Object attachment) {
        // å¤„ç†å¼‚å¸¸
    }
});
```

**AIOé€‚ç”¨åœºæ™¯**
- é«˜å¹¶å‘é•¿è¿æ¥
- å¤§é‡å¼‚æ­¥IOæ“ä½œ
- å¯¹å“åº”æ—¶é—´è¦æ±‚é«˜
- å¤æ‚çš„å¼‚æ­¥å¤„ç†é€»è¾‘

**AIOæ³¨æ„äº‹é¡¹**
- å›è°ƒåœ°ç‹±é—®é¢˜
- å¼‚å¸¸å¤„ç†å¤æ‚
- è°ƒè¯•å›°éš¾
- éœ€è¦åˆç†çš„çº¿ç¨‹æ± é…ç½®

</TabItem>
</Tabs>

## 3. é«˜çº§ç½‘ç»œç¼–ç¨‹æŠ€æœ¯

### 3.1 é›¶æ‹·è´æŠ€æœ¯

<Tabs>
<TabItem value="zero-copy-concept" label="é›¶æ‹·è´æ¦‚å¿µ">

**ä¼ ç»ŸIOæ•°æ®æ‹·è´è¿‡ç¨‹**
```mermaid
graph TB
    A[ç£ç›˜æ–‡ä»¶] --> B[å†…æ ¸ç¼“å†²åŒº]
    B --> C[ç”¨æˆ·ç©ºé—´ç¼“å†²åŒº]
    C --> D[Socketç¼“å†²åŒº]
    D --> E[ç½‘å¡ç¼“å†²åŒº]
    
    F[4æ¬¡æ‹·è´] --> G[2æ¬¡ç”¨æˆ·æ€/å†…æ ¸æ€åˆ‡æ¢]
```

**é›¶æ‹·è´ä¼˜åŒ–è¿‡ç¨‹**
```mermaid
graph TB
    A[ç£ç›˜æ–‡ä»¶] --> B[å†…æ ¸ç¼“å†²åŒº]
    B --> C[Socketç¼“å†²åŒº]
    C --> D[ç½‘å¡ç¼“å†²åŒº]
    
    E[2æ¬¡æ‹·è´] --> F[æ— ç”¨æˆ·æ€/å†…æ ¸æ€åˆ‡æ¢]
```

**Javaé›¶æ‹·è´å®ç°**
```java title="é›¶æ‹·è´æ–‡ä»¶ä¼ è¾“"
import java.io.FileInputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.FileChannel;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

public class ZeroCopyServer {
    public static void main(String[] args) throws IOException {
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(8080));
        
        while (true) {
            SocketChannel clientChannel = serverChannel.accept();
            
            // ä½¿ç”¨transferToå®ç°é›¶æ‹·è´
            FileInputStream fis = new FileInputStream("large-file.dat");
            FileChannel fileChannel = fis.getChannel();
            
            // é›¶æ‹·è´ä¼ è¾“æ–‡ä»¶
            long transferred = fileChannel.transferTo(
                0, fileChannel.size(), clientChannel);
            
            System.out.println("ä¼ è¾“å­—èŠ‚æ•°: " + transferred);
            
            fileChannel.close();
            fis.close();
            clientChannel.close();
        }
    }
}
```

</TabItem>
<TabItem value="direct-buffer" label="ç›´æ¥å†…å­˜">

**DirectByteBufferä¼˜åŠ¿**
```java title="ç›´æ¥å†…å­˜ä½¿ç”¨"
import java.nio.ByteBuffer;

public class DirectBufferExample {
    public static void main(String[] args) {
        // å †å†…å­˜ç¼“å†²åŒº
        ByteBuffer heapBuffer = ByteBuffer.allocate(1024);
        
        // ç›´æ¥å†…å­˜ç¼“å†²åŒºï¼ˆé›¶æ‹·è´ï¼‰
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        
        // æ€§èƒ½æµ‹è¯•
        long startTime = System.nanoTime();
        
        // ç›´æ¥å†…å­˜æ“ä½œæ›´å¿«ï¼Œé¿å…JVMå †å†…å­˜æ‹·è´
        for (int i = 0; i < 1000000; i++) {
            directBuffer.putInt(i);
        }
        
        long endTime = System.nanoTime();
        System.out.println("ç›´æ¥å†…å­˜æ“ä½œè€—æ—¶: " + (endTime - startTime) + "ns");
        
        // æ³¨æ„ï¼šç›´æ¥å†…å­˜éœ€è¦æ‰‹åŠ¨é‡Šæ”¾
        // ((DirectBuffer) directBuffer).cleaner().clean();
    }
}
```

**å†…å­˜æ˜ å°„æ–‡ä»¶**
```java title="å†…å­˜æ˜ å°„æ–‡ä»¶"
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class MemoryMappedFileExample {
    public static void main(String[] args) throws Exception {
        RandomAccessFile file = new RandomAccessFile("data.txt", "rw");
        FileChannel channel = file.getChannel();
        
        // å†…å­˜æ˜ å°„æ–‡ä»¶
        MappedByteBuffer buffer = channel.map(
            FileChannel.MapMode.READ_WRITE, 0, file.length());
        
        // ç›´æ¥æ“ä½œå†…å­˜æ˜ å°„åŒºåŸŸ
        buffer.put("Hello Memory Mapped File".getBytes());
        
        channel.close();
        file.close();
    }
}
```

</TabItem>
</Tabs>

### 3.2 ç²˜åŒ…æ‹†åŒ…å¤„ç†

<Tabs>
<TabItem value="packet-problem" label="ç²˜åŒ…æ‹†åŒ…é—®é¢˜">

**ç²˜åŒ…æ‹†åŒ…ç°è±¡**
```mermaid
graph TB
    A[å‘é€ç«¯] --> B[TCPç¼“å†²åŒº]
    B --> C[ç½‘ç»œä¼ è¾“]
    C --> D[æ¥æ”¶ç«¯ç¼“å†²åŒº]
    D --> E[åº”ç”¨ç¨‹åº]
    
    F[æ­£å¸¸æƒ…å†µ] --> F1[åŒ…1|åŒ…2|åŒ…3]
    G[ç²˜åŒ…æƒ…å†µ] --> G1[åŒ…1åŒ…2|åŒ…3]
    H[æ‹†åŒ…æƒ…å†µ] --> H1[åŒ…1çš„ä¸€éƒ¨åˆ†|åŒ…1çš„å‰©ä½™éƒ¨åˆ†åŒ…2]
```

**äº§ç”ŸåŸå› **
- **Nagleç®—æ³•**ï¼šä¸ºæé«˜ç½‘ç»œæ•ˆç‡ï¼Œåˆå¹¶å°åŒ…å‘é€
- **TCPç¼“å†²åŒº**ï¼šå‘é€å’Œæ¥æ”¶ç¼“å†²åŒºå¤§å°é™åˆ¶
- **ç½‘ç»œMTU**ï¼šæœ€å¤§ä¼ è¾“å•å…ƒé™åˆ¶
- **åº”ç”¨å±‚è¯»å–**ï¼šè¯»å–æ•°æ®çš„æ—¶æœºå’Œå¤§å°

</TabItem>
<TabItem value="solution-methods" label="è§£å†³æ–¹æ¡ˆ">

**1. å›ºå®šé•¿åº¦æ–¹æ¡ˆ**
```java title="å›ºå®šé•¿åº¦æ¶ˆæ¯å¤„ç†"
public class FixedLengthDecoder {
    private static final int MESSAGE_LENGTH = 100;
    private ByteBuffer buffer = ByteBuffer.allocate(MESSAGE_LENGTH * 10);
    
    public List<String> decode(ByteBuffer input) {
        List<String> messages = new ArrayList<>();
        
        // å°†æ–°æ•°æ®è¿½åŠ åˆ°ç¼“å†²åŒº
        buffer.put(input);
        buffer.flip();
        
        // æŒ‰å›ºå®šé•¿åº¦è§£ææ¶ˆæ¯
        while (buffer.remaining() >= MESSAGE_LENGTH) {
            byte[] messageBytes = new byte[MESSAGE_LENGTH];
            buffer.get(messageBytes);
            
            String message = new String(messageBytes).trim();
            messages.add(message);
        }
        
        // ä¿ç•™æœªå®Œæ•´çš„æ•°æ®
        buffer.compact();
        
        return messages;
    }
}
```

**2. åˆ†éš”ç¬¦æ–¹æ¡ˆ**
```java title="åˆ†éš”ç¬¦æ¶ˆæ¯å¤„ç†"
public class DelimiterDecoder {
    private static final byte DELIMITER = '\n';
    private ByteBuffer buffer = ByteBuffer.allocate(8192);
    
    public List<String> decode(ByteBuffer input) {
        List<String> messages = new ArrayList<>();
        
        buffer.put(input);
        buffer.flip();
        
        int start = 0;
        for (int i = 0; i < buffer.limit(); i++) {
            if (buffer.get(i) == DELIMITER) {
                // æ‰¾åˆ°å®Œæ•´æ¶ˆæ¯
                byte[] messageBytes = new byte[i - start];
                buffer.position(start);
                buffer.get(messageBytes);
                
                String message = new String(messageBytes);
                messages.add(message);
                
                start = i + 1;
            }
        }
        
        // ä¿ç•™æœªå®Œæ•´çš„æ•°æ®
        if (start < buffer.limit()) {
            buffer.position(start);
            buffer.compact();
        } else {
            buffer.clear();
        }
        
        return messages;
    }
}
```

**3. é•¿åº¦å­—æ®µæ–¹æ¡ˆ**
```java title="é•¿åº¦å­—æ®µæ¶ˆæ¯å¤„ç†"
public class LengthFieldDecoder {
    private ByteBuffer buffer = ByteBuffer.allocate(8192);
    
    public List<String> decode(ByteBuffer input) {
        List<String> messages = new ArrayList<>();
        
        buffer.put(input);
        buffer.flip();
        
        while (buffer.remaining() >= 4) { // è‡³å°‘æœ‰é•¿åº¦å­—æ®µ
            buffer.mark(); // æ ‡è®°å½“å‰ä½ç½®
            
            int messageLength = buffer.getInt(); // è¯»å–æ¶ˆæ¯é•¿åº¦
            
            if (buffer.remaining() >= messageLength) {
                // æœ‰å®Œæ•´æ¶ˆæ¯
                byte[] messageBytes = new byte[messageLength];
                buffer.get(messageBytes);
                
                String message = new String(messageBytes);
                messages.add(message);
            } else {
                // æ¶ˆæ¯ä¸å®Œæ•´ï¼Œå›é€€åˆ°æ ‡è®°ä½ç½®
                buffer.reset();
                break;
            }
        }
        
        buffer.compact();
        return messages;
    }
}
```

**4. è‡ªå®šä¹‰åè®®æ–¹æ¡ˆ**
```java title="è‡ªå®šä¹‰åè®®æ¶ˆæ¯"
public class CustomProtocolMessage {
    private static final int MAGIC_NUMBER = 0xCAFEBABE;
    private static final int HEADER_LENGTH = 16;
    
    private int magicNumber;    // 4å­—èŠ‚é­”æ•°
    private int version;        // 4å­—èŠ‚ç‰ˆæœ¬
    private int messageType;    // 4å­—èŠ‚æ¶ˆæ¯ç±»å‹
    private int bodyLength;     // 4å­—èŠ‚æ¶ˆæ¯ä½“é•¿åº¦
    private byte[] body;        // å˜é•¿æ¶ˆæ¯ä½“
    
    public static CustomProtocolMessage decode(ByteBuffer buffer) {
        if (buffer.remaining() < HEADER_LENGTH) {
            return null; // å¤´éƒ¨ä¸å®Œæ•´
        }
        
        buffer.mark();
        
        int magic = buffer.getInt();
        if (magic != MAGIC_NUMBER) {
            throw new IllegalArgumentException("Invalid magic number");
        }
        
        int version = buffer.getInt();
        int messageType = buffer.getInt();
        int bodyLength = buffer.getInt();
        
        if (buffer.remaining() < bodyLength) {
            buffer.reset(); // æ¶ˆæ¯ä½“ä¸å®Œæ•´ï¼Œå›é€€
            return null;
        }
        
        byte[] body = new byte[bodyLength];
        buffer.get(body);
        
        CustomProtocolMessage message = new CustomProtocolMessage();
        message.magicNumber = magic;
        message.version = version;
        message.messageType = messageType;
        message.bodyLength = bodyLength;
        message.body = body;
        
        return message;
    }
}
```

</TabItem>
</Tabs>

## 4. å¸¸è§é¢è¯•é—®é¢˜ä¸è§£ç­”

### 4.1 åŸºç¡€æ¦‚å¿µé—®é¢˜

<Tabs>
<TabItem value="basic-qa" label="åŸºç¡€é—®ç­”">

**Q1: BIOã€NIOã€AIOçš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ**

A: ä¸‰ç§IOæ¨¡å‹çš„ä¸»è¦åŒºåˆ«ï¼š
- **BIOï¼ˆé˜»å¡IOï¼‰**ï¼šåŒæ­¥é˜»å¡ï¼Œä¸€ä¸ªè¿æ¥ä¸€ä¸ªçº¿ç¨‹ï¼Œé€‚åˆè¿æ¥æ•°å°‘çš„åœºæ™¯
- **NIOï¼ˆéé˜»å¡IOï¼‰**ï¼šåŒæ­¥éé˜»å¡ï¼Œä¸€ä¸ªçº¿ç¨‹å¤„ç†å¤šä¸ªè¿æ¥ï¼Œä½¿ç”¨Selectorå¤šè·¯å¤ç”¨
- **AIOï¼ˆå¼‚æ­¥IOï¼‰**ï¼šå¼‚æ­¥éé˜»å¡ï¼ŒåŸºäºäº‹ä»¶å’Œå›è°ƒæœºåˆ¶ï¼Œé€‚åˆé«˜å¹¶å‘åœºæ™¯

**Q2: Selectorçš„å·¥ä½œåŸç†æ˜¯ä»€ä¹ˆï¼Ÿ**

A: Selectorå·¥ä½œåŸç†ï¼š
1. å°†Channelæ³¨å†Œåˆ°Selectorä¸Šï¼ŒæŒ‡å®šæ„Ÿå…´è¶£çš„äº‹ä»¶
2. è°ƒç”¨select()æ–¹æ³•é˜»å¡ç­‰å¾…äº‹ä»¶å‘ç”Ÿ
3. å½“æœ‰äº‹ä»¶å°±ç»ªæ—¶ï¼Œselect()è¿”å›å°±ç»ªé€šé“æ•°é‡
4. é€šè¿‡selectedKeys()è·å–å°±ç»ªçš„SelectionKeyé›†åˆ
5. éå†å¤„ç†æ¯ä¸ªå°±ç»ªçš„äº‹ä»¶

**Q3: ä»€ä¹ˆæ˜¯é›¶æ‹·è´ï¼Ÿæœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ**

A: é›¶æ‹·è´æ˜¯æŒ‡æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­é¿å…åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´ä¹‹é—´çš„æ‹·è´ï¼š
- **ä¼ ç»Ÿæ–¹å¼**ï¼šç£ç›˜â†’å†…æ ¸ç¼“å†²åŒºâ†’ç”¨æˆ·ç¼“å†²åŒºâ†’Socketç¼“å†²åŒºâ†’ç½‘å¡
- **é›¶æ‹·è´**ï¼šç£ç›˜â†’å†…æ ¸ç¼“å†²åŒºâ†’Socketç¼“å†²åŒºâ†’ç½‘å¡
- **ä¼˜åŠ¿**ï¼šå‡å°‘CPUå¼€é”€ã€å‡å°‘å†…å­˜æ‹·è´ã€æé«˜ä¼ è¾“æ•ˆç‡

</TabItem>
<TabItem value="advanced-qa" label="æ·±å…¥é—®ç­”">

**Q4: å¦‚ä½•å¤„ç†TCPç²˜åŒ…æ‹†åŒ…é—®é¢˜ï¼Ÿ**

A: å¸¸è§è§£å†³æ–¹æ¡ˆï¼š
1. **å›ºå®šé•¿åº¦**ï¼šæ¯ä¸ªæ¶ˆæ¯å›ºå®šå­—èŠ‚æ•°ï¼Œç®€å•ä½†æµªè´¹ç©ºé—´
2. **åˆ†éš”ç¬¦**ï¼šä½¿ç”¨ç‰¹æ®Šå­—ç¬¦åˆ†éš”æ¶ˆæ¯ï¼Œçµæ´»ä½†éœ€è¦è½¬ä¹‰
3. **é•¿åº¦å­—æ®µ**ï¼šæ¶ˆæ¯å¤´åŒ…å«é•¿åº¦ä¿¡æ¯ï¼Œæœ€å¸¸ç”¨çš„æ–¹æ¡ˆ
4. **è‡ªå®šä¹‰åè®®**ï¼šè®¾è®¡å®Œæ•´çš„åº”ç”¨å±‚åè®®ï¼Œæœ€çµæ´»ä½†å¤æ‚

**Q5: é«˜å¹¶å‘ç½‘ç»œç¼–ç¨‹çš„çº¿ç¨‹æ¨¡å‹æœ‰å“ªäº›ï¼Ÿ**

A: å¸¸è§çº¿ç¨‹æ¨¡å‹ï¼š
- **å•çº¿ç¨‹æ¨¡å‹**ï¼šä¸€ä¸ªçº¿ç¨‹å¤„ç†æ‰€æœ‰IOäº‹ä»¶ï¼Œç®€å•ä½†æ€§èƒ½æœ‰é™
- **å¤šçº¿ç¨‹æ¨¡å‹**ï¼šä¸ºæ¯ä¸ªè¿æ¥åˆ†é…çº¿ç¨‹ï¼Œèµ„æºæ¶ˆè€—å¤§
- **çº¿ç¨‹æ± æ¨¡å‹**ï¼šä½¿ç”¨å›ºå®šå¤§å°çº¿ç¨‹æ± ï¼Œæ§åˆ¶èµ„æºæ¶ˆè€—
- **Reactoræ¨¡å‹**ï¼šäº‹ä»¶é©±åŠ¨ï¼Œå•çº¿ç¨‹æˆ–å¤šçº¿ç¨‹Reactor
- **Proactoræ¨¡å‹**ï¼šå¼‚æ­¥IOï¼ŒåŸºäºå®Œæˆäº‹ä»¶çš„å¤„ç†

**Q6: å¦‚ä½•ä¼˜åŒ–ç½‘ç»œç¼–ç¨‹æ€§èƒ½ï¼Ÿ**

A: æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š
- **é€‰æ‹©åˆé€‚çš„IOæ¨¡å‹**ï¼šæ ¹æ®å¹¶å‘é‡é€‰æ‹©BIO/NIO/AIO
- **ä½¿ç”¨é›¶æ‹·è´æŠ€æœ¯**ï¼šDirectByteBufferã€transferToç­‰
- **åˆç†è®¾ç½®ç¼“å†²åŒºå¤§å°**ï¼šé¿å…é¢‘ç¹çš„ç³»ç»Ÿè°ƒç”¨
- **è¿æ¥æ± å¤ç”¨**ï¼šå‡å°‘è¿æ¥å»ºç«‹å’Œé”€æ¯å¼€é”€
- **æ‰¹é‡å¤„ç†**ï¼šåˆå¹¶å°çš„IOæ“ä½œ
- **å¼‚æ­¥å¤„ç†**ï¼šé¿å…é˜»å¡ä¸»çº¿ç¨‹

</TabItem>
</Tabs>

### 4.2 å®é™…åº”ç”¨é—®é¢˜

**ç½‘ç»œç¼–ç¨‹æœ€ä½³å®è·µ**

1. **é€‰æ‹©åˆé€‚çš„IOæ¨¡å‹**
   - è¿æ¥æ•° < 1000ï¼šBIO + çº¿ç¨‹æ± 
   - è¿æ¥æ•° 1000-10000ï¼šNIO + Reactor
   - è¿æ¥æ•° > 10000ï¼šAIO + Proactor

2. **å¼‚å¸¸å¤„ç†**
   - ç½‘ç»œä¸­æ–­å¤„ç†
   - è¶…æ—¶æœºåˆ¶è®¾ç½®
   - èµ„æºæ¸…ç†ä¿è¯

3. **æ€§èƒ½ç›‘æ§**
   - è¿æ¥æ•°ç›‘æ§
   - ååé‡ç»Ÿè®¡
   - å»¶è¿Ÿåˆ†æ

4. **å®‰å…¨è€ƒè™‘**
   - è¾“å…¥éªŒè¯
   - è¿æ¥æ•°é™åˆ¶
   - DDoSé˜²æŠ¤

é€šè¿‡æ·±å…¥ç†è§£Socketç¼–ç¨‹å’ŒIOæ¨¡å‹ï¼Œä½ å°†èƒ½å¤Ÿï¼š
- é€‰æ‹©åˆé€‚çš„IOæ¨¡å‹æ„å»ºé«˜æ€§èƒ½ç½‘ç»œåº”ç”¨
- è§£å†³ç½‘ç»œç¼–ç¨‹ä¸­çš„å¸¸è§é—®é¢˜
- ä¼˜åŒ–ç½‘ç»œåº”ç”¨çš„æ€§èƒ½å’Œå¯æ‰©å±•æ€§
- å¤„ç†å¤æ‚çš„å¹¶å‘å’Œå¼‚æ­¥ç¼–ç¨‹åœºæ™¯ 