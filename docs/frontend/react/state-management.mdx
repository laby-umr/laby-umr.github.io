---
sidebar_position: 3
title: ReactçŠ¶æ€ç®¡ç†å®Œå…¨æŒ‡å—
description: æ·±å…¥è§£æReactçŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼šContext APIã€Reduxã€Zustandã€Recoilç­‰ç°ä»£çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ
authors: [Laby]
tags: [çŠ¶æ€ç®¡ç†, Context API, Redux, Zustand, Recoil, MobX, çŠ¶æ€è®¾è®¡]
last_update:
  date: 2025-08-14
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# ReactçŠ¶æ€ç®¡ç†å®Œå…¨æŒ‡å—

çŠ¶æ€ç®¡ç†æ˜¯Reactåº”ç”¨å¼€å‘çš„æ ¸å¿ƒæŒ‘æˆ˜ä¹‹ä¸€ã€‚éšç€åº”ç”¨è§„æ¨¡çš„å¢é•¿ï¼Œå¦‚ä½•é«˜æ•ˆã€å¯ç»´æŠ¤åœ°ç®¡ç†åº”ç”¨çŠ¶æ€å˜å¾—è‡³å…³é‡è¦ã€‚æœ¬æŒ‡å—å°†æ·±å…¥æ¢è®¨å„ç§çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼Œå¸®åŠ©ä½ é€‰æ‹©æœ€é€‚åˆé¡¹ç›®éœ€æ±‚çš„è§£å†³æ–¹æ¡ˆã€‚

:::tip æ ¸å¿ƒä»·å€¼
**çŠ¶æ€ç®¡ç† = æ•°æ®æµæ§åˆ¶ + çŠ¶æ€å…±äº« + æ€§èƒ½ä¼˜åŒ– + å¼€å‘ä½“éªŒ**
- ğŸ¯ **æ•°æ®æµæ§åˆ¶**ï¼šå•å‘æ•°æ®æµï¼Œå¯é¢„æµ‹çš„çŠ¶æ€å˜åŒ–
- ğŸ”„ **çŠ¶æ€å…±äº«**ï¼šè·¨ç»„ä»¶çŠ¶æ€å…±äº«ï¼Œé¿å…prop drilling
- âš¡ **æ€§èƒ½ä¼˜åŒ–**ï¼šç²¾ç¡®æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“
- ğŸ› ï¸ **å¼€å‘ä½“éªŒ**ï¼šè°ƒè¯•å·¥å…·ï¼Œæ—¶é—´æ—…è¡Œï¼ŒçŠ¶æ€æŒä¹…åŒ–
- ğŸ“Š **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„çŠ¶æ€ç»“æ„ï¼Œæ˜“äºæµ‹è¯•å’Œç»´æŠ¤
- ğŸ¨ **çµæ´»æ€§**ï¼šé€‚åº”ä¸åŒè§„æ¨¡å’Œå¤æ‚åº¦çš„åº”ç”¨éœ€æ±‚
:::

## 1. çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”

### 1.1 æ–¹æ¡ˆé€‰æ‹©æŒ‡å—

é€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆéœ€è¦è€ƒè™‘åº”ç”¨è§„æ¨¡ã€å›¢é˜Ÿç»éªŒã€æ€§èƒ½è¦æ±‚ç­‰å¤šä¸ªå› ç´ ã€‚

```mermaid
graph TB
    subgraph "çŠ¶æ€ç®¡ç†æ–¹æ¡ˆé€‰æ‹©å†³ç­–æ ‘"
        A[å¼€å§‹è¯„ä¼°] --> B{åº”ç”¨è§„æ¨¡}
        B -->|å°å‹åº”ç”¨| C[Reactå†…ç½®çŠ¶æ€]
        B -->|ä¸­å‹åº”ç”¨| D{çŠ¶æ€å¤æ‚åº¦}
        B -->|å¤§å‹åº”ç”¨| E[ä¼ä¸šçº§æ–¹æ¡ˆ]
        
        C --> C1[useState + useContext]
        
        D -->|ç®€å•| D1[Zustand]
        D -->|å¤æ‚| D2[Redux Toolkit]
        
        E --> E1[Redux + Saga]
        E --> E2[MobX]
        E --> E3[Recoil]
        
        F[å›¢é˜Ÿç»éªŒ] --> G{Reduxç»éªŒ}
        G -->|æœ‰| H[Reduxç”Ÿæ€]
        G -->|æ— | I[ç°ä»£è½»é‡æ–¹æ¡ˆ]
        
        H --> H1[Redux Toolkit]
        H --> H2[Redux + RTK Query]
        
        I --> I1[Zustand]
        I --> I2[Jotai]
        I --> I3[Valtio]
    end
```

#### çŠ¶æ€ç®¡ç†æ–¹æ¡ˆå¯¹æ¯”è¡¨

| æ–¹æ¡ˆ | å­¦ä¹ æ›²çº¿ | åŒ…å¤§å° | æ€§èƒ½ | ç”Ÿæ€ç³»ç»Ÿ | é€‚ç”¨åœºæ™¯ | TypeScriptæ”¯æŒ |
|------|----------|--------|------|----------|----------|----------------|
| **useState + useContext** | ä½ | 0KB | ä¸­ç­‰ | Reactå†…ç½® | å°å‹åº”ç”¨ | â­â­â­ |
| **Redux Toolkit** | ä¸­ç­‰ | 47KB | é«˜ | ä¸°å¯Œ | ä¸­å¤§å‹åº”ç”¨ | â­â­â­â­â­ |
| **Zustand** | ä½ | 8KB | é«˜ | ä¸­ç­‰ | ä¸­å°å‹åº”ç”¨ | â­â­â­â­ |
| **Jotai** | ä¸­ç­‰ | 13KB | é«˜ | æ–°å…´ | åŸå­åŒ–çŠ¶æ€ | â­â­â­â­â­ |
| **Recoil** | ä¸­ç­‰ | 79KB | é«˜ | Facebook | å¤æ‚çŠ¶æ€å›¾ | â­â­â­â­ |
| **MobX** | é«˜ | 16KB | é«˜ | æˆç†Ÿ | é¢å‘å¯¹è±¡ | â­â­â­â­ |
| **Valtio** | ä½ | 9KB | é«˜ | æ–°å…´ | ä»£ç†çŠ¶æ€ | â­â­â­â­ |

<Tabs>
<TabItem value="react-builtin" label="Reactå†…ç½®çŠ¶æ€">

### Reactå†…ç½®çŠ¶æ€ç®¡ç†

å¯¹äºå°åˆ°ä¸­å‹åº”ç”¨ï¼ŒReactçš„å†…ç½®çŠ¶æ€ç®¡ç†é€šå¸¸å·²ç»è¶³å¤Ÿã€‚

```typescript title="Reactå†…ç½®çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ"
import React, { createContext, useContext, useReducer, useState, useCallback, useMemo } from 'react';

// 1. ç®€å•çŠ¶æ€ç®¡ç† - useState + useContext
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  language: 'zh' | 'en';
  notifications: Notification[];
}

interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  timestamp: number;
}

// Contextå®šä¹‰
const AppStateContext = createContext<{
  state: AppState;
  actions: {
    setUser: (user: User | null) => void;
    toggleTheme: () => void;
    setLanguage: (language: 'zh' | 'en') => void;
    addNotification: (notification: Omit<Notification, 'id' | 'timestamp'>) => void;
    removeNotification: (id: string) => void;
    clearNotifications: () => void;
  };
} | undefined>(undefined);

// Providerç»„ä»¶
export const AppStateProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<AppState>({
    user: null,
    theme: 'light',
    language: 'zh',
    notifications: []
  });
  
  // ä¼˜åŒ–çš„action creators
  const actions = useMemo(() => ({
    setUser: (user: User | null) => {
      setState(prev => ({ ...prev, user }));
    },
    
    toggleTheme: () => {
      setState(prev => ({ 
        ...prev, 
        theme: prev.theme === 'light' ? 'dark' : 'light' 
      }));
    },
    
    setLanguage: (language: 'zh' | 'en') => {
      setState(prev => ({ ...prev, language }));
    },
    
    addNotification: (notification: Omit<Notification, 'id' | 'timestamp'>) => {
      const newNotification: Notification = {
        ...notification,
        id: Math.random().toString(36).substr(2, 9),
        timestamp: Date.now()
      };
      
      setState(prev => ({
        ...prev,
        notifications: [...prev.notifications, newNotification]
      }));
      
      // è‡ªåŠ¨ç§»é™¤é€šçŸ¥
      setTimeout(() => {
        setState(prev => ({
          ...prev,
          notifications: prev.notifications.filter(n => n.id !== newNotification.id)
        }));
      }, 5000);
    },
    
    removeNotification: (id: string) => {
      setState(prev => ({
        ...prev,
        notifications: prev.notifications.filter(n => n.id !== id)
      }));
    },
    
    clearNotifications: () => {
      setState(prev => ({ ...prev, notifications: [] }));
    }
  }), []);
  
  const value = useMemo(() => ({ state, actions }), [state, actions]);
  
  return (
    <AppStateContext.Provider value={value}>
      {children}
    </AppStateContext.Provider>
  );
};

// Hook
export const useAppState = () => {
  const context = useContext(AppStateContext);
  if (context === undefined) {
    throw new Error('useAppState must be used within an AppStateProvider');
  }
  return context;
};

// 2. å¤æ‚çŠ¶æ€ç®¡ç† - useReducer
interface TodoState {
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
  loading: boolean;
  error: string | null;
}

interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: number;
  updatedAt: number;
}

type TodoAction =
  | { type: 'ADD_TODO'; payload: { text: string } }
  | { type: 'TOGGLE_TODO'; payload: { id: string } }
  | { type: 'DELETE_TODO'; payload: { id: string } }
  | { type: 'EDIT_TODO'; payload: { id: string; text: string } }
  | { type: 'SET_FILTER'; payload: { filter: TodoState['filter'] } }
  | { type: 'SET_LOADING'; payload: { loading: boolean } }
  | { type: 'SET_ERROR'; payload: { error: string | null } }
  | { type: 'LOAD_TODOS'; payload: { todos: Todo[] } }
  | { type: 'CLEAR_COMPLETED' };

const todoReducer = (state: TodoState, action: TodoAction): TodoState => {
  switch (action.type) {
    case 'ADD_TODO': {
      const newTodo: Todo = {
        id: Math.random().toString(36).substr(2, 9),
        text: action.payload.text,
        completed: false,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      
      return {
        ...state,
        todos: [...state.todos, newTodo],
        error: null
      };
    }
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed, updatedAt: Date.now() }
            : todo
        )
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload.id)
      };
    
    case 'EDIT_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, text: action.payload.text, updatedAt: Date.now() }
            : todo
        )
      };
    
    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload.filter
      };
    
    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload.loading
      };
    
    case 'SET_ERROR':
      return {
        ...state,
        error: action.payload.error,
        loading: false
      };
    
    case 'LOAD_TODOS':
      return {
        ...state,
        todos: action.payload.todos,
        loading: false,
        error: null
      };
    
    case 'CLEAR_COMPLETED':
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed)
      };
    
    default:
      return state;
  }
};

// Todo Context
const TodoContext = createContext<{
  state: TodoState;
  dispatch: React.Dispatch<TodoAction>;
  actions: {
    addTodo: (text: string) => void;
    toggleTodo: (id: string) => void;
    deleteTodo: (id: string) => void;
    editTodo: (id: string, text: string) => void;
    setFilter: (filter: TodoState['filter']) => void;
    clearCompleted: () => void;
    loadTodos: () => Promise<void>;
  };
} | undefined>(undefined);

export const TodoProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(todoReducer, {
    todos: [],
    filter: 'all',
    loading: false,
    error: null
  });
  
  // Action creators
  const actions = useMemo(() => ({
    addTodo: (text: string) => {
      dispatch({ type: 'ADD_TODO', payload: { text } });
    },
    
    toggleTodo: (id: string) => {
      dispatch({ type: 'TOGGLE_TODO', payload: { id } });
    },
    
    deleteTodo: (id: string) => {
      dispatch({ type: 'DELETE_TODO', payload: { id } });
    },
    
    editTodo: (id: string, text: string) => {
      dispatch({ type: 'EDIT_TODO', payload: { id, text } });
    },
    
    setFilter: (filter: TodoState['filter']) => {
      dispatch({ type: 'SET_FILTER', payload: { filter } });
    },
    
    clearCompleted: () => {
      dispatch({ type: 'CLEAR_COMPLETED' });
    },
    
    loadTodos: async () => {
      dispatch({ type: 'SET_LOADING', payload: { loading: true } });
      
      try {
        // æ¨¡æ‹ŸAPIè°ƒç”¨
        const response = await fetch('/api/todos');
        if (!response.ok) {
          throw new Error('Failed to load todos');
        }
        
        const todos = await response.json();
        dispatch({ type: 'LOAD_TODOS', payload: { todos } });
      } catch (error) {
        dispatch({ 
          type: 'SET_ERROR', 
          payload: { error: error instanceof Error ? error.message : 'Unknown error' }
        });
      }
    }
  }), []);
  
  const value = useMemo(() => ({ state, dispatch, actions }), [state, actions]);
  
  return (
    <TodoContext.Provider value={value}>
      {children}
    </TodoContext.Provider>
  );
};

export const useTodos = () => {
  const context = useContext(TodoContext);
  if (context === undefined) {
    throw new Error('useTodos must be used within a TodoProvider');
  }
  return context;
};

// ä½¿ç”¨ç¤ºä¾‹
const TodoApp: React.FC = () => {
  const { state, actions } = useTodos();
  const [newTodoText, setNewTodoText] = useState('');
  
  // è¿‡æ»¤todos
  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case 'active':
        return state.todos.filter(todo => !todo.completed);
      case 'completed':
        return state.todos.filter(todo => todo.completed);
      default:
        return state.todos;
    }
  }, [state.todos, state.filter]);
  
  const handleAddTodo = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      actions.addTodo(newTodoText.trim());
      setNewTodoText('');
    }
  }, [newTodoText, actions]);
  
  useEffect(() => {
    actions.loadTodos();
  }, [actions]);
  
  if (state.loading) {
    return <div className="loading">åŠ è½½ä¸­...</div>;
  }
  
  if (state.error) {
    return <div className="error">é”™è¯¯: {state.error}</div>;
  }
  
  return (
    <div className="todo-app">
      <h1>å¾…åŠäº‹é¡¹</h1>
      
      <form onSubmit={handleAddTodo} className="add-todo-form">
        <input
          type="text"
          value={newTodoText}
          onChange={(e) => setNewTodoText(e.target.value)}
          placeholder="æ·»åŠ æ–°çš„å¾…åŠäº‹é¡¹..."
          className="todo-input"
        />
        <button type="submit">æ·»åŠ </button>
      </form>
      
      <div className="todo-filters">
        <button
          className={state.filter === 'all' ? 'active' : ''}
          onClick={() => actions.setFilter('all')}
        >
          å…¨éƒ¨
        </button>
        <button
          className={state.filter === 'active' ? 'active' : ''}
          onClick={() => actions.setFilter('active')}
        >
          æœªå®Œæˆ
        </button>
        <button
          className={state.filter === 'completed' ? 'active' : ''}
          onClick={() => actions.setFilter('completed')}
        >
          å·²å®Œæˆ
        </button>
      </div>
      
      <ul className="todo-list">
        {filteredTodos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={() => actions.toggleTodo(todo.id)}
            onDelete={() => actions.deleteTodo(todo.id)}
            onEdit={(text) => actions.editTodo(todo.id, text)}
          />
        ))}
      </ul>
      
      {state.todos.some(todo => todo.completed) && (
        <button onClick={actions.clearCompleted} className="clear-completed">
          æ¸…é™¤å·²å®Œæˆ
        </button>
      )}
    </div>
  );
};
```

</TabItem>
<TabItem value="redux-toolkit" label="Redux Toolkit">

### Redux Toolkitç°ä»£åŒ–çŠ¶æ€ç®¡ç†

Redux Toolkitæ˜¯Reduxå®˜æ–¹æ¨èçš„ç°ä»£åŒ–å·¥å…·é›†ï¼Œå¤§å¹…ç®€åŒ–äº†Reduxçš„ä½¿ç”¨ã€‚

```typescript title="Redux Toolkitå®Œæ•´å®ç°"
import { createSlice, createAsyncThunk, configureStore, PayloadAction } from '@reduxjs/toolkit';
import { useSelector, useDispatch, TypedUseSelectorHook } from 'react-redux';

// 1. ç”¨æˆ·çŠ¶æ€ç®¡ç†
interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
  role: 'admin' | 'user' | 'guest';
}

interface UserState {
  currentUser: User | null;
  users: User[];
  loading: boolean;
  error: string | null;
}

const initialUserState: UserState = {
  currentUser: null,
  users: [],
  loading: false,
  error: null
};

// å¼‚æ­¥Thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/users');
      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error instanceof Error ? error.message : 'Unknown error');
    }
  }
);

export const loginUser = createAsyncThunk(
  'users/loginUser',
  async ({ email, password }: { email: string; password: string }, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        throw new Error('Login failed');
      }
      
      const data = await response.json();
      localStorage.setItem('token', data.token);
      return data.user;
    } catch (error) {
      return rejectWithValue(error instanceof Error ? error.message : 'Login failed');
    }
  }
);

export const updateUser = createAsyncThunk(
  'users/updateUser',
  async ({ id, updates }: { id: number; updates: Partial<User> }, { rejectWithValue }) => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`/api/users/${id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) {
        throw new Error('Update failed');
      }
      
      return await response.json();
    } catch (error) {
      return rejectWithValue(error instanceof Error ? error.message : 'Update failed');
    }
  }
);

// User Slice
const userSlice = createSlice({
  name: 'users',
  initialState: initialUserState,
  reducers: {
    logout: (state) => {
      state.currentUser = null;
      localStorage.removeItem('token');
    },
    clearError: (state) => {
      state.error = null;
    },
    setCurrentUser: (state, action: PayloadAction<User>) => {
      state.currentUser = action.payload;
    }
  },
  extraReducers: (builder) => {
    builder
      // fetchUsers
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // loginUser
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.currentUser = action.payload;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      // updateUser
      .addCase(updateUser.fulfilled, (state, action) => {
        if (state.currentUser && state.currentUser.id === action.payload.id) {
          state.currentUser = action.payload;
        }
        state.users = state.users.map(user =>
          user.id === action.payload.id ? action.payload : user
        );
      });
  }
});

export const { logout, clearError, setCurrentUser } = userSlice.actions;

// 2. è´­ç‰©è½¦çŠ¶æ€ç®¡ç†
interface CartItem {
  id: number;
  name: string;
  price: number;
  quantity: number;
  image: string;
}

interface CartState {
  items: CartItem[];
  totalItems: number;
  totalPrice: number;
  discount: number;
  shippingCost: number;
}

const initialCartState: CartState = {
  items: [],
  totalItems: 0,
  totalPrice: 0,
  discount: 0,
  shippingCost: 0
};

const cartSlice = createSlice({
  name: 'cart',
  initialState: initialCartState,
  reducers: {
    addItem: (state, action: PayloadAction<Omit<CartItem, 'quantity'>>) => {
      const existingItem = state.items.find(item => item.id === action.payload.id);
      
      if (existingItem) {
        existingItem.quantity += 1;
      } else {
        state.items.push({ ...action.payload, quantity: 1 });
      }
      
      cartSlice.caseReducers.calculateTotals(state);
    },
    
    removeItem: (state, action: PayloadAction<number>) => {
      state.items = state.items.filter(item => item.id !== action.payload);
      cartSlice.caseReducers.calculateTotals(state);
    },
    
    updateQuantity: (state, action: PayloadAction<{ id: number; quantity: number }>) => {
      const { id, quantity } = action.payload;
      
      if (quantity <= 0) {
        state.items = state.items.filter(item => item.id !== id);
      } else {
        const item = state.items.find(item => item.id === id);
        if (item) {
          item.quantity = quantity;
        }
      }
      
      cartSlice.caseReducers.calculateTotals(state);
    },
    
    applyDiscount: (state, action: PayloadAction<number>) => {
      state.discount = action.payload;
    },
    
    setShippingCost: (state, action: PayloadAction<number>) => {
      state.shippingCost = action.payload;
    },
    
    clearCart: (state) => {
      state.items = [];
      state.totalItems = 0;
      state.totalPrice = 0;
      state.discount = 0;
    },
    
    calculateTotals: (state) => {
      state.totalItems = state.items.reduce((sum, item) => sum + item.quantity, 0);
      state.totalPrice = state.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    }
  }
});

export const {
  addItem,
  removeItem,
  updateQuantity,
  applyDiscount,
  setShippingCost,
  clearCart
} = cartSlice.actions;

// 3. é€šçŸ¥çŠ¶æ€ç®¡ç†
interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  timestamp: number;
  autoClose?: boolean;
}

interface NotificationState {
  notifications: Notification[];
}

const initialNotificationState: NotificationState = {
  notifications: []
};

const notificationSlice = createSlice({
  name: 'notifications',
  initialState: initialNotificationState,
  reducers: {
    addNotification: (state, action: PayloadAction<Omit<Notification, 'id' | 'timestamp'>>) => {
      const notification: Notification = {
        ...action.payload,
        id: Math.random().toString(36).substr(2, 9),
        timestamp: Date.now()
      };
      
      state.notifications.push(notification);
    },
    
    removeNotification: (state, action: PayloadAction<string>) => {
      state.notifications = state.notifications.filter(n => n.id !== action.payload);
    },
    
    clearNotifications: (state) => {
      state.notifications = [];
    }
  }
});

export const { addNotification, removeNotification, clearNotifications } = notificationSlice.actions;

// Storeé…ç½®
export const store = configureStore({
  reducer: {
    users: userSlice.reducer,
    cart: cartSlice.reducer,
    notifications: notificationSlice.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    }),
  devTools: process.env.NODE_ENV !== 'production'
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// ç±»å‹åŒ–çš„hooks
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// Selectors
export const selectCurrentUser = (state: RootState) => state.users.currentUser;
export const selectUsers = (state: RootState) => state.users.users;
export const selectUserLoading = (state: RootState) => state.users.loading;
export const selectUserError = (state: RootState) => state.users.error;

export const selectCartItems = (state: RootState) => state.cart.items;
export const selectCartTotal = (state: RootState) => state.cart.totalPrice;
export const selectCartItemCount = (state: RootState) => state.cart.totalItems;
export const selectCartFinalPrice = (state: RootState) => {
  const { totalPrice, discount, shippingCost } = state.cart;
  const discountAmount = totalPrice * (discount / 100);
  return totalPrice - discountAmount + shippingCost;
};

export const selectNotifications = (state: RootState) => state.notifications.notifications;

// ä½¿ç”¨ç¤ºä¾‹ç»„ä»¶
const UserProfile: React.FC = () => {
  const dispatch = useAppDispatch();
  const currentUser = useAppSelector(selectCurrentUser);
  const loading = useAppSelector(selectUserLoading);
  const error = useAppSelector(selectUserError);
  
  const [editing, setEditing] = useState(false);
  const [name, setName] = useState(currentUser?.name || '');
  
  const handleSave = async () => {
    if (currentUser) {
      try {
        await dispatch(updateUser({ id: currentUser.id, updates: { name } })).unwrap();
        setEditing(false);
        dispatch(addNotification({
          type: 'success',
          message: 'ç”¨æˆ·ä¿¡æ¯æ›´æ–°æˆåŠŸ',
          autoClose: true
        }));
      } catch (error) {
        dispatch(addNotification({
          type: 'error',
          message: 'æ›´æ–°å¤±è´¥: ' + error,
          autoClose: true
        }));
      }
    }
  };
  
  if (loading) return <div>åŠ è½½ä¸­...</div>;
  if (error) return <div>é”™è¯¯: {error}</div>;
  if (!currentUser) return <div>è¯·å…ˆç™»å½•</div>;
  
  return (
    <div className="user-profile">
      <h2>ç”¨æˆ·èµ„æ–™</h2>
      
      {editing ? (
        <div>
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
          />
          <button onClick={handleSave}>ä¿å­˜</button>
          <button onClick={() => setEditing(false)}>å–æ¶ˆ</button>
        </div>
      ) : (
        <div>
          <p>å§“å: {currentUser.name}</p>
          <p>é‚®ç®±: {currentUser.email}</p>
          <button onClick={() => setEditing(true)}>ç¼–è¾‘</button>
        </div>
      )}
      
      <button onClick={() => dispatch(logout())}>
        é€€å‡ºç™»å½•
      </button>
    </div>
  );
};

const ShoppingCart: React.FC = () => {
  const dispatch = useAppDispatch();
  const items = useAppSelector(selectCartItems);
  const totalPrice = useAppSelector(selectCartTotal);
  const finalPrice = useAppSelector(selectCartFinalPrice);
  
  return (
    <div className="shopping-cart">
      <h2>è´­ç‰©è½¦</h2>
      
      {items.length === 0 ? (
        <p>è´­ç‰©è½¦ä¸ºç©º</p>
      ) : (
        <>
          {items.map(item => (
            <div key={item.id} className="cart-item">
              <span>{item.name}</span>
              <span>Â¥{item.price}</span>
              <div>
                <button
                  onClick={() => dispatch(updateQuantity({ id: item.id, quantity: item.quantity - 1 }))}
                >
                  -
                </button>
                <span>{item.quantity}</span>
                <button
                  onClick={() => dispatch(updateQuantity({ id: item.id, quantity: item.quantity + 1 }))}
                >
                  +
                </button>
              </div>
              <button onClick={() => dispatch(removeItem(item.id))}>
                åˆ é™¤
              </button>
            </div>
          ))}
          
          <div className="cart-summary">
            <p>å°è®¡: Â¥{totalPrice.toFixed(2)}</p>
            <p>æ€»è®¡: Â¥{finalPrice.toFixed(2)}</p>
            <button onClick={() => dispatch(clearCart())}>
              æ¸…ç©ºè´­ç‰©è½¦
            </button>
          </div>
        </>
      )}
    </div>
  );
};
```

</TabItem>
<TabItem value="zustand" label="Zustand">

### Zustandè½»é‡çº§çŠ¶æ€ç®¡ç†

Zustandæ˜¯ä¸€ä¸ªå°å·§ã€å¿«é€Ÿã€å¯æ‰©å±•çš„çŠ¶æ€ç®¡ç†è§£å†³æ–¹æ¡ˆã€‚

```typescript title="ZustandçŠ¶æ€ç®¡ç†å®ç°"
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { persist } from 'zustand/middleware';

// 1. åŸºç¡€Store
interface CounterState {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
  setCount: (count: number) => void;
}

export const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
  setCount: (count) => set({ count })
}));

// 2. å¤æ‚Store with Immer
interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: number;
}

interface TodoState {
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
  loading: boolean;
  error: string | null;
  
  // Actions
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  deleteTodo: (id: string) => void;
  editTodo: (id: string, text: string) => void;
  setFilter: (filter: 'all' | 'active' | 'completed') => void;
  clearCompleted: () => void;
  loadTodos: () => Promise<void>;
  
  // Computed
  filteredTodos: () => Todo[];
  completedCount: () => number;
  activeCount: () => number;
}

export const useTodoStore = create<TodoState>()(
  immer(
    subscribeWithSelector((set, get) => ({
      todos: [],
      filter: 'all',
      loading: false,
      error: null,
      
      addTodo: (text: string) =>
        set((state) => {
          state.todos.push({
            id: Math.random().toString(36).substr(2, 9),
            text,
            completed: false,
            createdAt: Date.now()
          });
        }),
      
      toggleTodo: (id: string) =>
        set((state) => {
          const todo = state.todos.find(t => t.id === id);
          if (todo) {
            todo.completed = !todo.completed;
          }
        }),
      
      deleteTodo: (id: string) =>
        set((state) => {
          state.todos = state.todos.filter(t => t.id !== id);
        }),
      
      editTodo: (id: string, text: string) =>
        set((state) => {
          const todo = state.todos.find(t => t.id === id);
          if (todo) {
            todo.text = text;
          }
        }),
      
      setFilter: (filter) => set({ filter }),
      
      clearCompleted: () =>
        set((state) => {
          state.todos = state.todos.filter(t => !t.completed);
        }),
      
      loadTodos: async () => {
        set({ loading: true, error: null });
        
        try {
          const response = await fetch('/api/todos');
          if (!response.ok) {
            throw new Error('Failed to load todos');
          }
          
          const todos = await response.json();
          set({ todos, loading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Unknown error',
            loading: false
          });
        }
      },
      
      // Computed values
      filteredTodos: () => {
        const { todos, filter } = get();
        switch (filter) {
          case 'active':
            return todos.filter(t => !t.completed);
          case 'completed':
            return todos.filter(t => t.completed);
          default:
            return todos;
        }
      },
      
      completedCount: () => get().todos.filter(t => t.completed).length,
      activeCount: () => get().todos.filter(t => !t.completed).length
    }))
  )
);

// 3. æŒä¹…åŒ–Store
interface UserState {
  user: User | null;
  theme: 'light' | 'dark';
  language: 'zh' | 'en';
  preferences: {
    notifications: boolean;
    autoSave: boolean;
    compactMode: boolean;
  };
  
  // Actions
  setUser: (user: User | null) => void;
  toggleTheme: () => void;
  setLanguage: (language: 'zh' | 'en') => void;
  updatePreferences: (preferences: Partial<UserState['preferences']>) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

export const useUserStore = create<UserState>()(
  persist(
    immer((set, get) => ({
      user: null,
      theme: 'light',
      language: 'zh',
      preferences: {
        notifications: true,
        autoSave: true,
        compactMode: false
      },
      
      setUser: (user) => set({ user }),
      
      toggleTheme: () =>
        set((state) => {
          state.theme = state.theme === 'light' ? 'dark' : 'light';
        }),
      
      setLanguage: (language) => set({ language }),
      
      updatePreferences: (newPreferences) =>
        set((state) => {
          Object.assign(state.preferences, newPreferences);
        }),
      
      login: async (email: string, password: string) => {
        try {
          const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
          });
          
          if (!response.ok) {
            throw new Error('Login failed');
          }
          
          const { user, token } = await response.json();
          localStorage.setItem('token', token);
          set({ user });
        } catch (error) {
          throw error;
        }
      },
      
      logout: () => {
        localStorage.removeItem('token');
        set({ user: null });
      }
    })),
    {
      name: 'user-storage',
      partialize: (state) => ({
        theme: state.theme,
        language: state.language,
        preferences: state.preferences
      })
    }
  )
);

// 4. è®¢é˜…å’Œä¸­é—´ä»¶
// ä¸»é¢˜å˜åŒ–ç›‘å¬
useUserStore.subscribe(
  (state) => state.theme,
  (theme) => {
    document.documentElement.setAttribute('data-theme', theme);
  }
);

// è¯­è¨€å˜åŒ–ç›‘å¬
useUserStore.subscribe(
  (state) => state.language,
  (language) => {
    document.documentElement.setAttribute('lang', language);
  }
);

// 5. é€‰æ‹©å™¨ä¼˜åŒ–
export const useUser = () => useUserStore((state) => state.user);
export const useTheme = () => useUserStore((state) => state.theme);
export const useLanguage = () => useUserStore((state) => state.language);
export const usePreferences = () => useUserStore((state) => state.preferences);

// æµ…æ¯”è¾ƒé€‰æ‹©å™¨
export const useTodoStats = () => 
  useTodoStore(
    (state) => ({
      total: state.todos.length,
      completed: state.completedCount(),
      active: state.activeCount()
    }),
    (a, b) => a.total === b.total && a.completed === b.completed && a.active === b.active
  );

// 6. ä½¿ç”¨ç¤ºä¾‹
const TodoApp: React.FC = () => {
  const {
    todos,
    filter,
    loading,
    error,
    addTodo,
    toggleTodo,
    deleteTodo,
    setFilter,
    clearCompleted,
    loadTodos,
    filteredTodos
  } = useTodoStore();
  
  const stats = useTodoStats();
  const [newTodoText, setNewTodoText] = useState('');
  
  useEffect(() => {
    loadTodos();
  }, [loadTodos]);
  
  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      addTodo(newTodoText.trim());
      setNewTodoText('');
    }
  };
  
  if (loading) return <div>åŠ è½½ä¸­...</div>;
  if (error) return <div>é”™è¯¯: {error}</div>;
  
  return (
    <div className="todo-app">
      <h1>å¾…åŠäº‹é¡¹ ({stats.total})</h1>
      
      <form onSubmit={handleAddTodo}>
        <input
          type="text"
          value={newTodoText}
          onChange={(e) => setNewTodoText(e.target.value)}
          placeholder="æ·»åŠ æ–°çš„å¾…åŠäº‹é¡¹..."
        />
        <button type="submit">æ·»åŠ </button>
      </form>
      
      <div className="filters">
        <button
          className={filter === 'all' ? 'active' : ''}
          onClick={() => setFilter('all')}
        >
          å…¨éƒ¨ ({stats.total})
        </button>
        <button
          className={filter === 'active' ? 'active' : ''}
          onClick={() => setFilter('active')}
        >
          æœªå®Œæˆ ({stats.active})
        </button>
        <button
          className={filter === 'completed' ? 'active' : ''}
          onClick={() => setFilter('completed')}
        >
          å·²å®Œæˆ ({stats.completed})
        </button>
      </div>
      
      <ul className="todo-list">
        {filteredTodos().map(todo => (
          <li key={todo.id} className={todo.completed ? 'completed' : ''}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
            <button onClick={() => deleteTodo(todo.id)}>åˆ é™¤</button>
          </li>
        ))}
      </ul>
      
      {stats.completed > 0 && (
        <button onClick={clearCompleted}>
          æ¸…é™¤å·²å®Œæˆ ({stats.completed})
        </button>
      )}
    </div>
  );
};

const UserSettings: React.FC = () => {
  const { theme, language, preferences, toggleTheme, setLanguage, updatePreferences } = useUserStore();
  
  return (
    <div className="user-settings">
      <h2>ç”¨æˆ·è®¾ç½®</h2>
      
      <div className="setting-group">
        <label>ä¸»é¢˜</label>
        <button onClick={toggleTheme}>
          {theme === 'light' ? 'ğŸŒ™ åˆ‡æ¢åˆ°æ·±è‰²' : 'â˜€ï¸ åˆ‡æ¢åˆ°æµ…è‰²'}
        </button>
      </div>
      
      <div className="setting-group">
        <label>è¯­è¨€</label>
        <select value={language} onChange={(e) => setLanguage(e.target.value as 'zh' | 'en')}>
          <option value="zh">ä¸­æ–‡</option>
          <option value="en">English</option>
        </select>
      </div>
      
      <div className="setting-group">
        <label>
          <input
            type="checkbox"
            checked={preferences.notifications}
            onChange={(e) => updatePreferences({ notifications: e.target.checked })}
          />
          å¯ç”¨é€šçŸ¥
        </label>
      </div>
      
      <div className="setting-group">
        <label>
          <input
            type="checkbox"
            checked={preferences.autoSave}
            onChange={(e) => updatePreferences({ autoSave: e.target.checked })}
          />
          è‡ªåŠ¨ä¿å­˜
        </label>
      </div>
      
      <div className="setting-group">
        <label>
          <input
            type="checkbox"
            checked={preferences.compactMode}
            onChange={(e) => updatePreferences({ compactMode: e.target.checked })}
          />
          ç´§å‡‘æ¨¡å¼
        </label>
      </div>
    </div>
  );
};
```

</TabItem>
<TabItem value="jotai" label="JotaiåŸå­åŒ–">

### JotaiåŸå­åŒ–çŠ¶æ€ç®¡ç†

Jotaié‡‡ç”¨åŸå­åŒ–çš„çŠ¶æ€ç®¡ç†æ–¹å¼ï¼Œæä¾›äº†æ›´ç»†ç²’åº¦çš„çŠ¶æ€æ§åˆ¶ã€‚

```typescript title="JotaiåŸå­åŒ–çŠ¶æ€ç®¡ç†"
import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai';
import { atomWithStorage, atomWithReset, RESET } from 'jotai/utils';
import { atomWithImmer } from 'jotai-immer';

// 1. åŸºç¡€åŸå­
export const countAtom = atom(0);
export const nameAtom = atom('');
export const emailAtom = atom('');

// 2. æ´¾ç”ŸåŸå­
export const doubleCountAtom = atom((get) => get(countAtom) * 2);
export const isEvenAtom = atom((get) => get(countAtom) % 2 === 0);

// 3. å¯å†™æ´¾ç”ŸåŸå­
export const uppercaseNameAtom = atom(
  (get) => get(nameAtom).toUpperCase(),
  (get, set, newValue: string) => {
    set(nameAtom, newValue.toLowerCase());
  }
);

// 4. å¼‚æ­¥åŸå­
interface User {
  id: number;
  name: string;
  email: string;
}

export const userIdAtom = atom<number | null>(null);

export const userAtom = atom(async (get) => {
  const userId = get(userIdAtom);
  if (!userId) return null;
  
  const response = await fetch(`/api/users/${userId}`);
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  
  return response.json() as Promise<User>;
});

// 5. å­˜å‚¨åŸå­
export const themeAtom = atomWithStorage<'light' | 'dark'>('theme', 'light');
export const languageAtom = atomWithStorage<'zh' | 'en'>('language', 'zh');

// 6. å¯é‡ç½®åŸå­
export const formDataAtom = atomWithReset({
  name: '',
  email: '',
  message: ''
});

// 7. ImmeråŸå­
interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: number;
}

export const todosAtom = atomWithImmer<Todo[]>([]);

// 8. å¤æ‚çŠ¶æ€ç»„åˆ
interface AppState {
  user: User | null;
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
  loading: boolean;
  error: string | null;
}

// åˆ†ç¦»çš„åŸå­
export const currentUserAtom = atom<User | null>(null);
export const todoListAtom = atomWithImmer<Todo[]>([]);
export const todoFilterAtom = atom<'all' | 'active' | 'completed'>('all');
export const loadingAtom = atom(false);
export const errorAtom = atom<string | null>(null);

// æ´¾ç”ŸåŸå­
export const filteredTodosAtom = atom((get) => {
  const todos = get(todoListAtom);
  const filter = get(todoFilterAtom);
  
  switch (filter) {
    case 'active':
      return todos.filter(todo => !todo.completed);
    case 'completed':
      return todos.filter(todo => todo.completed);
    default:
      return todos;
  }
});

export const todoStatsAtom = atom((get) => {
  const todos = get(todoListAtom);
  return {
    total: todos.length,
    completed: todos.filter(t => t.completed).length,
    active: todos.filter(t => !t.completed).length
  };
});

// 9. åŠ¨ä½œåŸå­
export const addTodoAtom = atom(
  null,
  (get, set, text: string) => {
    const newTodo: Todo = {
      id: Math.random().toString(36).substr(2, 9),
      text,
      completed: false,
      createdAt: Date.now()
    };
    
    set(todoListAtom, (draft) => {
      draft.push(newTodo);
    });
  }
);

export const toggleTodoAtom = atom(
  null,
  (get, set, id: string) => {
    set(todoListAtom, (draft) => {
      const todo = draft.find(t => t.id === id);
      if (todo) {
        todo.completed = !todo.completed;
      }
    });
  }
);

export const deleteTodoAtom = atom(
  null,
  (get, set, id: string) => {
    set(todoListAtom, (draft) => {
      const index = draft.findIndex(t => t.id === id);
      if (index !== -1) {
        draft.splice(index, 1);
      }
    });
  }
);

export const clearCompletedAtom = atom(
  null,
  (get, set) => {
    set(todoListAtom, (draft) => {
      return draft.filter(t => !t.completed);
    });
  }
);

// 10. å¼‚æ­¥åŠ¨ä½œåŸå­
export const loadTodosAtom = atom(
  null,
  async (get, set) => {
    set(loadingAtom, true);
    set(errorAtom, null);
    
    try {
      const response = await fetch('/api/todos');
      if (!response.ok) {
        throw new Error('Failed to load todos');
      }
      
      const todos = await response.json();
      set(todoListAtom, todos);
    } catch (error) {
      set(errorAtom, error instanceof Error ? error.message : 'Unknown error');
    } finally {
      set(loadingAtom, false);
    }
  }
);

export const saveTodoAtom = atom(
  null,
  async (get, set, todo: Todo) => {
    try {
      const response = await fetch(`/api/todos/${todo.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(todo)
      });
      
      if (!response.ok) {
        throw new Error('Failed to save todo');
      }
      
      const updatedTodo = await response.json();
      
      set(todoListAtom, (draft) => {
        const index = draft.findIndex(t => t.id === todo.id);
        if (index !== -1) {
          draft[index] = updatedTodo;
        }
      });
    } catch (error) {
      set(errorAtom, error instanceof Error ? error.message : 'Save failed');
    }
  }
);

// 11. ä½¿ç”¨ç¤ºä¾‹ç»„ä»¶
const Counter: React.FC = () => {
  const [count, setCount] = useAtom(countAtom);
  const doubleCount = useAtomValue(doubleCountAtom);
  const isEven = useAtomValue(isEvenAtom);
  
  return (
    <div className="counter">
      <h2>è®¡æ•°å™¨</h2>
      <p>å½“å‰å€¼: {count}</p>
      <p>åŒå€å€¼: {doubleCount}</p>
      <p>æ˜¯å¦ä¸ºå¶æ•°: {isEven ? 'æ˜¯' : 'å¦'}</p>
      
      <div className="controls">
        <button onClick={() => setCount(c => c - 1)}>-1</button>
        <button onClick={() => setCount(c => c + 1)}>+1</button>
        <button onClick={() => setCount(0)}>é‡ç½®</button>
      </div>
    </div>
  );
};

const TodoApp: React.FC = () => {
  const todos = useAtomValue(filteredTodosAtom);
  const stats = useAtomValue(todoStatsAtom);
  const [filter, setFilter] = useAtom(todoFilterAtom);
  const loading = useAtomValue(loadingAtom);
  const error = useAtomValue(errorAtom);
  
  const addTodo = useSetAtom(addTodoAtom);
  const toggleTodo = useSetAtom(toggleTodoAtom);
  const deleteTodo = useSetAtom(deleteTodoAtom);
  const clearCompleted = useSetAtom(clearCompletedAtom);
  const loadTodos = useSetAtom(loadTodosAtom);
  
  const [newTodoText, setNewTodoText] = useState('');
  
  useEffect(() => {
    loadTodos();
  }, [loadTodos]);
  
  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      addTodo(newTodoText.trim());
      setNewTodoText('');
    }
  };
  
  if (loading) return <div>åŠ è½½ä¸­...</div>;
  if (error) return <div>é”™è¯¯: {error}</div>;
  
  return (
    <div className="todo-app">
      <h1>å¾…åŠäº‹é¡¹ ({stats.total})</h1>
      
      <form onSubmit={handleAddTodo}>
        <input
          type="text"
          value={newTodoText}
          onChange={(e) => setNewTodoText(e.target.value)}
          placeholder="æ·»åŠ æ–°çš„å¾…åŠäº‹é¡¹..."
        />
        <button type="submit">æ·»åŠ </button>
      </form>
      
      <div className="filters">
        <button
          className={filter === 'all' ? 'active' : ''}
          onClick={() => setFilter('all')}
        >
          å…¨éƒ¨ ({stats.total})
        </button>
        <button
          className={filter === 'active' ? 'active' : ''}
          onClick={() => setFilter('active')}
        >
          æœªå®Œæˆ ({stats.active})
        </button>
        <button
          className={filter === 'completed' ? 'active' : ''}
          onClick={() => setFilter('completed')}
        >
          å·²å®Œæˆ ({stats.completed})
        </button>
      </div>
      
      <ul className="todo-list">
        {todos.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={() => toggleTodo(todo.id)}
            onDelete={() => deleteTodo(todo.id)}
          />
        ))}
      </ul>
      
      {stats.completed > 0 && (
        <button onClick={() => clearCompleted()}>
          æ¸…é™¤å·²å®Œæˆ ({stats.completed})
        </button>
      )}
    </div>
  );
};

const TodoItem: React.FC<{
  todo: Todo;
  onToggle: () => void;
  onDelete: () => void;
}> = ({ todo, onToggle, onDelete }) => {
  const [editing, setEditing] = useState(false);
  const [text, setText] = useState(todo.text);
  const saveTodo = useSetAtom(saveTodoAtom);
  
  const handleSave = async () => {
    if (text.trim() && text !== todo.text) {
      await saveTodo({ ...todo, text: text.trim() });
    }
    setEditing(false);
  };
  
  const handleCancel = () => {
    setText(todo.text);
    setEditing(false);
  };
  
  return (
    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={onToggle}
      />
      
      {editing ? (
        <div className="edit-mode">
          <input
            type="text"
            value={text}
            onChange={(e) => setText(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleSave();
              if (e.key === 'Escape') handleCancel();
            }}
            autoFocus
          />
          <button onClick={handleSave}>ä¿å­˜</button>
          <button onClick={handleCancel}>å–æ¶ˆ</button>
        </div>
      ) : (
        <div className="view-mode">
          <span onDoubleClick={() => setEditing(true)}>
            {todo.text}
          </span>
          <button onClick={() => setEditing(true)}>ç¼–è¾‘</button>
          <button onClick={onDelete}>åˆ é™¤</button>
        </div>
      )}
    </li>
  );
};

// 12. è¡¨å•å¤„ç†
const ContactForm: React.FC = () => {
  const [formData, setFormData] = useAtom(formDataAtom);
  const resetForm = useSetAtom(RESET);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      const response = await fetch('/api/contact', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (response.ok) {
        alert('æ¶ˆæ¯å‘é€æˆåŠŸï¼');
        resetForm(formDataAtom);
      } else {
        throw new Error('å‘é€å¤±è´¥');
      }
    } catch (error) {
      alert('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="contact-form">
      <h2>è”ç³»æˆ‘ä»¬</h2>
      
      <div className="form-field">
        <label htmlFor="name">å§“å</label>
        <input
          id="name"
          type="text"
          value={formData.name}
          onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
          required
        />
      </div>
      
      <div className="form-field">
        <label htmlFor="email">é‚®ç®±</label>
        <input
          id="email"
          type="email"
          value={formData.email}
          onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
          required
        />
      </div>
      
      <div className="form-field">
        <label htmlFor="message">æ¶ˆæ¯</label>
        <textarea
          id="message"
          value={formData.message}
          onChange={(e) => setFormData(prev => ({ ...prev, message: e.target.value }))}
          required
          rows={4}
        />
      </div>
      
      <div className="form-actions">
        <button type="submit">å‘é€</button>
        <button type="button" onClick={() => resetForm(formDataAtom)}>
          é‡ç½®
        </button>
      </div>
    </form>
  );
};
```

</TabItem>
</Tabs>

## 2. çŠ¶æ€è®¾è®¡åŸåˆ™ä¸æœ€ä½³å®è·µ 