---
sidebar_position: 4
title: VueçŠ¶æ€ç®¡ç†æ–¹æ¡ˆ
description: Vueåº”ç”¨ä¸­çš„çŠ¶æ€ç®¡ç†ç­–ç•¥ï¼ŒåŒ…å«Piniaã€Vuexä¸Composition APIçŠ¶æ€ç®¡ç†
authors: [Laby]
tags: [Vue.js, Pinia, Vuex, çŠ¶æ€ç®¡ç†, å“åº”å¼çŠ¶æ€]
last_update:
  date: 2025-08-15
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# VueçŠ¶æ€ç®¡ç†æ–¹æ¡ˆ

éšç€Vueåº”ç”¨è§„æ¨¡çš„å¢é•¿ï¼Œç»„ä»¶é—´çš„çŠ¶æ€å…±äº«å’Œç®¡ç†å˜å¾—å°¤ä¸ºé‡è¦ã€‚æœ¬æ–‡å°†ä»‹ç»Vueç”Ÿæ€ç³»ç»Ÿä¸­çš„å„ç§çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼ŒåŒ…æ‹¬Piniaã€Vuexä»¥åŠä½¿ç”¨Composition APIçš„çŠ¶æ€ç®¡ç†ç­–ç•¥ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**VueçŠ¶æ€ç®¡ç†çš„ä»·å€¼**
- ğŸ“Š **é›†ä¸­å¼çŠ¶æ€**ï¼šæä¾›åº”ç”¨çš„å•ä¸€çŠ¶æ€æº
- ğŸ”„ **å¯é¢„æµ‹çš„å˜æ›´**ï¼šé€šè¿‡æ˜ç¡®çš„è§„åˆ™ä¿®æ”¹çŠ¶æ€
- ğŸ§© **æ¨¡å—åŒ–è®¾è®¡**ï¼šå°†å¤æ‚çŠ¶æ€åˆ†è§£ä¸ºå¯ç®¡ç†çš„æ¨¡å—
- ğŸ” **å¼€å‘å·¥å…·**ï¼šæä¾›æ—¶é—´æ—…è¡Œã€çŠ¶æ€å¿«ç…§ç­‰è°ƒè¯•åŠŸèƒ½
- âš¡ **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–ç»„ä»¶æ›´æ–°å’Œæ¸²æŸ“
:::

## 1. Pinia - æ–°ä¸€ä»£çŠ¶æ€ç®¡ç†

Piniaæ˜¯Vueå®˜æ–¹æ¨èçš„æ–°ä¸€ä»£çŠ¶æ€ç®¡ç†åº“ï¼Œç›¸æ¯”Vuexæ›´è½»é‡ã€æ›´TypeScriptå‹å¥½ï¼Œå¹¶ä¸”æä¾›äº†æ›´å¥½çš„å¼€å‘ä½“éªŒã€‚

### 1.1 PiniaåŸºç¡€è®¾ç½®

é¦–å…ˆå®‰è£…Piniaï¼š

```bash
npm install pinia
```

åœ¨Vueåº”ç”¨ä¸­æ³¨å†ŒPiniaï¼š

```js title="src/main.js"
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')
```

### 1.2 åˆ›å»ºPinia Store

ä½¿ç”¨`defineStore`åˆ›å»ºä¸€ä¸ªstoreï¼š

```js title="src/stores/counter.js"
import { defineStore } from 'pinia'

// åŸºäºOption APIé£æ ¼çš„store
export const useCounterStore = defineStore('counter', {
  // state
  state: () => ({
    count: 0,
    name: 'Counter',
    users: []
  }),
  
  // getters
  getters: {
    doubleCount: (state) => state.count * 2,
    // è®¿é—®å…¶ä»–getter
    doubleCountPlusOne() {
      return this.doubleCount + 1
    }
  },
  
  // actions
  actions: {
    increment() {
      this.count++
    },
    async fetchUsers() {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users')
        const data = await response.json()
        this.users = data
      } catch (error) {
        console.error('Failed to fetch users:', error)
      }
    }
  }
})
```

ä½¿ç”¨Composition APIé£æ ¼åˆ›å»ºstoreï¼š

```js title="src/stores/user.js"
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

// åŸºäºç»„åˆå¼APIé£æ ¼çš„store
export const useUserStore = defineStore('user', () => {
  // state
  const user = ref(null)
  const isLoggedIn = ref(false)
  const token = ref(localStorage.getItem('token') || null)
  const error = ref(null)
  
  // getters
  const userFullName = computed(() => {
    if (!user.value) return ''
    return `${user.value.firstName} ${user.value.lastName}`
  })
  
  // actions
  async function login(credentials) {
    try {
      error.value = null
      // æ¨¡æ‹ŸAPIè°ƒç”¨
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      })
      
      if (!response.ok) {
        throw new Error('Login failed')
      }
      
      const data = await response.json()
      user.value = data.user
      token.value = data.token
      isLoggedIn.value = true
      
      // ä¿å­˜tokenåˆ°æœ¬åœ°å­˜å‚¨
      localStorage.setItem('token', data.token)
      
      return true
    } catch (e) {
      error.value = e.message
      return false
    }
  }
  
  function logout() {
    user.value = null
    token.value = null
    isLoggedIn.value = false
    localStorage.removeItem('token')
  }
  
  async function fetchUserProfile() {
    if (!token.value) return null
    
    try {
      const response = await fetch('/api/profile', {
        headers: {
          'Authorization': `Bearer ${token.value}`
        }
      })
      
      if (!response.ok) {
        throw new Error('Failed to fetch profile')
      }
      
      user.value = await response.json()
      isLoggedIn.value = true
      
      return user.value
    } catch (e) {
      error.value = e.message
      return null
    }
  }
  
  return {
    // state
    user,
    isLoggedIn,
    token,
    error,
    // getters
    userFullName,
    // actions
    login,
    logout,
    fetchUserProfile
  }
})
```

### 1.3 åœ¨ç»„ä»¶ä¸­ä½¿ç”¨Pinia

```vue title="ä½¿ç”¨Piniaçš„ç»„ä»¶ç¤ºä¾‹"
<template>
  <div class="user-profile">
    <div v-if="userStore.isLoggedIn">
      <h1>æ¬¢è¿, {{ userStore.userFullName }}</h1>
      <button @click="userStore.logout">é€€å‡ºç™»å½•</button>
    </div>
    <div v-else>
      <h2>ç”¨æˆ·ç™»å½•</h2>
      <form @submit.prevent="handleLogin">
        <input v-model="email" type="email" placeholder="é‚®ç®±" required />
        <input v-model="password" type="password" placeholder="å¯†ç " required />
        <p v-if="userStore.error" class="error">{{ userStore.error }}</p>
        <button type="submit" :disabled="isLoading">
          {{ isLoading ? 'ç™»å½•ä¸­...' : 'ç™»å½•' }}
        </button>
      </form>
    </div>
    
    <div class="counter-section">
      <h3>è®¡æ•°å™¨: {{ counterStore.count }}</h3>
      <p>åŒå€å€¼: {{ counterStore.doubleCount }}</p>
      <button @click="counterStore.increment">å¢åŠ </button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useUserStore } from '../stores/user'
import { useCounterStore } from '../stores/counter'

const userStore = useUserStore()
const counterStore = useCounterStore()

const email = ref('')
const password = ref('')
const isLoading = ref(false)

const handleLogin = async () => {
  isLoading.value = true
  try {
    const success = await userStore.login({
      email: email.value,
      password: password.value
    })
    
    if (success) {
      email.value = ''
      password.value = ''
    }
  } finally {
    isLoading.value = false
  }
}
</script>
```

### 1.4 Piniaé«˜çº§ç‰¹æ€§

#### Storeé—´é€šä¿¡

Storeä¹‹é—´å¯ä»¥ç›¸äº’å¼•ç”¨å’Œäº¤äº’ï¼š

```js title="stores/cart.js"
import { defineStore } from 'pinia'
import { useProductStore } from './product'
import { useUserStore } from './user'

export const useCartStore = defineStore('cart', {
  state: () => ({
    items: [],
  }),
  
  getters: {
    totalItems: (state) => state.items.length,
    totalPrice: (state) => {
      const productStore = useProductStore()
      return state.items.reduce((total, item) => {
        const product = productStore.getProductById(item.productId)
        return total + (product?.price || 0) * item.quantity
      }, 0)
    },
    cartWithProducts: (state) => {
      const productStore = useProductStore()
      return state.items.map(item => {
        const product = productStore.getProductById(item.productId)
        return { 
          ...item,
          product,
          subtotal: (product?.price || 0) * item.quantity 
        }
      })
    }
  },
  
  actions: {
    addToCart(productId, quantity = 1) {
      const existingItem = this.items.find(item => item.productId === productId)
      
      if (existingItem) {
        existingItem.quantity += quantity
      } else {
        this.items.push({
          productId,
          quantity
        })
      }
      
      this.saveCart()
    },
    
    removeItem(productId) {
      const index = this.items.findIndex(item => item.productId === productId)
      if (index > -1) {
        this.items.splice(index, 1)
        this.saveCart()
      }
    },
    
    updateQuantity(productId, quantity) {
      const item = this.items.find(item => item.productId === productId)
      if (item) {
        item.quantity = quantity
        this.saveCart()
      }
    },
    
    async checkout() {
      const userStore = useUserStore()
      
      if (!userStore.isLoggedIn) {
        throw new Error('è¯·å…ˆç™»å½•')
      }
      
      try {
        // åˆ›å»ºè®¢å•
        const orderData = {
          userId: userStore.user.id,
          items: this.items,
          totalAmount: this.totalPrice
        }
        
        // æ¨¡æ‹ŸAPIè°ƒç”¨
        const response = await fetch('/api/orders', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${userStore.token}`
          },
          body: JSON.stringify(orderData)
        })
        
        if (!response.ok) {
          throw new Error('ç»“ç®—å¤±è´¥')
        }
        
        // æ¸…ç©ºè´­ç‰©è½¦
        this.clearCart()
        
        return await response.json()
      } catch (error) {
        console.error('ç»“ç®—é”™è¯¯:', error)
        throw error
      }
    },
    
    clearCart() {
      this.items = []
      this.saveCart()
    },
    
    loadCart() {
      const savedCart = localStorage.getItem('cart')
      if (savedCart) {
        this.items = JSON.parse(savedCart)
      }
    },
    
    saveCart() {
      localStorage.setItem('cart', JSON.stringify(this.items))
    }
  }
})
```

#### æŒä¹…åŒ–çŠ¶æ€

ä½¿ç”¨Piniaæ’ä»¶å®ç°çŠ¶æ€æŒä¹…åŒ–ï¼š

```js title="src/plugins/piniaPersist.js"
import { toRaw } from 'vue'

export function piniaPersistPlugin({ options, store }) {
  // ä»æœ¬åœ°å­˜å‚¨æ¢å¤çŠ¶æ€
  if (options.persist) {
    const storageKey = `pinia-${store.$id}`
    const savedState = localStorage.getItem(storageKey)
    
    if (savedState) {
      store.$patch(JSON.parse(savedState))
    }
    
    // ç›‘å¬çŠ¶æ€å˜åŒ–å¹¶ä¿å­˜
    store.$subscribe((mutation, state) => {
      localStorage.setItem(storageKey, JSON.stringify(toRaw(state)))
    })
  }
}
```

åœ¨åº”ç”¨ä¸­ä½¿ç”¨æ’ä»¶ï¼š

```js title="src/main.js"
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import { piniaPersistPlugin } from './plugins/piniaPersist'

const app = createApp(App)
const pinia = createPinia()

// æ³¨å†ŒPiniaæ’ä»¶
pinia.use(piniaPersistPlugin)

app.use(pinia)
app.mount('#app')
```

é…ç½®Storeå¯ç”¨æŒä¹…åŒ–ï¼š

```js title="src/stores/theme.js"
import { defineStore } from 'pinia'

export const useThemeStore = defineStore('theme', {
  state: () => ({
    darkMode: false,
    accentColor: '#3b82f6',
    fontSize: 'medium'
  }),
  
  actions: {
    toggleDarkMode() {
      this.darkMode = !this.darkMode
      document.documentElement.classList.toggle('dark', this.darkMode)
    },
    setAccentColor(color) {
      this.accentColor = color
      document.documentElement.style.setProperty('--accent-color', color)
    }
  },
  
  // å¯ç”¨æŒä¹…åŒ–
  persist: true
})
```

#### çƒ­é‡è½½ä¸å¼€å‘å·¥å…·

Piniaæ”¯æŒçƒ­æ¨¡å—æ›¿æ¢(HMR)å’ŒVueå¼€å‘å·¥å…·ï¼š

```js title="src/stores/counter.js"
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  actions: {
    increment() {
      this.count++
    }
  }
})

// å¯ç”¨çƒ­é‡è½½
if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useCounterStore, import.meta.hot))
}
```

## 2. Vuex - ç»å…¸çŠ¶æ€ç®¡ç†

è™½ç„¶Piniaæ˜¯æ–°ä¸€ä»£çŠ¶æ€ç®¡ç†åº“ï¼Œä½†è®¸å¤šé¡¹ç›®ä»åœ¨ä½¿ç”¨Vuexã€‚äº†è§£Vuexå¯¹ç»´æŠ¤ç°æœ‰é¡¹ç›®éå¸¸é‡è¦ã€‚

### 2.1 VuexåŸºç¡€è®¾ç½®

å®‰è£…Vuexï¼š

```bash
# å¯¹äºVue 3é¡¹ç›®
npm install vuex@next
```

åˆ›å»ºVuex storeï¼š

```js title="src/store/index.js"
import { createStore } from 'vuex'

export default createStore({
  state() {
    return {
      count: 0,
      todos: [],
      user: null
    }
  },
  
  mutations: {
    INCREMENT(state) {
      state.count++
    },
    SET_TODOS(state, todos) {
      state.todos = todos
    },
    ADD_TODO(state, todo) {
      state.todos.push(todo)
    },
    SET_USER(state, user) {
      state.user = user
    }
  },
  
  actions: {
    increment({ commit }) {
      commit('INCREMENT')
    },
    async fetchTodos({ commit }) {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos')
        const todos = await response.json()
        commit('SET_TODOS', todos)
        return todos
      } catch (error) {
        console.error('Error fetching todos:', error)
        return []
      }
    },
    async login({ commit }, credentials) {
      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        })
        
        if (!response.ok) {
          throw new Error('Login failed')
        }
        
        const data = await response.json()
        commit('SET_USER', data.user)
        localStorage.setItem('token', data.token)
        return true
      } catch (error) {
        console.error('Login error:', error)
        return false
      }
    }
  },
  
  getters: {
    completedTodos(state) {
      return state.todos.filter(todo => todo.completed)
    },
    incompleteTodos(state) {
      return state.todos.filter(todo => !todo.completed)
    },
    todoCount(state) {
      return state.todos.length
    },
    isLoggedIn(state) {
      return !!state.user
    }
  }
})
```

åœ¨Vueåº”ç”¨ä¸­æ³¨å†ŒVuexï¼š

```js title="src/main.js"
import { createApp } from 'vue'
import App from './App.vue'
import store from './store'

const app = createApp(App)
app.use(store)
app.mount('#app')
```

### 2.2 åœ¨ç»„ä»¶ä¸­ä½¿ç”¨Vuex

é€‰é¡¹å¼APIä¸­ä½¿ç”¨Vuexï¼š

```vue title="ä½¿ç”¨é€‰é¡¹å¼APIçš„Vuexç¤ºä¾‹"
<template>
  <div class="todo-app">
    <h1>å¾…åŠäº‹é¡¹ ({{ todoCount }})</h1>
    
    <div v-if="isLoading">åŠ è½½ä¸­...</div>
    <div v-else>
      <form @submit.prevent="addNewTodo">
        <input v-model="newTodo" placeholder="æ·»åŠ æ–°å¾…åŠ..." />
        <button type="submit">æ·»åŠ </button>
      </form>
      
      <ul class="todo-list">
        <li 
          v-for="todo in todos" 
          :key="todo.id"
          :class="{ completed: todo.completed }"
        >
          {{ todo.title }}
        </li>
      </ul>
      
      <div class="todo-stats">
        <p>å®Œæˆ: {{ completedTodos.length }}</p>
        <p>æœªå®Œæˆ: {{ incompleteTodos.length }}</p>
      </div>
    </div>
  </div>
</template>

<script>
import { mapState, mapGetters, mapActions } from 'vuex'

export default {
  data() {
    return {
      isLoading: false,
      newTodo: ''
    }
  },
  
  computed: {
    ...mapState(['todos']),
    ...mapGetters(['completedTodos', 'incompleteTodos', 'todoCount'])
  },
  
  methods: {
    ...mapActions(['fetchTodos']),
    
    async addNewTodo() {
      if (!this.newTodo.trim()) return
      
      this.$store.commit('ADD_TODO', {
        id: Date.now(),
        title: this.newTodo,
        completed: false
      })
      
      this.newTodo = ''
    }
  },
  
  async mounted() {
    this.isLoading = true
    await this.fetchTodos()
    this.isLoading = false
  }
}
</script>
```

ç»„åˆå¼APIä¸­ä½¿ç”¨Vuexï¼š

```vue title="ä½¿ç”¨ç»„åˆå¼APIçš„Vuexç¤ºä¾‹"
<template>
  <div class="user-profile">
    <div v-if="isLoggedIn">
      <h1>æ¬¢è¿, {{ user?.name }}</h1>
      <button @click="handleLogout">é€€å‡ºç™»å½•</button>
    </div>
    <div v-else>
      <h2>ç”¨æˆ·ç™»å½•</h2>
      <form @submit.prevent="handleLogin">
        <input v-model="email" type="email" placeholder="é‚®ç®±" required />
        <input v-model="password" type="password" placeholder="å¯†ç " required />
        <button type="submit" :disabled="isLoading">
          {{ isLoading ? 'ç™»å½•ä¸­...' : 'ç™»å½•' }}
        </button>
      </form>
    </div>
    
    <div class="counter-section">
      <h3>è®¡æ•°å™¨: {{ count }}</h3>
      <button @click="increment">å¢åŠ </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { useStore } from 'vuex'

const store = useStore()
const email = ref('')
const password = ref('')
const isLoading = ref(false)

// è®¡ç®—å±æ€§
const count = computed(() => store.state.count)
const user = computed(() => store.state.user)
const isLoggedIn = computed(() => store.getters.isLoggedIn)

// æ–¹æ³•
const increment = () => {
  store.dispatch('increment')
}

const handleLogin = async () => {
  if (!email.value || !password.value) return
  
  isLoading.value = true
  try {
    const success = await store.dispatch('login', {
      email: email.value,
      password: password.value
    })
    
    if (success) {
      email.value = ''
      password.value = ''
    }
  } finally {
    isLoading.value = false
  }
}

const handleLogout = () => {
  store.commit('SET_USER', null)
  localStorage.removeItem('token')
}
</script>
```

### 2.3 Vuexæ¨¡å—åŒ–

å¯¹äºå¤§å‹åº”ç”¨ï¼ŒVuexæ”¯æŒå°†storeåˆ†å‰²æˆæ¨¡å—ï¼š

```js title="src/store/modules/auth.js"
export default {
  namespaced: true,
  
  state: () => ({
    user: null,
    token: localStorage.getItem('token') || null,
    error: null
  }),
  
  mutations: {
    SET_USER(state, user) {
      state.user = user
    },
    SET_TOKEN(state, token) {
      state.token = token
      if (token) {
        localStorage.setItem('token', token)
      } else {
        localStorage.removeItem('token')
      }
    },
    SET_ERROR(state, error) {
      state.error = error
    }
  },
  
  actions: {
    async login({ commit }, credentials) {
      commit('SET_ERROR', null)
      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        })
        
        if (!response.ok) {
          throw new Error('Login failed')
        }
        
        const data = await response.json()
        commit('SET_USER', data.user)
        commit('SET_TOKEN', data.token)
        
        return true
      } catch (error) {
        commit('SET_ERROR', error.message)
        return false
      }
    },
    
    logout({ commit }) {
      commit('SET_USER', null)
      commit('SET_TOKEN', null)
    },
    
    async fetchUserProfile({ commit, state }) {
      if (!state.token) return null
      
      try {
        const response = await fetch('/api/profile', {
          headers: {
            'Authorization': `Bearer ${state.token}`
          }
        })
        
        if (!response.ok) {
          throw new Error('Failed to fetch profile')
        }
        
        const user = await response.json()
        commit('SET_USER', user)
        
        return user
      } catch (error) {
        commit('SET_ERROR', error.message)
        return null
      }
    }
  },
  
  getters: {
    isLoggedIn(state) {
      return !!state.user
    },
    userRole(state) {
      return state.user?.role || 'guest'
    },
    hasPermission: (state) => (permission) => {
      return state.user?.permissions?.includes(permission) || false
    }
  }
}
```

```js title="src/store/modules/products.js"
export default {
  namespaced: true,
  
  state: () => ({
    products: [],
    loading: false,
    error: null
  }),
  
  mutations: {
    SET_PRODUCTS(state, products) {
      state.products = products
    },
    SET_LOADING(state, loading) {
      state.loading = loading
    },
    SET_ERROR(state, error) {
      state.error = error
    }
  },
  
  actions: {
    async fetchProducts({ commit }) {
      commit('SET_LOADING', true)
      commit('SET_ERROR', null)
      
      try {
        const response = await fetch('/api/products')
        if (!response.ok) {
          throw new Error('Failed to fetch products')
        }
        
        const products = await response.json()
        commit('SET_PRODUCTS', products)
        return products
      } catch (error) {
        commit('SET_ERROR', error.message)
        return []
      } finally {
        commit('SET_LOADING', false)
      }
    },
    
    async fetchProductById({ commit, state }, id) {
      // å¦‚æœå·²ç»åœ¨æœ¬åœ°å­˜å‚¨ï¼Œç›´æ¥è¿”å›
      const existingProduct = state.products.find(p => p.id === id)
      if (existingProduct) return existingProduct
      
      // å¦åˆ™ä»APIè·å–
      commit('SET_LOADING', true)
      commit('SET_ERROR', null)
      
      try {
        const response = await fetch(`/api/products/${id}`)
        if (!response.ok) {
          throw new Error(`Failed to fetch product ${id}`)
        }
        
        const product = await response.json()
        // æ·»åŠ åˆ°æœ¬åœ°äº§å“åˆ—è¡¨
        commit('SET_PRODUCTS', [...state.products, product])
        return product
      } catch (error) {
        commit('SET_ERROR', error.message)
        return null
      } finally {
        commit('SET_LOADING', false)
      }
    }
  },
  
  getters: {
    featuredProducts(state) {
      return state.products.filter(p => p.featured)
    },
    productById: (state) => (id) => {
      return state.products.find(p => p.id === id)
    }
  }
}
```

ç»„åˆæ¨¡å—åˆ°ä¸»storeï¼š

```js title="src/store/index.js"
import { createStore } from 'vuex'
import auth from './modules/auth'
import products from './modules/products'
import cart from './modules/cart'

export default createStore({
  modules: {
    auth,
    products,
    cart
  }
})
```

åœ¨ç»„ä»¶ä¸­ä½¿ç”¨æ¨¡å—åŒ–storeï¼š

```vue
<template>
  <div>
    <!-- å•†å“åˆ—è¡¨ -->
    <div v-if="loading">åŠ è½½ä¸­...</div>
    <div v-else-if="error">{{ error }}</div>
    <div v-else class="product-grid">
      <div 
        v-for="product in products" 
        :key="product.id"
        class="product-card"
      >
        <h3>{{ product.name }}</h3>
        <p>{{ product.price | currency }}</p>
        <button @click="addToCart(product.id)">åŠ å…¥è´­ç‰©è½¦</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, onMounted } from 'vue'
import { useStore } from 'vuex'

const store = useStore()

// æ˜ å°„æ¨¡å—çŠ¶æ€
const products = computed(() => store.state.products.products)
const loading = computed(() => store.state.products.loading)
const error = computed(() => store.state.products.error)

// æ–¹æ³•
const fetchProducts = () => store.dispatch('products/fetchProducts')
const addToCart = (productId) => store.dispatch('cart/addToCart', productId)

onMounted(fetchProducts)
</script>
```

## 3. Composition APIçŠ¶æ€ç®¡ç†

å¯¹äºä¸­å°å‹åº”ç”¨ï¼Œå¯ä»¥ä½¿ç”¨Vue 3çš„Composition APIåˆ›å»ºè‡ªå®šä¹‰çŠ¶æ€ç®¡ç†æ–¹æ¡ˆï¼Œæ— éœ€å¼•å…¥é¢å¤–åº“ã€‚

### 3.1 ç®€å•çŠ¶æ€ç®¡ç†

ä½¿ç”¨`provide/inject`å’Œ`reactive`åˆ›å»ºç®€å•çŠ¶æ€ç®¡ç†ï¼š

```js title="src/composables/useThemeState.js"
import { reactive, provide, inject } from 'vue'

// åˆ›å»ºä¸€ä¸ªå”¯ä¸€çš„key
const ThemeStateSymbol = Symbol('ThemeState')

export function provideThemeState() {
  // åˆ›å»ºå“åº”å¼çŠ¶æ€
  const state = reactive({
    darkMode: false,
    fontSize: 'medium',
    colorScheme: 'blue'
  })
  
  // ä¸»é¢˜åˆ‡æ¢å‡½æ•°
  function toggleDarkMode() {
    state.darkMode = !state.darkMode
    document.documentElement.classList.toggle('dark', state.darkMode)
  }
  
  // è®¾ç½®å­—ä½“å¤§å°
  function setFontSize(size) {
    state.fontSize = size
    document.documentElement.setAttribute('data-font-size', size)
  }
  
  // è®¾ç½®é¢œè‰²ä¸»é¢˜
  function setColorScheme(scheme) {
    state.colorScheme = scheme
    document.documentElement.setAttribute('data-color-scheme', scheme)
  }
  
  // æä¾›çŠ¶æ€å’Œæ–¹æ³•
  provide(ThemeStateSymbol, {
    state,
    toggleDarkMode,
    setFontSize,
    setColorScheme
  })
}

export function useThemeState() {
  // æ³¨å…¥çŠ¶æ€å’Œæ–¹æ³•
  const theme = inject(ThemeStateSymbol)
  
  if (!theme) {
    throw new Error('useThemeState() must be used within a component that calls provideThemeState()')
  }
  
  return theme
}
```

åœ¨åº”ç”¨ä¸­ä½¿ç”¨ï¼š

```vue title="src/App.vue"
<template>
  <div :class="{ 'dark-theme': state.darkMode }">
    <header>
      <button @click="toggleDarkMode">
        {{ state.darkMode ? 'åˆ‡æ¢åˆ°äº®è‰²æ¨¡å¼' : 'åˆ‡æ¢åˆ°æš—è‰²æ¨¡å¼' }}
      </button>
      
      <div class="font-size-controls">
        <button @click="setFontSize('small')">å°</button>
        <button @click="setFontSize('medium')">ä¸­</button>
        <button @click="setFontSize('large')">å¤§</button>
      </div>
    </header>
    
    <router-view />
  </div>
</template>

<script setup>
import { provideThemeState, useThemeState } from './composables/useThemeState'

// æä¾›ä¸»é¢˜çŠ¶æ€
provideThemeState()

// ä½¿ç”¨ä¸»é¢˜çŠ¶æ€
const { state, toggleDarkMode, setFontSize } = useThemeState()
</script>
```

### 3.2 å®Œæ•´çŠ¶æ€ç®¡ç†

åˆ›å»ºä¸€ä¸ªå…·æœ‰ç±»ä¼¼Vuex/Piniaç‰¹æ€§çš„çŠ¶æ€ç®¡ç†è§£å†³æ–¹æ¡ˆï¼š

```js title="src/composables/createStore.js"
import { reactive, readonly, provide, inject, computed, watch } from 'vue'

export function createStore(options) {
  // åˆ›å»ºå”¯ä¸€symbol
  const storeSymbol = Symbol('store')
  
  function useCreateStore() {
    // çŠ¶æ€åˆå§‹åŒ–
    const state = reactive(typeof options.state === 'function' ? options.state() : options.state || {})
    
    // å¤„ç†getters
    const getters = {}
    if (options.getters) {
      Object.keys(options.getters).forEach(getterName => {
        getters[getterName] = computed(() => options.getters[getterName](state, getters))
      })
    }
    
    // å¤„ç†actions
    const actions = {}
    if (options.actions) {
      Object.keys(options.actions).forEach(actionName => {
        actions[actionName] = (...args) => options.actions[actionName]({ state, getters, actions }, ...args)
      })
    }
    
    // æŒä¹…åŒ–æ”¯æŒ
    if (options.persist?.enabled) {
      const storageKey = options.persist.key || storeSymbol.toString()
      const storage = options.persist.storage || localStorage
      
      // ä»å­˜å‚¨ä¸­æ¢å¤çŠ¶æ€
      const savedState = storage.getItem(storageKey)
      if (savedState) {
        const parsed = JSON.parse(savedState)
        Object.assign(state, parsed)
      }
      
      // ä¿å­˜çŠ¶æ€åˆ°å­˜å‚¨
      watch(
        () => JSON.parse(JSON.stringify(state)),
        (newState) => {
          storage.setItem(storageKey, JSON.stringify(newState))
        },
        { deep: true }
      )
    }
    
    return {
      state: readonly(state),
      getters: readonly(getters),
      actions,
      // å†…éƒ¨ä½¿ç”¨ï¼Œç”¨äºé‡ç½®çŠ¶æ€
      _reset: () => Object.assign(state, typeof options.state === 'function' ? options.state() : options.state || {})
    }
  }
  
  const store = useCreateStore()
  
  // æä¾›store
  function provideStore() {
    provide(storeSymbol, store)
    return store
  }
  
  // æ³¨å…¥store
  function useStore() {
    const injectedStore = inject(storeSymbol, null)
    if (!injectedStore) {
      throw new Error('Store not provided. Make sure to call provideStore() in a parent component.')
    }
    return injectedStore
  }
  
  return {
    provideStore,
    useStore
  }
}
```

ä½¿ç”¨è‡ªå®šä¹‰storeï¼š

```js title="src/stores/userStore.js"
import { createStore } from '../composables/createStore'

export const { provideStore: provideUserStore, useStore: useUserStore } = createStore({
  state: () => ({
    user: null,
    token: localStorage.getItem('token') || null,
    isLoading: false,
    error: null
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token && !!state.user,
    username: (state) => state.user?.name || 'Guest',
    userRole: (state) => state.user?.role || 'guest'
  },
  
  actions: {
    async login({ state }, credentials) {
      state.isLoading = true
      state.error = null
      
      try {
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        })
        
        if (!response.ok) {
          throw new Error('Login failed')
        }
        
        const data = await response.json()
        state.user = data.user
        state.token = data.token
        localStorage.setItem('token', data.token)
        
        return true
      } catch (error) {
        state.error = error.message
        return false
      } finally {
        state.isLoading = false
      }
    },
    
    logout({ state }) {
      state.user = null
      state.token = null
      localStorage.removeItem('token')
    }
  },
  
  persist: {
    enabled: true,
    key: 'user-store',
    storage: localStorage
  }
})
```

åœ¨åº”ç”¨ä¸­ä½¿ç”¨ï¼š

```vue title="src/App.vue"
<template>
  <div class="app">
    <header>
      <nav>
        <span v-if="isLoggedIn">æ¬¢è¿, {{ username }}</span>
        <button v-if="isLoggedIn" @click="actions.logout">é€€å‡ºç™»å½•</button>
        <router-link v-else to="/login">ç™»å½•</router-link>
      </nav>
    </header>
    
    <router-view />
  </div>
</template>

<script setup>
import { provideUserStore, useUserStore } from './stores/userStore'

// æä¾›ç”¨æˆ·store
provideUserStore()

// ä½¿ç”¨ç”¨æˆ·store
const { state, getters, actions } = useUserStore()
const { isLoggedIn, username } = getters
</script>
```

## 4. çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ

### 4.1 ä½•æ—¶ä½¿ç”¨çŠ¶æ€ç®¡ç†

çŠ¶æ€ç®¡ç†ä¸æ˜¯å¿…é¡»çš„ï¼Œåº”æ ¹æ®åº”ç”¨å¤æ‚åº¦å†³å®šï¼š

1. **å°å‹åº”ç”¨**: ä½¿ç”¨propsã€emitså’Œç®€å•çš„provide/inject
2. **ä¸­å‹åº”ç”¨**: ä½¿ç”¨Composition APIçŠ¶æ€ç®¡ç†æˆ–è½»é‡çº§Pinia
3. **å¤§å‹åº”ç”¨**: ä½¿ç”¨Piniaæˆ–Vuexè¿›è¡Œæ¨¡å—åŒ–çŠ¶æ€ç®¡ç†

### 4.2 çŠ¶æ€ç»„ç»‡åŸåˆ™

1. **å•ä¸€èŒè´£**: æ¯ä¸ªstoreåªç®¡ç†ä¸€ä¸ªé¢†åŸŸçš„çŠ¶æ€
2. **æœ€å°åŒ–çŠ¶æ€**: åªå­˜å‚¨å¿…è¦çš„çŠ¶æ€ï¼Œé¿å…å†—ä½™æ•°æ®
3. **è§„èŒƒå‘½å**: ä½¿ç”¨ä¸€è‡´çš„å‘½åçº¦å®š
4. **é¿å…é‡å¤**: é¿å…åœ¨å¤šä¸ªstoreä¸­å­˜å‚¨ç›¸åŒæ•°æ®
5. **å±‚æ¬¡ç»“æ„**: å¤æ‚çŠ¶æ€é‡‡ç”¨åˆç†çš„å±‚æ¬¡ç»“æ„

### 4.3 æ€§èƒ½ä¼˜åŒ–

1. **é¿å…è¿‡åº¦è®¢é˜…**: ä»…è®¢é˜…éœ€è¦çš„çŠ¶æ€
2. **ä½¿ç”¨è®¡ç®—å±æ€§**: ç¼“å­˜æ´¾ç”ŸçŠ¶æ€
3. **æ‡’åŠ è½½æ¨¡å—**: æŒ‰éœ€åŠ è½½çŠ¶æ€æ¨¡å—
4. **ç²¾ç»†åŒ–æ›´æ–°**: é¿å…æ•´ä½“çŠ¶æ€å¯¹è±¡æ›¿æ¢
5. **é˜²æŠ–/èŠ‚æµ**: é¢‘ç¹å˜åŒ–çš„çŠ¶æ€ä½¿ç”¨é˜²æŠ–/èŠ‚æµ

### 4.4 è°ƒè¯•æŠ€å·§

1. **ä½¿ç”¨Vueå¼€å‘å·¥å…·**: Vue Devtoolså¯æ£€æŸ¥Pinia/VuexçŠ¶æ€
2. **æ—¶é—´æ—…è¡Œè°ƒè¯•**: ä½¿ç”¨å¼€å‘å·¥å…·çš„æ—¶é—´æ—…è¡ŒåŠŸèƒ½
3. **æ—¥å¿—æ’ä»¶**: æ·»åŠ æ—¥å¿—æ’ä»¶è®°å½•çŠ¶æ€å˜åŒ–
4. **çŠ¶æ€å¿«ç…§**: åœ¨å…³é”®ç‚¹ä¿å­˜çŠ¶æ€å¿«ç…§
5. **ä¸­é—´ä»¶**: ä½¿ç”¨ä¸­é—´ä»¶æ‹¦æˆªçŠ¶æ€æ“ä½œ 