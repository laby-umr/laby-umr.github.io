---
sidebar_position: 1
title: Vue.jsç°ä»£å¼€å‘å®è·µæŒ‡å—
description: æ·±å…¥è§£æVue 3ç»„åˆå¼APIã€å“åº”å¼ç³»ç»Ÿã€ç»„ä»¶åŒ–å¼€å‘ä¸ç”Ÿæ€ç³»ç»Ÿæœ€ä½³å®è·µ
authors: [Laby]
tags: [Vue.js, ç»„åˆå¼API, å“åº”å¼ç³»ç»Ÿ, ç»„ä»¶åŒ–, Pinia, Nuxt.js, æ€§èƒ½ä¼˜åŒ–]
last_update:
  date: 2025-08-14
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# Vue.jsç°ä»£å¼€å‘å®è·µæŒ‡å—

Vue.jsæ˜¯ä¸€ä¸ªæ¸è¿›å¼JavaScriptæ¡†æ¶ï¼Œä»¥å…¶ç®€æ´çš„APIã€ä¼˜ç§€çš„æ€§èƒ½å’Œä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿæˆä¸ºç°ä»£å‰ç«¯å¼€å‘çš„çƒ­é—¨é€‰æ‹©ã€‚Vue 3å¼•å…¥çš„ç»„åˆå¼APIã€æ›´å¥½çš„TypeScriptæ”¯æŒå’Œæ€§èƒ½ä¼˜åŒ–ï¼Œä½¿å…¶æˆä¸ºæ„å»ºç°ä»£Webåº”ç”¨çš„ç†æƒ³é€‰æ‹©ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**Vue.js = æ¸è¿›å¼ + å“åº”å¼ + ç»„ä»¶åŒ– + ç”Ÿæ€ä¸°å¯Œ**
- ğŸ¯ **æ¸è¿›å¼æ¡†æ¶**ï¼šå¯ä»¥é€æ­¥é‡‡ç”¨ï¼Œä»ç®€å•é¡µé¢åˆ°å¤æ‚åº”ç”¨
- âš¡ **å“åº”å¼ç³»ç»Ÿ**ï¼šåŸºäºProxyçš„é«˜æ€§èƒ½å“åº”å¼æ•°æ®ç»‘å®š
- ğŸ§© **ç»„ä»¶åŒ–å¼€å‘**ï¼šå•æ–‡ä»¶ç»„ä»¶ï¼Œå¼€å‘ä½“éªŒä¼˜ç§€
- ğŸ”§ **ç»„åˆå¼API**ï¼šæ›´å¥½çš„é€»è¾‘å¤ç”¨å’ŒTypeScriptæ”¯æŒ
- ğŸ“¦ **ä¸°å¯Œç”Ÿæ€**ï¼šVue Routerã€Piniaã€Nuxt.jsç­‰å®Œæ•´è§£å†³æ–¹æ¡ˆ
- ğŸ¨ **å¼€å‘ä½“éªŒ**ï¼šä¼˜ç§€çš„å¼€å‘å·¥å…·å’Œè°ƒè¯•æ”¯æŒ
:::

## 1. Vue 3æ ¸å¿ƒç‰¹æ€§ä¸æ¶æ„

### 1.1 Vue 3æ¶æ„æ¼”è¿›

Vue 3ç›¸æ¯”Vue 2åœ¨æ¶æ„ä¸Šæœ‰äº†é‡å¤§æ”¹è¿›ï¼Œå¼•å…¥äº†ç»„åˆå¼APIã€æ›´å¥½çš„æ€§èƒ½å’ŒTypeScriptæ”¯æŒã€‚

```mermaid
graph TB
    subgraph "Vue 3æ¶æ„å›¾"
        subgraph "ç¼–è¯‘æ—¶"
            SFC[å•æ–‡ä»¶ç»„ä»¶<br/>*.vue]
            COMPILER[Vueç¼–è¯‘å™¨<br/>Template â†’ Render Function]
            OPTIMIZER[ç¼–è¯‘ä¼˜åŒ–<br/>é™æ€æå‡ã€è¡¥ä¸æ ‡è®°]
        end
        
        subgraph "è¿è¡Œæ—¶"
            REACTIVITY[å“åº”å¼ç³»ç»Ÿ<br/>Proxy-based]
            RENDERER[æ¸²æŸ“å™¨<br/>Virtual DOM]
            SCHEDULER[è°ƒåº¦å™¨<br/>å¼‚æ­¥æ›´æ–°é˜Ÿåˆ—]
        end
        
        subgraph "ç»„åˆå¼API"
            COMPOSITION[ç»„åˆå¼API<br/>setup(), ref(), reactive()]
            LIFECYCLE[ç”Ÿå‘½å‘¨æœŸé’©å­<br/>onMounted(), onUpdated()]
            COMPUTED[è®¡ç®—å±æ€§<br/>computed(), watch()]
        end
    end
    
    SFC --> COMPILER
    COMPILER --> OPTIMIZER
    OPTIMIZER --> RENDERER
    RENDERER --> REACTIVITY
    REACTIVITY --> SCHEDULER
```

#### Vue 2 vs Vue 3 å¯¹æ¯”

| ç‰¹æ€§å¯¹æ¯” | Vue 2 | Vue 3 | æ”¹è¿›è¯´æ˜ |
|---------|-------|-------|----------|
| **å“åº”å¼ç³»ç»Ÿ** | Object.defineProperty | Proxy | æ›´å¥½çš„æ€§èƒ½ï¼Œæ”¯æŒæ•°ç»„å’Œå¯¹è±¡ |
| **APIé£æ ¼** | é€‰é¡¹å¼API | ç»„åˆå¼API + é€‰é¡¹å¼API | æ›´å¥½çš„é€»è¾‘å¤ç”¨å’ŒTypeScriptæ”¯æŒ |
| **æ€§èƒ½** | åŸºå‡†æ€§èƒ½ | 2xæ›´å¿« | ç¼–è¯‘ä¼˜åŒ–ã€Tree-shaking |
| **åŒ…å¤§å°** | ~34KB | ~16KB | æ›´å¥½çš„Tree-shaking |
| **TypeScript** | éƒ¨åˆ†æ”¯æŒ | å®Œå…¨æ”¯æŒ | åŸç”ŸTypeScriptæ”¯æŒ |
| **å¤šæ ¹èŠ‚ç‚¹** | ä¸æ”¯æŒ | æ”¯æŒ | Fragmentæ”¯æŒ |
### 1.2 ç»„åˆå¼APIæ·±åº¦è§£æ

ç»„åˆå¼APIæ˜¯Vue 3çš„æ ¸å¿ƒç‰¹æ€§ï¼Œæä¾›äº†æ›´çµæ´»çš„é€»è¾‘ç»„ç»‡æ–¹å¼å’Œæ›´å¥½çš„TypeScriptæ”¯æŒã€‚

<Tabs>
<TabItem value="composition-basics" label="ç»„åˆå¼APIåŸºç¡€">

#### åŸºç¡€ç»„åˆå¼APIä½¿ç”¨

```vue title="ç»„åˆå¼APIåŸºç¡€ç¤ºä¾‹"
<template>
  <div class="user-profile">
    <!-- ç”¨æˆ·ä¿¡æ¯å±•ç¤º -->
    <div class="user-info" v-if="!loading">
      <img :src="user?.avatar" :alt="user?.name" class="avatar" />
      <div class="details">
        <h2>{{ user?.name }}</h2>
        <p>{{ user?.email }}</p>
        <span class="role">{{ user?.role }}</span>
      </div>
    </div>
    
    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-else class="loading">
      <div class="spinner"></div>
      <p>åŠ è½½ä¸­...</p>
    </div>
    
    <!-- é”™è¯¯çŠ¶æ€ -->
    <div v-if="error" class="error">
      <p>{{ error }}</p>
      <button @click="retry">é‡è¯•</button>
    </div>
    
    <!-- ç”¨æˆ·æ“ä½œ -->
    <div class="actions" v-if="user">
      <button @click="toggleEdit" class="btn-primary">
        {{ isEditing ? 'å–æ¶ˆç¼–è¾‘' : 'ç¼–è¾‘èµ„æ–™' }}
      </button>
      <button @click="logout" class="btn-secondary">ç™»å‡º</button>
    </div>
    
    <!-- ç¼–è¾‘è¡¨å• -->
    <div v-if="isEditing" class="edit-form">
      <form @submit.prevent="saveUser">
        <div class="form-group">
          <label for="name">å§“åï¼š</label>
          <input
            id="name"
            v-model="editForm.name"
            type="text"
            required
            class="form-input"
          />
        </div>
        
        <div class="form-group">
          <label for="email">é‚®ç®±ï¼š</label>
          <input
            id="email"
            v-model="editForm.email"
            type="email"
            required
            class="form-input"
          />
        </div>
        
        <div class="form-actions">
          <button type="submit" :disabled="saving" class="btn-primary">
            {{ saving ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜' }}
          </button>
          <button type="button" @click="cancelEdit" class="btn-secondary">
            å–æ¶ˆ
          </button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, onMounted, watch, nextTick } from 'vue'
import { useRouter } from 'vue-router'
import { useUserStore } from '@/stores/user'

// ç±»å‹å®šä¹‰
interface User {
  id: number
  name: string
  email: string
  avatar: string
  role: 'admin' | 'user' | 'guest'
}

interface EditForm {
  name: string
  email: string
}

// å“åº”å¼æ•°æ®
const user = ref<User | null>(null)
const loading = ref(true)
const error = ref<string | null>(null)
const isEditing = ref(false)
const saving = ref(false)

// å“åº”å¼å¯¹è±¡
const editForm = reactive<EditForm>({
  name: '',
  email: ''
})

// ç»„åˆå¼å‡½æ•°
const router = useRouter()
const userStore = useUserStore()

// è®¡ç®—å±æ€§
const isAdmin = computed(() => user.value?.role === 'admin')
const canEdit = computed(() => user.value && (isAdmin.value || user.value.id === userStore.currentUserId))

// ç”Ÿå‘½å‘¨æœŸé’©å­
onMounted(async () => {
  await fetchUser()
})

// ä¾¦å¬å™¨
watch(user, (newUser) => {
  if (newUser) {
    editForm.name = newUser.name
    editForm.email = newUser.email
  }
}, { immediate: true })

// æ–¹æ³•å®šä¹‰
const fetchUser = async () => {
  try {
    loading.value = true
    error.value = null
    
    const response = await fetch('/api/user/profile')
    if (!response.ok) {
      throw new Error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥')
    }
    
    user.value = await response.json()
  } catch (err) {
    error.value = err instanceof Error ? err.message : 'æœªçŸ¥é”™è¯¯'
  } finally {
    loading.value = false
  }
}

const toggleEdit = () => {
  if (!canEdit.value) return
  
  isEditing.value = !isEditing.value
  
  if (isEditing.value) {
    // è¿›å…¥ç¼–è¾‘æ¨¡å¼æ—¶ï¼Œèšç„¦åˆ°ç¬¬ä¸€ä¸ªè¾“å…¥æ¡†
    nextTick(() => {
      const firstInput = document.querySelector('.edit-form input') as HTMLInputElement
      firstInput?.focus()
    })
  }
}

const saveUser = async () => {
  if (!user.value) return
  
  try {
    saving.value = true
    
    const response = await fetch(`/api/users/${user.value.id}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(editForm)
    })
    
    if (!response.ok) {
      throw new Error('ä¿å­˜å¤±è´¥')
    }
    
    const updatedUser = await response.json()
    user.value = updatedUser
    isEditing.value = false
    
    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
    userStore.showMessage('ä¿å­˜æˆåŠŸ', 'success')
  } catch (err) {
    error.value = err instanceof Error ? err.message : 'ä¿å­˜å¤±è´¥'
  } finally {
    saving.value = false
  }
}

const cancelEdit = () => {
  if (user.value) {
    editForm.name = user.value.name
    editForm.email = user.value.email
  }
  isEditing.value = false
}

const retry = () => {
  fetchUser()
}

const logout = async () => {
  await userStore.logout()
  router.push('/login')
}
</script>

<style scoped>
.user-profile {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
}

.user-info {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 20px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: #fff;
}

.avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  object-fit: cover;
}

.details h2 {
  margin: 0 0 8px 0;
  color: #333;
}

.details p {
  margin: 0 0 8px 0;
  color: #666;
}

.role {
  display: inline-block;
  padding: 4px 8px;
  background: #e3f2fd;
  color: #1976d2;
  border-radius: 4px;
  font-size: 12px;
}

.loading, .error {
  text-align: center;
  padding: 40px;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 16px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.actions {
  display: flex;
  gap: 12px;
  margin-top: 20px;
}

.edit-form {
  margin-top: 20px;
  padding: 20px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  background: #f9f9f9;
}

.form-group {
  margin-bottom: 16px;
}

.form-group label {
  display: block;
  margin-bottom: 4px;
  font-weight: 500;
}

.form-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

.form-input:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.form-actions {
  display: flex;
  gap: 12px;
}

.btn-primary, .btn-secondary {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
}

.btn-primary {
  background: #3498db;
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: #2980b9;
}

.btn-primary:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
}

.btn-secondary {
  background: #95a5a6;
  color: white;
}

.btn-secondary:hover {
  background: #7f8c8d;
}

.error {
  color: #e74c3c;
}
</style>
```

</TabItem>
<TabItem value="composables" label="ç»„åˆå¼å‡½æ•°">

#### è‡ªå®šä¹‰ç»„åˆå¼å‡½æ•°

```typescript title="ç»„åˆå¼å‡½æ•°æœ€ä½³å®è·µ"
// composables/useApi.ts
import { ref, computed } from 'vue'

export interface ApiState<T> {
  data: Ref<T | null>
  loading: Ref<boolean>
  error: Ref<string | null>
  execute: (...args: any[]) => Promise<T>
  reset: () => void
}

export function useApi<T>(
  apiFunction: (...args: any[]) => Promise<T>
): ApiState<T> {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const execute = async (...args: any[]): Promise<T> => {
    try {
      loading.value = true
      error.value = null
      
      const result = await apiFunction(...args)
      data.value = result
      return result
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'è¯·æ±‚å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  const reset = () => {
    data.value = null
    loading.value = false
    error.value = null
  }
  
  return {
    data,
    loading,
    error,
    execute,
    reset
  }
}

// composables/useLocalStorage.ts
import { ref, watch, Ref } from 'vue'

export function useLocalStorage<T>(
  key: string,
  defaultValue: T
): [Ref<T>, (value: T) => void] {
  const storedValue = localStorage.getItem(key)
  const initialValue = storedValue ? JSON.parse(storedValue) : defaultValue
  
  const state = ref<T>(initialValue)
  
  const setValue = (value: T) => {
    state.value = value
  }
  
  watch(
    state,
    (newValue) => {
      localStorage.setItem(key, JSON.stringify(newValue))
    },
    { deep: true }
  )
  
  return [state, setValue]
}

// composables/useDebounce.ts
import { ref, watch, Ref } from 'vue'

export function useDebounce<T>(
  value: Ref<T>,
  delay: number = 300
): Ref<T> {
  const debouncedValue = ref<T>(value.value)
  
  watch(value, (newValue) => {
    const timer = setTimeout(() => {
      debouncedValue.value = newValue
    }, delay)
    
    return () => clearTimeout(timer)
  })
  
  return debouncedValue
}

// composables/useIntersectionObserver.ts
import { ref, onMounted, onUnmounted, Ref } from 'vue'

export function useIntersectionObserver(
  target: Ref<Element | null>,
  options: IntersectionObserverInit = {}
) {
  const isIntersecting = ref(false)
  const isSupported = typeof IntersectionObserver !== 'undefined'
  
  let observer: IntersectionObserver | null = null
  
  const cleanup = () => {
    if (observer) {
      observer.disconnect()
      observer = null
    }
  }
  
  const observe = () => {
    if (!isSupported || !target.value) return
    
    cleanup()
    
    observer = new IntersectionObserver(([entry]) => {
      isIntersecting.value = entry.isIntersecting
    }, options)
    
    observer.observe(target.value)
  }
  
  onMounted(observe)
  onUnmounted(cleanup)
  
  return {
    isIntersecting,
    isSupported,
    observe,
    cleanup
  }
}

// ä½¿ç”¨ç¤ºä¾‹
export default defineComponent({
  setup() {
    // APIè°ƒç”¨
    const { data: users, loading, error, execute: fetchUsers } = useApi(
      () => fetch('/api/users').then(res => res.json())
    )
    
    // æœ¬åœ°å­˜å‚¨
    const [preferences, setPreferences] = useLocalStorage('userPreferences', {
      theme: 'light',
      language: 'zh-CN'
    })
    
    // é˜²æŠ–æœç´¢
    const searchQuery = ref('')
    const debouncedQuery = useDebounce(searchQuery, 500)
    
    watch(debouncedQuery, (query) => {
      if (query) {
        // æ‰§è¡Œæœç´¢
        console.log('æœç´¢:', query)
      }
    })
    
    // æ— é™æ»šåŠ¨
    const loadMoreTrigger = ref<HTMLElement | null>(null)
    const { isIntersecting } = useIntersectionObserver(loadMoreTrigger)
    
    watch(isIntersecting, (intersecting) => {
      if (intersecting) {
        // åŠ è½½æ›´å¤šæ•°æ®
        console.log('åŠ è½½æ›´å¤š')
      }
    })
    
    onMounted(() => {
      fetchUsers()
    })
    
    return {
      users,
      loading,
      error,
      preferences,
      setPreferences,
      searchQuery,
      loadMoreTrigger
    }
  }
})
```

</TabItem>
<TabItem value="reactivity" label="å“åº”å¼ç³»ç»Ÿ">

#### å“åº”å¼ç³»ç»Ÿæ·±å…¥ç†è§£

```typescript title="Vue 3å“åº”å¼ç³»ç»Ÿè¯¦è§£"
import { 
  ref, 
  reactive, 
  computed, 
  watch, 
  watchEffect,
  readonly,
  shallowRef,
  shallowReactive,
  toRef,
  toRefs,
  unref,
  isRef,
  isReactive
} from 'vue'

// 1. åŸºç¡€å“åº”å¼API
export function useReactivityDemo() {
  // ref: åŸºç¡€ç±»å‹å“åº”å¼
  const count = ref(0)
  const message = ref('Hello Vue 3')
  
  // reactive: å¯¹è±¡å“åº”å¼
  const state = reactive({
    user: {
      name: 'John',
      age: 30
    },
    settings: {
      theme: 'dark',
      notifications: true
    }
  })
  
  // readonly: åªè¯»å“åº”å¼
  const readonlyState = readonly(state)
  
  // è®¡ç®—å±æ€§
  const doubleCount = computed(() => count.value * 2)
  const userInfo = computed(() => `${state.user.name} (${state.user.age}å²)`)
  
  // å¯å†™è®¡ç®—å±æ€§
  const fullName = computed({
    get: () => `${state.user.name}`,
    set: (value: string) => {
      state.user.name = value
    }
  })
  
  return {
    count,
    message,
    state,
    readonlyState,
    doubleCount,
    userInfo,
    fullName
  }
}

// 2. é«˜çº§å“åº”å¼æ¨¡å¼
export function useAdvancedReactivity() {
  // æµ…å±‚å“åº”å¼
  const shallowState = shallowReactive({
    deep: {
      nested: {
        value: 1
      }
    }
  })
  
  const shallowCount = shallowRef({ count: 0 })
  
  // toRef å’Œ toRefs
  const state = reactive({
    name: 'Vue',
    version: '3.0',
    features: ['Composition API', 'TypeScript']
  })
  
  const name = toRef(state, 'name')
  const { version, features } = toRefs(state)
  
  // å“åº”å¼åˆ¤æ–­
  const checkReactivity = () => {
    console.log('count is ref:', isRef(count))
    console.log('state is reactive:', isReactive(state))
    console.log('unref count:', unref(count))
  }
  
  return {
    shallowState,
    shallowCount,
    name,
    version,
    features,
    checkReactivity
  }
}

// 3. ä¾¦å¬å™¨æ¨¡å¼
export function useWatchers() {
  const count = ref(0)
  const state = reactive({
    name: 'Vue',
    nested: {
      value: 1
    }
  })
  
  // åŸºç¡€ä¾¦å¬å™¨
  watch(count, (newValue, oldValue) => {
    console.log(`count changed from ${oldValue} to ${newValue}`)
  })
  
  // ä¾¦å¬å¤šä¸ªæº
  watch([count, () => state.name], ([newCount, newName], [oldCount, oldName]) => {
    console.log('Multiple sources changed:', {
      count: { old: oldCount, new: newCount },
      name: { old: oldName, new: newName }
    })
  })
  
  // æ·±åº¦ä¾¦å¬
  watch(
    () => state.nested,
    (newValue, oldValue) => {
      console.log('Nested object changed:', newValue)
    },
    { deep: true }
  )
  
  // ç«‹å³æ‰§è¡Œä¾¦å¬å™¨
  watch(
    count,
    (value) => {
      console.log('Immediate watch:', value)
    },
    { immediate: true }
  )
  
  // watchEffect: è‡ªåŠ¨è¿½è¸ªä¾èµ–
  const stopWatcher = watchEffect(() => {
    console.log(`Count is ${count.value}, name is ${state.name}`)
  })
  
  // åœæ­¢ä¾¦å¬å™¨
  const stopAllWatchers = () => {
    stopWatcher()
  }
  
  // å¼‚æ­¥ä¾¦å¬å™¨
  watchEffect(async (onInvalidate) => {
    const controller = new AbortController()
    
    onInvalidate(() => {
      controller.abort()
    })
    
    try {
      const response = await fetch(`/api/data/${count.value}`, {
        signal: controller.signal
      })
      const data = await response.json()
      console.log('Fetched data:', data)
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Fetch error:', error)
      }
    }
  })
  
  return {
    count,
    state,
    stopAllWatchers
  }
}

// 4. å“åº”å¼å·¥å…·å‡½æ•°
export function useReactivityUtils() {
  // å“åº”å¼è½¬æ¢å·¥å…·
  const convertToReactive = <T extends object>(obj: T): T => {
    return reactive(obj)
  }
  
  // æ·±åº¦åªè¯»è½¬æ¢
  const makeDeepReadonly = <T>(obj: T): Readonly<T> => {
    return readonly(obj)
  }
  
  // å“åº”å¼æ•°æ®å…‹éš†
  const cloneReactive = <T extends object>(source: T): T => {
    return reactive(JSON.parse(JSON.stringify(source)))
  }
  
  // å“åº”å¼æ•°æ®åˆå¹¶
  const mergeReactive = <T extends object, U extends object>(
    target: T,
    source: U
  ): T & U => {
    return reactive({ ...target, ...source })
  }
  
  return {
    convertToReactive,
    makeDeepReadonly,
    cloneReactive,
    mergeReactive
  }
}

// ä½¿ç”¨ç¤ºä¾‹ç»„ä»¶
export default defineComponent({
  setup() {
    const { count, state, doubleCount } = useReactivityDemo()
    const { name, version } = useAdvancedReactivity()
    const { stopAllWatchers } = useWatchers()
    
    // ç»„åˆå¤šä¸ªç»„åˆå¼å‡½æ•°
    const increment = () => {
      count.value++
    }
    
    const updateUser = () => {
      state.user.name = 'Jane'
      state.user.age = 25
    }
    
    onUnmounted(() => {
      stopAllWatchers()
    })
    
    return {
      count,
      state,
      doubleCount,
      name,
      version,
      increment,
      updateUser
    }
  }
})
```

</TabItem>
</Tabs>

## 2. Vueç»„ä»¶åŒ–å¼€å‘

### 2.1 å•æ–‡ä»¶ç»„ä»¶(SFC)æ¶æ„

Vueçš„å•æ–‡ä»¶ç»„ä»¶æä¾›äº†ä¼˜ç§€çš„å¼€å‘ä½“éªŒï¼Œå°†æ¨¡æ¿ã€é€»è¾‘å’Œæ ·å¼å°è£…åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚

```mermaid
graph TB
    subgraph "Vueå•æ–‡ä»¶ç»„ä»¶ç»“æ„"
        SFC[*.vueæ–‡ä»¶]
        SFC --> TEMPLATE[<template>æ¨¡æ¿]
        SFC --> SCRIPT[<script setup>é€»è¾‘]
        SFC --> STYLE[<style scoped>æ ·å¼]
        
        TEMPLATE --> DIRECTIVES[æŒ‡ä»¤ç³»ç»Ÿ]
        TEMPLATE --> INTERPOLATION[æ’å€¼è¡¨è¾¾å¼]
        TEMPLATE --> EVENTS[äº‹ä»¶å¤„ç†]
        
        SCRIPT --> COMPOSITION[ç»„åˆå¼API]
        SCRIPT --> PROPS[Propså®šä¹‰]
        SCRIPT --> EMITS[äº‹ä»¶å‘å°„]
        
        STYLE --> SCOPED[ä½œç”¨åŸŸæ ·å¼]
        STYLE --> MODULES[CSS Modules]
        STYLE --> PREPROCESSOR[é¢„å¤„ç†å™¨]
    end
```

#### ç»„ä»¶è®¾è®¡æ¨¡å¼å¯¹æ¯”

| è®¾è®¡æ¨¡å¼ | é€‚ç”¨åœºæ™¯ | ä¼˜åŠ¿ | åŠ£åŠ¿ | ç¤ºä¾‹ |
|---------|----------|------|------|------|
| **å±•ç¤ºç»„ä»¶** | UIæ¸²æŸ“ | å¯å¤ç”¨ã€æ˜“æµ‹è¯• | åŠŸèƒ½å•ä¸€ | Button, Card, Modal |
| **å®¹å™¨ç»„ä»¶** | ä¸šåŠ¡é€»è¾‘ | é€»è¾‘é›†ä¸­ | è€¦åˆåº¦é«˜ | UserList, ProductManager |
| **é«˜é˜¶ç»„ä»¶** | åŠŸèƒ½å¢å¼º | æ¨ªåˆ‡å…³æ³¨ç‚¹ | å¤æ‚åº¦é«˜ | withAuth, withLoading |
| **Renderlessç»„ä»¶** | é€»è¾‘å¤ç”¨ | çµæ´»æ€§é«˜ | ç†è§£æˆæœ¬ | DataProvider, FormValidator |

<Tabs>
<TabItem value="component-communication" label="ç»„ä»¶é€šä¿¡">

#### ç»„ä»¶é€šä¿¡å®Œæ•´æ–¹æ¡ˆ

```vue title="çˆ¶å­ç»„ä»¶é€šä¿¡ç¤ºä¾‹"
<!-- çˆ¶ç»„ä»¶: UserManagement.vue -->
<template>
  <div class="user-management">
    <div class="header">
      <h1>ç”¨æˆ·ç®¡ç†</h1>
      <button @click="showAddModal = true" class="btn-primary">
        æ·»åŠ ç”¨æˆ·
      </button>
    </div>
    
    <!-- æœç´¢å’Œè¿‡æ»¤ -->
    <UserFilters
      v-model:search="searchQuery"
      v-model:role="selectedRole"
      :roles="availableRoles"
      @reset="resetFilters"
    />
    
    <!-- ç”¨æˆ·åˆ—è¡¨ -->
    <UserList
      :users="filteredUsers"
      :loading="loading"
      @edit="handleEditUser"
      @delete="handleDeleteUser"
      @toggle-status="handleToggleStatus"
    />
    
    <!-- æ·»åŠ /ç¼–è¾‘ç”¨æˆ·æ¨¡æ€æ¡† -->
    <UserModal
      v-model:visible="showAddModal"
      :user="editingUser"
      :mode="modalMode"
      @save="handleSaveUser"
      @cancel="handleCancelEdit"
    />
    
    <!-- ç¡®è®¤åˆ é™¤å¯¹è¯æ¡† -->
    <ConfirmDialog
      v-model:visible="showDeleteDialog"
      title="ç¡®è®¤åˆ é™¤"
      :message="`ç¡®å®šè¦åˆ é™¤ç”¨æˆ· ${deletingUser?.name} å—ï¼Ÿ`"
      @confirm="confirmDelete"
      @cancel="showDeleteDialog = false"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import UserFilters from './components/UserFilters.vue'
import UserList from './components/UserList.vue'
import UserModal from './components/UserModal.vue'
import ConfirmDialog from './components/ConfirmDialog.vue'
import { useUserApi } from '@/composables/useUserApi'
import { useNotification } from '@/composables/useNotification'

// ç±»å‹å®šä¹‰
interface User {
  id: number
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
  status: 'active' | 'inactive'
  avatar?: string
  createdAt: string
}

type ModalMode = 'add' | 'edit'

// å“åº”å¼æ•°æ®
const searchQuery = ref('')
const selectedRole = ref<string>('')
const showAddModal = ref(false)
const showDeleteDialog = ref(false)
const editingUser = ref<User | null>(null)
const deletingUser = ref<User | null>(null)
const modalMode = ref<ModalMode>('add')

// ç»„åˆå¼å‡½æ•°
const { users, loading, fetchUsers, createUser, updateUser, deleteUser } = useUserApi()
const { showSuccess, showError } = useNotification()

// è®¡ç®—å±æ€§
const availableRoles = computed(() => [
  { value: '', label: 'å…¨éƒ¨è§’è‰²' },
  { value: 'admin', label: 'ç®¡ç†å‘˜' },
  { value: 'user', label: 'æ™®é€šç”¨æˆ·' },
  { value: 'guest', label: 'è®¿å®¢' }
])

const filteredUsers = computed(() => {
  return users.value.filter(user => {
    const matchesSearch = !searchQuery.value || 
      user.name.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
      user.email.toLowerCase().includes(searchQuery.value.toLowerCase())
    
    const matchesRole = !selectedRole.value || user.role === selectedRole.value
    
    return matchesSearch && matchesRole
  })
})

// äº‹ä»¶å¤„ç†
const handleEditUser = (user: User) => {
  editingUser.value = { ...user }
  modalMode.value = 'edit'
  showAddModal.value = true
}

const handleDeleteUser = (user: User) => {
  deletingUser.value = user
  showDeleteDialog.value = true
}

const handleToggleStatus = async (user: User) => {
  try {
    const newStatus = user.status === 'active' ? 'inactive' : 'active'
    await updateUser(user.id, { status: newStatus })
    showSuccess(`ç”¨æˆ·çŠ¶æ€å·²æ›´æ–°ä¸º${newStatus === 'active' ? 'æ¿€æ´»' : 'ç¦ç”¨'}`)
  } catch (error) {
    showError('æ›´æ–°ç”¨æˆ·çŠ¶æ€å¤±è´¥')
  }
}

const handleSaveUser = async (userData: Partial<User>) => {
  try {
    if (modalMode.value === 'add') {
      await createUser(userData)
      showSuccess('ç”¨æˆ·åˆ›å»ºæˆåŠŸ')
    } else {
      await updateUser(editingUser.value!.id, userData)
      showSuccess('ç”¨æˆ·æ›´æ–°æˆåŠŸ')
    }
    
    showAddModal.value = false
    editingUser.value = null
  } catch (error) {
    showError(modalMode.value === 'add' ? 'åˆ›å»ºç”¨æˆ·å¤±è´¥' : 'æ›´æ–°ç”¨æˆ·å¤±è´¥')
  }
}

const handleCancelEdit = () => {
  showAddModal.value = false
  editingUser.value = null
}

const confirmDelete = async () => {
  if (!deletingUser.value) return
  
  try {
    await deleteUser(deletingUser.value.id)
    showSuccess('ç”¨æˆ·åˆ é™¤æˆåŠŸ')
    showDeleteDialog.value = false
    deletingUser.value = null
  } catch (error) {
    showError('åˆ é™¤ç”¨æˆ·å¤±è´¥')
  }
}

const resetFilters = () => {
  searchQuery.value = ''
  selectedRole.value = ''
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  fetchUsers()
})
</script>

<!-- å­ç»„ä»¶: UserFilters.vue -->
<template>
  <div class="user-filters">
    <div class="filter-group">
      <label for="search">æœç´¢ç”¨æˆ·ï¼š</label>
      <input
        id="search"
        :value="search"
        @input="$emit('update:search', $event.target.value)"
        type="text"
        placeholder="è¾“å…¥å§“åæˆ–é‚®ç®±..."
        class="search-input"
      />
    </div>
    
    <div class="filter-group">
      <label for="role">è§’è‰²ç­›é€‰ï¼š</label>
      <select
        id="role"
        :value="role"
        @change="$emit('update:role', $event.target.value)"
        class="role-select"
      >
        <option
          v-for="roleOption in roles"
          :key="roleOption.value"
          :value="roleOption.value"
        >
          {{ roleOption.label }}
        </option>
      </select>
    </div>
    
    <button @click="$emit('reset')" class="btn-secondary">
      é‡ç½®ç­›é€‰
    </button>
  </div>
</template>

<script setup lang="ts">
// Propså®šä¹‰
interface Props {
  search: string
  role: string
  roles: Array<{ value: string; label: string }>
}

defineProps<Props>()

// äº‹ä»¶å®šä¹‰
interface Emits {
  'update:search': [value: string]
  'update:role': [value: string]
  'reset': []
}

defineEmits<Emits>()
</script>

<!-- å­ç»„ä»¶: UserList.vue -->
<template>
  <div class="user-list">
    <div v-if="loading" class="loading">
      <div class="spinner"></div>
      <p>åŠ è½½ä¸­...</p>
    </div>
    
    <div v-else-if="users.length === 0" class="empty-state">
      <p>æš‚æ— ç”¨æˆ·æ•°æ®</p>
    </div>
    
    <div v-else class="user-grid">
      <div
        v-for="user in users"
        :key="user.id"
        class="user-card"
        :class="{ 'user-card--inactive': user.status === 'inactive' }"
      >
        <div class="user-avatar">
          <img
            :src="user.avatar || '/default-avatar.png'"
            :alt="user.name"
            class="avatar-image"
          />
          <div class="status-indicator" :class="`status--${user.status}`"></div>
        </div>
        
        <div class="user-info">
          <h3 class="user-name">{{ user.name }}</h3>
          <p class="user-email">{{ user.email }}</p>
          <span class="user-role" :class="`role--${user.role}`">
            {{ getRoleLabel(user.role) }}
          </span>
        </div>
        
        <div class="user-actions">
          <button
            @click="$emit('edit', user)"
            class="btn-icon"
            title="ç¼–è¾‘"
          >
            âœï¸
          </button>
          <button
            @click="$emit('toggle-status', user)"
            class="btn-icon"
            :title="user.status === 'active' ? 'ç¦ç”¨' : 'å¯ç”¨'"
          >
            {{ user.status === 'active' ? 'ğŸ”’' : 'ğŸ”“' }}
          </button>
          <button
            @click="$emit('delete', user)"
            class="btn-icon btn-danger"
            title="åˆ é™¤"
          >
            ğŸ—‘ï¸
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
// Propså’ŒEmitså®šä¹‰
interface User {
  id: number
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
  status: 'active' | 'inactive'
  avatar?: string
}

interface Props {
  users: User[]
  loading: boolean
}

interface Emits {
  'edit': [user: User]
  'delete': [user: User]
  'toggle-status': [user: User]
}

defineProps<Props>()
defineEmits<Emits>()

// å·¥å…·å‡½æ•°
const getRoleLabel = (role: string) => {
  const roleLabels = {
    admin: 'ç®¡ç†å‘˜',
    user: 'æ™®é€šç”¨æˆ·',
    guest: 'è®¿å®¢'
  }
  return roleLabels[role] || role
}
</script>
```

</TabItem>
<TabItem value="provide-inject" label="ä¾èµ–æ³¨å…¥">

#### Provide/Injectæ¨¡å¼

```vue title="ä¾èµ–æ³¨å…¥å®Œæ•´ç¤ºä¾‹"
<!-- æ ¹ç»„ä»¶: App.vue -->
<template>
  <div id="app">
    <ThemeProvider>
      <UserProvider>
        <NotificationProvider>
          <router-view />
        </NotificationProvider>
      </UserProvider>
    </ThemeProvider>
  </div>
</template>

<script setup lang="ts">
import ThemeProvider from './providers/ThemeProvider.vue'
import UserProvider from './providers/UserProvider.vue'
import NotificationProvider from './providers/NotificationProvider.vue'
</script>

<!-- ä¸»é¢˜æä¾›è€…: ThemeProvider.vue -->
<template>
  <div :class="`theme-${theme}`">
    <slot />
  </div>
</template>

<script setup lang="ts">
import { ref, provide, computed } from 'vue'

// ä¸»é¢˜ç±»å‹å®šä¹‰
type Theme = 'light' | 'dark' | 'auto'

interface ThemeContext {
  theme: Ref<Theme>
  toggleTheme: () => void
  setTheme: (theme: Theme) => void
  isDark: ComputedRef<boolean>
}

// æ³¨å…¥é”®
export const ThemeKey = Symbol('theme') as InjectionKey<ThemeContext>

// å“åº”å¼çŠ¶æ€
const theme = ref<Theme>('light')

// è®¡ç®—å±æ€§
const isDark = computed(() => {
  if (theme.value === 'auto') {
    return window.matchMedia('(prefers-color-scheme: dark)').matches
  }
  return theme.value === 'dark'
})

// æ–¹æ³•
const toggleTheme = () => {
  theme.value = theme.value === 'light' ? 'dark' : 'light'
}

const setTheme = (newTheme: Theme) => {
  theme.value = newTheme
}

// æä¾›ä¸»é¢˜ä¸Šä¸‹æ–‡
provide(ThemeKey, {
  theme,
  toggleTheme,
  setTheme,
  isDark
})

// ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
if (theme.value === 'auto') {
  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
  mediaQuery.addEventListener('change', () => {
    // è§¦å‘é‡æ–°è®¡ç®—
    theme.value = 'auto'
  })
}
</script>

<!-- ç”¨æˆ·æä¾›è€…: UserProvider.vue -->
<template>
  <slot />
</template>

<script setup lang="ts">
import { ref, provide, computed } from 'vue'
import { useRouter } from 'vue-router'

// ç”¨æˆ·ç±»å‹å®šä¹‰
interface User {
  id: number
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
  avatar?: string
  permissions: string[]
}

interface UserContext {
  user: Ref<User | null>
  loading: Ref<boolean>
  login: (credentials: LoginCredentials) => Promise<void>
  logout: () => Promise<void>
  updateProfile: (updates: Partial<User>) => Promise<void>
  hasPermission: (permission: string) => boolean
  isAdmin: ComputedRef<boolean>
}

// æ³¨å…¥é”®
export const UserKey = Symbol('user') as InjectionKey<UserContext>

// å“åº”å¼çŠ¶æ€
const user = ref<User | null>(null)
const loading = ref(false)

// è·¯ç”±
const router = useRouter()

// è®¡ç®—å±æ€§
const isAdmin = computed(() => user.value?.role === 'admin')

// æ–¹æ³•
const login = async (credentials: LoginCredentials) => {
  try {
    loading.value = true
    
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    })
    
    if (!response.ok) {
      throw new Error('ç™»å½•å¤±è´¥')
    }
    
    const { user: userData, token } = await response.json()
    
    localStorage.setItem('token', token)
    user.value = userData
    
    router.push('/dashboard')
  } catch (error) {
    throw error
  } finally {
    loading.value = false
  }
}

const logout = async () => {
  try {
    await fetch('/api/auth/logout', { method: 'POST' })
  } catch (error) {
    console.error('Logout error:', error)
  } finally {
    localStorage.removeItem('token')
    user.value = null
    router.push('/login')
  }
}

const updateProfile = async (updates: Partial<User>) => {
  if (!user.value) return
  
  try {
    const response = await fetch(`/api/users/${user.value.id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    })
    
    if (!response.ok) {
      throw new Error('æ›´æ–°å¤±è´¥')
    }
    
    const updatedUser = await response.json()
    user.value = updatedUser
  } catch (error) {
    throw error
  }
}

const hasPermission = (permission: string): boolean => {
  return user.value?.permissions.includes(permission) || false
}

// æä¾›ç”¨æˆ·ä¸Šä¸‹æ–‡
provide(UserKey, {
  user,
  loading,
  login,
  logout,
  updateProfile,
  hasPermission,
  isAdmin
})

// åˆå§‹åŒ–æ—¶æ£€æŸ¥ç™»å½•çŠ¶æ€
onMounted(async () => {
  const token = localStorage.getItem('token')
  if (token) {
    try {
      const response = await fetch('/api/auth/me', {
        headers: { Authorization: `Bearer ${token}` }
      })
      
      if (response.ok) {
        user.value = await response.json()
      } else {
        localStorage.removeItem('token')
      }
    } catch (error) {
      console.error('Auth check failed:', error)
      localStorage.removeItem('token')
    }
  }
})
</script>

<!-- é€šçŸ¥æä¾›è€…: NotificationProvider.vue -->
<template>
  <div>
    <slot />
    
    <!-- é€šçŸ¥å®¹å™¨ -->
    <Teleport to="body">
      <div class="notification-container">
        <TransitionGroup name="notification" tag="div">
          <div
            v-for="notification in notifications"
            :key="notification.id"
            class="notification"
            :class="`notification--${notification.type}`"
          >
            <div class="notification-content">
              <div class="notification-icon">
                {{ getNotificationIcon(notification.type) }}
              </div>
              <div class="notification-text">
                <div class="notification-title">{{ notification.title }}</div>
                <div v-if="notification.message" class="notification-message">
                  {{ notification.message }}
                </div>
              </div>
              <button
                @click="removeNotification(notification.id)"
                class="notification-close"
              >
                Ã—
              </button>
            </div>
          </div>
        </TransitionGroup>
      </div>
    </Teleport>
  </div>
</template>

<script setup lang="ts">
import { ref, provide } from 'vue'

// é€šçŸ¥ç±»å‹å®šä¹‰
type NotificationType = 'success' | 'error' | 'warning' | 'info'

interface Notification {
  id: string
  type: NotificationType
  title: string
  message?: string
  duration?: number
}

interface NotificationContext {
  notifications: Ref<Notification[]>
  showNotification: (notification: Omit<Notification, 'id'>) => void
  showSuccess: (title: string, message?: string) => void
  showError: (title: string, message?: string) => void
  showWarning: (title: string, message?: string) => void
  showInfo: (title: string, message?: string) => void
  removeNotification: (id: string) => void
}

// æ³¨å…¥é”®
export const NotificationKey = Symbol('notification') as InjectionKey<NotificationContext>

// å“åº”å¼çŠ¶æ€
const notifications = ref<Notification[]>([])

// æ–¹æ³•
const showNotification = (notification: Omit<Notification, 'id'>) => {
  const id = Date.now().toString()
  const newNotification: Notification = {
    id,
    duration: 5000,
    ...notification
  }
  
  notifications.value.push(newNotification)
  
  // è‡ªåŠ¨ç§»é™¤
  if (newNotification.duration && newNotification.duration > 0) {
    setTimeout(() => {
      removeNotification(id)
    }, newNotification.duration)
  }
}

const showSuccess = (title: string, message?: string) => {
  showNotification({ type: 'success', title, message })
}

const showError = (title: string, message?: string) => {
  showNotification({ type: 'error', title, message })
}

const showWarning = (title: string, message?: string) => {
  showNotification({ type: 'warning', title, message })
}

const showInfo = (title: string, message?: string) => {
  showNotification({ type: 'info', title, message })
}

const removeNotification = (id: string) => {
  const index = notifications.value.findIndex(n => n.id === id)
  if (index > -1) {
    notifications.value.splice(index, 1)
  }
}

const getNotificationIcon = (type: NotificationType) => {
  const icons = {
    success: 'âœ…',
    error: 'âŒ',
    warning: 'âš ï¸',
    info: 'â„¹ï¸'
  }
  return icons[type]
}

// æä¾›é€šçŸ¥ä¸Šä¸‹æ–‡
provide(NotificationKey, {
  notifications,
  showNotification,
  showSuccess,
  showError,
  showWarning,
  showInfo,
  removeNotification
})
</script>

<!-- ä½¿ç”¨ä¾èµ–æ³¨å…¥çš„ç»„ä»¶ -->
<template>
  <div class="settings-page">
    <div class="settings-header">
      <h1>è®¾ç½®</h1>
      <button @click="toggleTheme" class="theme-toggle">
        {{ isDark ? 'ğŸŒ' : 'ğŸŒ™' }}
      </button>
    </div>
    
    <div class="settings-content">
      <div class="setting-group">
        <h3>ä¸»é¢˜è®¾ç½®</h3>
        <select v-model="theme" @change="setTheme(theme)">
          <option value="light">æµ…è‰²ä¸»é¢˜</option>
          <option value="dark">æ·±è‰²ä¸»é¢˜</option>
          <option value="auto">è·Ÿéšç³»ç»Ÿ</option>
        </select>
      </div>
      
      <div class="setting-group" v-if="isAdmin">
        <h3>ç®¡ç†å‘˜è®¾ç½®</h3>
        <button @click="showAdminPanel">ç®¡ç†é¢æ¿</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { inject } from 'vue'
import { ThemeKey } from '@/providers/ThemeProvider.vue'
import { UserKey } from '@/providers/UserProvider.vue'
import { NotificationKey } from '@/providers/NotificationProvider.vue'

// æ³¨å…¥ä¾èµ–
const themeContext = inject(ThemeKey)
const userContext = inject(UserKey)
const notificationContext = inject(NotificationKey)

if (!themeContext || !userContext || !notificationContext) {
  throw new Error('Required providers not found')
}

const { theme, toggleTheme, setTheme, isDark } = themeContext
const { isAdmin } = userContext
const { showInfo } = notificationContext

// æ–¹æ³•
const showAdminPanel = () => {
  showInfo('ç®¡ç†é¢æ¿', 'å³å°†è·³è½¬åˆ°ç®¡ç†é¢æ¿')
}
</script>
```

</TabItem>
<TabItem value="slots" label="æ’æ§½ç³»ç»Ÿ">

#### æ’æ§½ç³»ç»Ÿé«˜çº§ç”¨æ³•

```vue title="æ’æ§½ç³»ç»Ÿå®Œæ•´ç¤ºä¾‹"
<!-- åŸºç¡€æ’æ§½ç»„ä»¶: BaseCard.vue -->
<template>
  <div class="base-card" :class="cardClasses">
    <!-- å¤´éƒ¨æ’æ§½ -->
    <header v-if="$slots.header" class="card-header">
      <slot name="header" :title="title" :subtitle="subtitle" />
    </header>
    
    <!-- é»˜è®¤å†…å®¹æ’æ§½ -->
    <main class="card-content">
      <slot :loading="loading" :error="error" />
    </main>
    
    <!-- åº•éƒ¨æ’æ§½ -->
    <footer v-if="$slots.footer" class="card-footer">
      <slot name="footer" :actions="actions" />
    </footer>
    
    <!-- åŠ è½½çŠ¶æ€æ’æ§½ -->
    <div v-if="loading && $slots.loading" class="card-loading">
      <slot name="loading" />
    </div>
    
    <!-- é”™è¯¯çŠ¶æ€æ’æ§½ -->
    <div v-if="error && $slots.error" class="card-error">
      <slot name="error" :error="error" :retry="retry" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

// Propså®šä¹‰
interface Props {
  title?: string
  subtitle?: string
  variant?: 'default' | 'primary' | 'success' | 'warning' | 'danger'
  size?: 'small' | 'medium' | 'large'
  loading?: boolean
  error?: string | null
  actions?: Array<{ label: string; onClick: () => void }>
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'default',
  size: 'medium',
  loading: false,
  error: null
})

// äº‹ä»¶å®šä¹‰
interface Emits {
  retry: []
}

const emit = defineEmits<Emits>()

// è®¡ç®—å±æ€§
const cardClasses = computed(() => [
  `card--${props.variant}`,
  `card--${props.size}`,
  {
    'card--loading': props.loading,
    'card--error': props.error
  }
])

// æ–¹æ³•
const retry = () => {
  emit('retry')
}
</script>

<!-- æ•°æ®è¡¨æ ¼ç»„ä»¶: DataTable.vue -->
<template>
  <BaseCard
    :loading="loading"
    :error="error"
    @retry="$emit('retry')"
    class="data-table-card"
  >
    <!-- è¡¨æ ¼å¤´éƒ¨ -->
    <template #header="{ title, subtitle }">
      <div class="table-header">
        <div class="table-title">
          <h2>{{ title || 'æ•°æ®è¡¨æ ¼' }}</h2>
          <p v-if="subtitle">{{ subtitle }}</p>
        </div>
        
        <div class="table-actions">
          <slot name="actions" :selected="selectedRows" />
        </div>
      </div>
    </template>
    
    <!-- è¡¨æ ¼å†…å®¹ -->
    <template #default="{ loading, error }">
      <div class="table-container">
        <!-- è¡¨æ ¼å·¥å…·æ  -->
        <div class="table-toolbar">
          <div class="table-filters">
            <slot name="filters" />
          </div>
          
          <div class="table-controls">
            <button
              @click="toggleSelectAll"
              class="btn-secondary"
              :disabled="loading"
            >
              {{ isAllSelected ? 'å–æ¶ˆå…¨é€‰' : 'å…¨é€‰' }}
            </button>
            
            <slot name="controls" :refresh="refresh" />
          </div>
        </div>
        
        <!-- è¡¨æ ¼ä¸»ä½“ -->
        <div class="table-wrapper">
          <table class="data-table">
            <thead>
              <tr>
                <th v-if="selectable" class="select-column">
                  <input
                    type="checkbox"
                    :checked="isAllSelected"
                    @change="toggleSelectAll"
                  />
                </th>
                
                <th
                  v-for="column in columns"
                  :key="column.key"
                  :class="getColumnClass(column)"
                  @click="handleSort(column)"
                >
                  <div class="column-header">
                    <span>{{ column.title }}</span>
                    <span
                      v-if="column.sortable"
                      class="sort-indicator"
                      :class="getSortClass(column.key)"
                    >
                      â†•ï¸
                    </span>
                  </div>
                </th>
                
                <th v-if="$slots.actions" class="actions-column">
                  æ“ä½œ
                </th>
              </tr>
            </thead>
            
            <tbody>
              <tr
                v-for="(row, index) in paginatedData"
                :key="getRowKey(row, index)"
                :class="getRowClass(row, index)"
                @click="handleRowClick(row, index)"
              >
                <td v-if="selectable" class="select-cell">
                  <input
                    type="checkbox"
                    :checked="isRowSelected(row)"
                    @change="toggleRowSelection(row)"
                    @click.stop
                  />
                </td>
                
                <td
                  v-for="column in columns"
                  :key="column.key"
                  :class="getCellClass(column, row)"
                >
                  <!-- è‡ªå®šä¹‰åˆ—æ¸²æŸ“ -->
                  <slot
                    :name="`column-${column.key}`"
                    :row="row"
                    :column="column"
                    :value="getColumnValue(row, column.key)"
                    :index="index"
                  >
                    <!-- é»˜è®¤åˆ—æ¸²æŸ“ -->
                    <span>{{ getColumnValue(row, column.key) }}</span>
                  </slot>
                </td>
                
                <td v-if="$slots.actions" class="actions-cell">
                  <slot name="actions" :row="row" :index="index" />
                </td>
              </tr>
            </tbody>
          </table>
          
          <!-- ç©ºçŠ¶æ€ -->
          <div v-if="!loading && data.length === 0" class="empty-state">
            <slot name="empty">
              <div class="empty-content">
                <p>æš‚æ— æ•°æ®</p>
              </div>
            </slot>
          </div>
        </div>
        
        <!-- åˆ†é¡µ -->
        <div v-if="pagination" class="table-pagination">
          <slot
            name="pagination"
            :current="currentPage"
            :total="totalPages"
            :pageSize="pageSize"
            :totalItems="data.length"
            :goToPage="goToPage"
            :changePageSize="changePageSize"
          >
            <!-- é»˜è®¤åˆ†é¡µç»„ä»¶ -->
            <DefaultPagination
              :current="currentPage"
              :total="totalPages"
              :page-size="pageSize"
              @change="goToPage"
              @size-change="changePageSize"
            />
          </slot>
        </div>
      </div>
    </template>
    
    <!-- åŠ è½½çŠ¶æ€ -->
    <template #loading>
      <slot name="loading">
        <div class="table-loading">
          <div class="loading-spinner"></div>
          <p>æ•°æ®åŠ è½½ä¸­...</p>
        </div>
      </slot>
    </template>
    
    <!-- é”™è¯¯çŠ¶æ€ -->
    <template #error="{ error, retry }">
      <slot name="error" :error="error" :retry="retry">
        <div class="table-error">
          <p>{{ error }}</p>
          <button @click="retry" class="btn-primary">é‡è¯•</button>
        </div>
      </slot>
    </template>
  </BaseCard>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import BaseCard from './BaseCard.vue'
import DefaultPagination from './DefaultPagination.vue'

// ç±»å‹å®šä¹‰
interface Column {
  key: string
  title: string
  sortable?: boolean
  width?: string
  align?: 'left' | 'center' | 'right'
  fixed?: 'left' | 'right'
}

interface Props {
  data: any[]
  columns: Column[]
  loading?: boolean
  error?: string | null
  selectable?: boolean
  pagination?: boolean
  pageSize?: number
  rowKey?: string | ((row: any) => string)
}

interface Emits {
  'row-click': [row: any, index: number]
  'selection-change': [selectedRows: any[]]
  'sort-change': [column: string, direction: 'asc' | 'desc' | null]
  'retry': []
}

const props = withDefaults(defineProps<Props>(), {
  loading: false,
  error: null,
  selectable: false,
  pagination: true,
  pageSize: 10,
  rowKey: 'id'
})

const emit = defineEmits<Emits>()

// å“åº”å¼æ•°æ®
const selectedRows = ref<any[]>([])
const currentPage = ref(1)
const sortColumn = ref<string | null>(null)
const sortDirection = ref<'asc' | 'desc' | null>(null)

// è®¡ç®—å±æ€§
const sortedData = computed(() => {
  if (!sortColumn.value || !sortDirection.value) {
    return props.data
  }
  
  return [...props.data].sort((a, b) => {
    const aValue = getColumnValue(a, sortColumn.value!)
    const bValue = getColumnValue(b, sortColumn.value!)
    
    if (aValue < bValue) return sortDirection.value === 'asc' ? -1 : 1
    if (aValue > bValue) return sortDirection.value === 'asc' ? 1 : -1
    return 0
  })
})

const paginatedData = computed(() => {
  if (!props.pagination) return sortedData.value
  
  const start = (currentPage.value - 1) * props.pageSize
  const end = start + props.pageSize
  return sortedData.value.slice(start, end)
})

const totalPages = computed(() => {
  return Math.ceil(props.data.length / props.pageSize)
})

const isAllSelected = computed(() => {
  return props.data.length > 0 && selectedRows.value.length === props.data.length
})

// æ–¹æ³•
const getRowKey = (row: any, index: number): string => {
  if (typeof props.rowKey === 'function') {
    return props.rowKey(row)
  }
  return row[props.rowKey] || index.toString()
}

const getColumnValue = (row: any, key: string) => {
  return key.split('.').reduce((obj, k) => obj?.[k], row)
}

const getColumnClass = (column: Column) => [
  `column-${column.key}`,
  `align-${column.align || 'left'}`,
  {
    'sortable': column.sortable,
    'fixed-left': column.fixed === 'left',
    'fixed-right': column.fixed === 'right'
  }
]

const getCellClass = (column: Column, row: any) => [
  `cell-${column.key}`,
  `align-${column.align || 'left'}`
]

const getRowClass = (row: any, index: number) => [
  'table-row',
  {
    'row-selected': isRowSelected(row),
    'row-even': index % 2 === 0,
    'row-odd': index % 2 === 1
  }
]

const getSortClass = (columnKey: string) => {
  if (sortColumn.value !== columnKey) return ''
  return `sort-${sortDirection.value}`
}

const isRowSelected = (row: any): boolean => {
  const rowKey = getRowKey(row, 0)
  return selectedRows.value.some(selected => getRowKey(selected, 0) === rowKey)
}

const toggleRowSelection = (row: any) => {
  const rowKey = getRowKey(row, 0)
  const index = selectedRows.value.findIndex(selected => getRowKey(selected, 0) === rowKey)
  
  if (index > -1) {
    selectedRows.value.splice(index, 1)
  } else {
    selectedRows.value.push(row)
  }
}

const toggleSelectAll = () => {
  if (isAllSelected.value) {
    selectedRows.value = []
  } else {
    selectedRows.value = [...props.data]
  }
}

const handleSort = (column: Column) => {
  if (!column.sortable) return
  
  if (sortColumn.value === column.key) {
    // åˆ‡æ¢æ’åºæ–¹å‘
    if (sortDirection.value === 'asc') {
      sortDirection.value = 'desc'
    } else if (sortDirection.value === 'desc') {
      sortDirection.value = null
      sortColumn.value = null
    } else {
      sortDirection.value = 'asc'
    }
  } else {
    sortColumn.value = column.key
    sortDirection.value = 'asc'
  }
  
  emit('sort-change', sortColumn.value, sortDirection.value)
}

const handleRowClick = (row: any, index: number) => {
  emit('row-click', row, index)
}

const goToPage = (page: number) => {
  currentPage.value = page
}

const changePageSize = (size: number) => {
  props.pageSize = size
  currentPage.value = 1
}

const refresh = () => {
  emit('retry')
}

// ç›‘å¬é€‰æ‹©å˜åŒ–
watch(selectedRows, (newSelection) => {
  emit('selection-change', newSelection)
}, { deep: true })
</script>

<!-- ä½¿ç”¨ç¤ºä¾‹ -->
<template>
  <div class="user-management">
    <DataTable
      :data="users"
      :columns="columns"
      :loading="loading"
      :error="error"
      selectable
      @row-click="handleRowClick"
      @selection-change="handleSelectionChange"
      @retry="fetchUsers"
    >
      <!-- æ“ä½œæŒ‰é’® -->
      <template #actions="{ selected }">
        <button
          @click="handleBatchDelete"
          :disabled="selected.length === 0"
          class="btn-danger"
        >
          æ‰¹é‡åˆ é™¤ ({{ selected.length }})
        </button>
        <button @click="handleAddUser" class="btn-primary">
          æ·»åŠ ç”¨æˆ·
        </button>
      </template>
      
      <!-- è¿‡æ»¤å™¨ -->
      <template #filters>
        <input
          v-model="searchQuery"
          placeholder="æœç´¢ç”¨æˆ·..."
          class="search-input"
        />
        <select v-model="roleFilter" class="role-filter">
          <option value="">å…¨éƒ¨è§’è‰²</option>
          <option value="admin">ç®¡ç†å‘˜</option>
          <option value="user">ç”¨æˆ·</option>
        </select>
      </template>
      
      <!-- è‡ªå®šä¹‰åˆ—æ¸²æŸ“ -->
      <template #column-avatar="{ row }">
        <img
          :src="row.avatar || '/default-avatar.png'"
          :alt="row.name"
          class="user-avatar"
        />
      </template>
      
      <template #column-status="{ row }">
        <span
          class="status-badge"
          :class="`status--${row.status}`"
        >
          {{ row.status === 'active' ? 'æ¿€æ´»' : 'ç¦ç”¨' }}
        </span>
      </template>
      
      <!-- è¡Œæ“ä½œ -->
      <template #actions="{ row }">
        <button @click="editUser(row)" class="btn-sm btn-secondary">
          ç¼–è¾‘
        </button>
        <button @click="deleteUser(row)" class="btn-sm btn-danger">
          åˆ é™¤
        </button>
      </template>
      
      <!-- ç©ºçŠ¶æ€ -->
      <template #empty>
        <div class="empty-users">
          <h3>æš‚æ— ç”¨æˆ·</h3>
          <p>ç‚¹å‡»"æ·»åŠ ç”¨æˆ·"æŒ‰é’®åˆ›å»ºç¬¬ä¸€ä¸ªç”¨æˆ·</p>
          <button @click="handleAddUser" class="btn-primary">
            æ·»åŠ ç”¨æˆ·
          </button>
        </div>
      </template>
    </DataTable>
  </div>
</template>
```

</TabItem>
</Tabs>

## 3. Vueç”Ÿæ€ç³»ç»Ÿä¸å·¥å…·é“¾

### 3.1 Vue Router 4è·¯ç”±ç®¡ç†

Vue Router 4ä¸ºVue 3åº”ç”¨æä¾›äº†å¼ºå¤§çš„è·¯ç”±åŠŸèƒ½ï¼Œæ”¯æŒåµŒå¥—è·¯ç”±ã€è·¯ç”±å®ˆå«ã€åŠ¨æ€è·¯ç”±ç­‰ç‰¹æ€§ã€‚

```mermaid
graph TB
    subgraph "Vue Routeræ¶æ„"
        ROUTER[Vue Router]
        ROUTER --> ROUTES[è·¯ç”±é…ç½®]
        ROUTER --> GUARDS[è·¯ç”±å®ˆå«]
        ROUTER --> NAVIGATION[å¯¼èˆªæ§åˆ¶]
        
        ROUTES --> NESTED[åµŒå¥—è·¯ç”±]
        ROUTES --> DYNAMIC[åŠ¨æ€è·¯ç”±]
        ROUTES --> LAZY[æ‡’åŠ è½½]
        
        GUARDS --> GLOBAL[å…¨å±€å®ˆå«]
        GUARDS --> ROUTE[è·¯ç”±å®ˆå«]
        GUARDS --> COMPONENT[ç»„ä»¶å®ˆå«]
        
        NAVIGATION --> PROGRAMMATIC[ç¼–ç¨‹å¼å¯¼èˆª]
        NAVIGATION --> DECLARATIVE[å£°æ˜å¼å¯¼èˆª]
    end
```

#### è·¯ç”±é…ç½®æœ€ä½³å®è·µ

| è·¯ç”±ç‰¹æ€§ | ä½¿ç”¨åœºæ™¯ | é…ç½®æ–¹å¼ | æ€§èƒ½å½±å“ |
|---------|----------|----------|----------|
| **åµŒå¥—è·¯ç”±** | å¤šå±‚çº§é¡µé¢ | childrené…ç½® | ä¸­ç­‰ |
| **åŠ¨æ€è·¯ç”±** | å‚æ•°åŒ–é¡µé¢ | :idè¯­æ³• | ä½ |
| **æ‡’åŠ è½½** | ä»£ç åˆ†å‰² | import()å‡½æ•° | ä¼˜åŒ–é¦–å± |
| **è·¯ç”±å®ˆå«** | æƒé™æ§åˆ¶ | beforeEnterç­‰ | ä½ |
| **å‘½åè·¯ç”±** | ç¼–ç¨‹å¯¼èˆª | nameå±æ€§ | æ—  |

<Tabs>
<TabItem value="router-config" label="è·¯ç”±é…ç½®">

#### å®Œæ•´è·¯ç”±é…ç½®ç¤ºä¾‹

```typescript title="Vue Routerå®Œæ•´é…ç½®"
// router/index.ts
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'
import { useUserStore } from '@/stores/user'
import { useNotificationStore } from '@/stores/notification'

// è·¯ç”±ç±»å‹å®šä¹‰
declare module 'vue-router' {
  interface RouteMeta {
    title?: string
    requiresAuth?: boolean
    roles?: string[]
    permissions?: string[]
    layout?: string
    keepAlive?: boolean
    showInMenu?: boolean
    icon?: string
  }
}

// è·¯ç”±é…ç½®
const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/Home.vue'),
    meta: {
      title: 'é¦–é¡µ',
      showInMenu: true,
      icon: 'ğŸ '
    }
  },
  
  // è®¤è¯ç›¸å…³è·¯ç”±
  {
    path: '/auth',
    component: () => import('@/layouts/AuthLayout.vue'),
    children: [
      {
        path: 'login',
        name: 'Login',
        component: () => import('@/views/auth/Login.vue'),
        meta: {
          title: 'ç™»å½•',
          layout: 'auth'
        }
      },
      {
        path: 'register',
        name: 'Register',
        component: () => import('@/views/auth/Register.vue'),
        meta: {
          title: 'æ³¨å†Œ',
          layout: 'auth'
        }
      },
      {
        path: 'forgot-password',
        name: 'ForgotPassword',
        component: () => import('@/views/auth/ForgotPassword.vue'),
        meta: {
          title: 'å¿˜è®°å¯†ç ',
          layout: 'auth'
        }
      }
    ]
  },
  
  // ç”¨æˆ·ç›¸å…³è·¯ç”±
  {
    path: '/user',
    component: () => import('@/layouts/DefaultLayout.vue'),
    meta: {
      requiresAuth: true
    },
    children: [
      {
        path: 'profile',
        name: 'UserProfile',
        component: () => import('@/views/user/Profile.vue'),
        meta: {
          title: 'ä¸ªäººèµ„æ–™',
          requiresAuth: true,
          showInMenu: true,
          icon: 'ğŸ‘¤'
        }
      },
      {
        path: 'settings',
        name: 'UserSettings',
        component: () => import('@/views/user/Settings.vue'),
        meta: {
          title: 'ç”¨æˆ·è®¾ç½®',
          requiresAuth: true,
          showInMenu: true,
          icon: 'âš™ï¸'
        }
      },
      {
        path: 'notifications',
        name: 'UserNotifications',
        component: () => import('@/views/user/Notifications.vue'),
        meta: {
          title: 'æ¶ˆæ¯é€šçŸ¥',
          requiresAuth: true,
          showInMenu: true,
          icon: 'ğŸ””'
        }
      }
    ]
  },
  
  // ç®¡ç†å‘˜è·¯ç”±
  {
    path: '/admin',
    component: () => import('@/layouts/AdminLayout.vue'),
    meta: {
      requiresAuth: true,
      roles: ['admin']
    },
    children: [
      {
        path: '',
        name: 'AdminDashboard',
        component: () => import('@/views/admin/Dashboard.vue'),
        meta: {
          title: 'ç®¡ç†é¢æ¿',
          requiresAuth: true,
          roles: ['admin'],
          showInMenu: true,
          icon: 'ğŸ“Š'
        }
      },
      {
        path: 'users',
        name: 'AdminUsers',
        component: () => import('@/views/admin/Users.vue'),
        meta: {
          title: 'ç”¨æˆ·ç®¡ç†',
          requiresAuth: true,
          roles: ['admin'],
          permissions: ['users.read'],
          showInMenu: true,
          icon: 'ğŸ‘¥'
        }
      },
      {
        path: 'users/:id',
        name: 'AdminUserDetail',
        component: () => import('@/views/admin/UserDetail.vue'),
        meta: {
          title: 'ç”¨æˆ·è¯¦æƒ…',
          requiresAuth: true,
          roles: ['admin'],
          permissions: ['users.read']
        },
        props: true
      },
      {
        path: 'settings',
        name: 'AdminSettings',
        component: () => import('@/views/admin/Settings.vue'),
        meta: {
          title: 'ç³»ç»Ÿè®¾ç½®',
          requiresAuth: true,
          roles: ['admin'],
          permissions: ['settings.manage'],
          showInMenu: true,
          icon: 'ğŸ”§'
        }
      }
    ]
  },
  
  // åŠ¨æ€è·¯ç”±ç¤ºä¾‹
  {
    path: '/posts/:id(\\d+)',
    name: 'PostDetail',
    component: () => import('@/views/posts/PostDetail.vue'),
    meta: {
      title: 'æ–‡ç« è¯¦æƒ…'
    },
    props: route => ({
      id: Number(route.params.id),
      tab: route.query.tab
    })
  },
  
  // å¯é€‰å‚æ•°è·¯ç”±
  {
    path: '/search/:keyword?',
    name: 'Search',
    component: () => import('@/views/Search.vue'),
    meta: {
      title: 'æœç´¢'
    }
  },
  
  // é€šé…ç¬¦è·¯ç”±
  {
    path: '/docs/:path(.*)*',
    name: 'Documentation',
    component: () => import('@/views/Documentation.vue'),
    meta: {
      title: 'æ–‡æ¡£'
    }
  },
  
  // é‡å®šå‘
  {
    path: '/dashboard',
    redirect: { name: 'Home' }
  },
  
  // 404é¡µé¢
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/errors/NotFound.vue'),
    meta: {
      title: 'é¡µé¢æœªæ‰¾åˆ°'
    }
  }
]

// åˆ›å»ºè·¯ç”±å®ä¾‹
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
  scrollBehavior(to, from, savedPosition) {
    // æ»šåŠ¨è¡Œä¸º
    if (savedPosition) {
      return savedPosition
    } else if (to.hash) {
      return { el: to.hash, behavior: 'smooth' }
    } else {
      return { top: 0 }
    }
  }
})

// å…¨å±€å‰ç½®å®ˆå«
router.beforeEach(async (to, from, next) => {
  const userStore = useUserStore()
  const notificationStore = useNotificationStore()
  
  // è®¾ç½®é¡µé¢æ ‡é¢˜
  if (to.meta.title) {
    document.title = `${to.meta.title} - My App`
  }
  
  // æ£€æŸ¥è®¤è¯è¦æ±‚
  if (to.meta.requiresAuth) {
    if (!userStore.isAuthenticated) {
      notificationStore.showError('è¯·å…ˆç™»å½•')
      next({
        name: 'Login',
        query: { redirect: to.fullPath }
      })
      return
    }
    
    // æ£€æŸ¥è§’è‰²æƒé™
    if (to.meta.roles && !userStore.hasAnyRole(to.meta.roles)) {
      notificationStore.showError('æƒé™ä¸è¶³')
      next({ name: 'Home' })
      return
    }
    
    // æ£€æŸ¥å…·ä½“æƒé™
    if (to.meta.permissions && !userStore.hasAnyPermission(to.meta.permissions)) {
      notificationStore.showError('æƒé™ä¸è¶³')
      next({ name: 'Home' })
      return
    }
  }
  
  // å·²ç™»å½•ç”¨æˆ·è®¿é—®è®¤è¯é¡µé¢æ—¶é‡å®šå‘
  if (to.path.startsWith('/auth') && userStore.isAuthenticated) {
    next({ name: 'Home' })
    return
  }
  
  next()
})

// å…¨å±€åç½®é’©å­
router.afterEach((to, from) => {
  // é¡µé¢è®¿é—®ç»Ÿè®¡
  if (typeof gtag !== 'undefined') {
    gtag('config', 'GA_MEASUREMENT_ID', {
      page_title: to.meta.title,
      page_location: window.location.href
    })
  }
  
  // æ¸…é™¤åŠ è½½çŠ¶æ€
  const loadingStore = useLoadingStore()
  loadingStore.setLoading(false)
})

// è·¯ç”±é”™è¯¯å¤„ç†
router.onError((error) => {
  console.error('Router error:', error)
  const notificationStore = useNotificationStore()
  notificationStore.showError('é¡µé¢åŠ è½½å¤±è´¥')
})

export default router

// è·¯ç”±å·¥å…·å‡½æ•°
export const routeUtils = {
  // æ£€æŸ¥å½“å‰è·¯ç”±æ˜¯å¦åŒ¹é…
  isCurrentRoute(routeName: string): boolean {
    return router.currentRoute.value.name === routeName
  },
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºå­è·¯ç”±
  isChildRoute(parentName: string): boolean {
    const current = router.currentRoute.value
    return current.matched.some(route => route.name === parentName)
  },
  
  // è·å–é¢åŒ…å±‘å¯¼èˆª
  getBreadcrumbs() {
    const route = router.currentRoute.value
    return route.matched
      .filter(record => record.meta?.title)
      .map(record => ({
        title: record.meta.title,
        name: record.name,
        path: record.path
      }))
  },
  
  // ç”Ÿæˆèœå•é¡¹
  generateMenuItems() {
    const userStore = useUserStore()
    
    const filterRoutes = (routes: RouteRecordRaw[]): any[] => {
      return routes
        .filter(route => {
          // æ£€æŸ¥æ˜¯å¦æ˜¾ç¤ºåœ¨èœå•ä¸­
          if (!route.meta?.showInMenu) return false
          
          // æ£€æŸ¥æƒé™
          if (route.meta.requiresAuth && !userStore.isAuthenticated) return false
          if (route.meta.roles && !userStore.hasAnyRole(route.meta.roles)) return false
          if (route.meta.permissions && !userStore.hasAnyPermission(route.meta.permissions)) return false
          
          return true
        })
        .map(route => ({
          name: route.name,
          title: route.meta?.title,
          icon: route.meta?.icon,
          path: route.path,
          children: route.children ? filterRoutes(route.children) : []
        }))
    }
    
    return filterRoutes(routes)
  }
}
```

</TabItem>
<TabItem value="navigation" label="å¯¼èˆªç»„ä»¶">

#### å¯¼èˆªç»„ä»¶å®ç°

```vue title="å¯¼èˆªç»„ä»¶å®Œæ•´å®ç°"
<!-- ä¸»å¯¼èˆªç»„ä»¶: MainNavigation.vue -->
<template>
  <nav class="main-navigation">
    <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
    <div class="nav-header">
      <router-link to="/" class="nav-logo">
        <img src="/logo.svg" alt="Logo" />
        <span>My App</span>
      </router-link>
      
      <!-- é¢åŒ…å±‘å¯¼èˆª -->
      <div class="breadcrumb">
        <router-link
          v-for="(crumb, index) in breadcrumbs"
          :key="crumb.name"
          :to="{ name: crumb.name }"
          class="breadcrumb-item"
          :class="{ active: index === breadcrumbs.length - 1 }"
        >
          {{ crumb.title }}
        </router-link>
      </div>
      
      <!-- ç”¨æˆ·èœå• -->
      <div class="nav-user">
        <UserDropdown />
      </div>
    </div>
    
    <!-- ä¾§è¾¹å¯¼èˆªèœå• -->
    <div class="nav-sidebar">
      <div class="nav-menu">
        <NavMenuItem
          v-for="item in menuItems"
          :key="item.name"
          :item="item"
          :level="0"
        />
      </div>
    </div>
  </nav>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { routeUtils } from '@/router'
import NavMenuItem from './NavMenuItem.vue'
import UserDropdown from './UserDropdown.vue'

// å½“å‰è·¯ç”±
const route = useRoute()

// è®¡ç®—å±æ€§
const breadcrumbs = computed(() => routeUtils.getBreadcrumbs())
const menuItems = computed(() => routeUtils.generateMenuItems())
</script>

<!-- å¯¼èˆªèœå•é¡¹: NavMenuItem.vue -->
<template>
  <div class="nav-menu-item" :class="itemClasses">
    <!-- æœ‰å­èœå•çš„é¡¹ -->
    <div
      v-if="item.children && item.children.length > 0"
      class="nav-item-header"
      @click="toggleExpanded"
    >
      <div class="nav-item-content">
        <span class="nav-item-icon">{{ item.icon }}</span>
        <span class="nav-item-title">{{ item.title }}</span>
      </div>
      <span class="nav-item-arrow" :class="{ expanded: isExpanded }">
        â–¼
      </span>
    </div>
    
    <!-- æ— å­èœå•çš„é¡¹ -->
    <router-link
      v-else
      :to="{ name: item.name }"
      class="nav-item-link"
      :class="{ active: isActive }"
    >
      <span class="nav-item-icon">{{ item.icon }}</span>
      <span class="nav-item-title">{{ item.title }}</span>
    </router-link>
    
    <!-- å­èœå• -->
    <Transition name="submenu">
      <div v-if="isExpanded && item.children" class="nav-submenu">
        <NavMenuItem
          v-for="child in item.children"
          :key="child.name"
          :item="child"
          :level="level + 1"
        />
      </div>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useRoute } from 'vue-router'
import { routeUtils } from '@/router'

// Props
interface MenuItem {
  name: string
  title: string
  icon?: string
  path: string
  children?: MenuItem[]
}

interface Props {
  item: MenuItem
  level: number
}

const props = defineProps<Props>()

// å“åº”å¼æ•°æ®
const isExpanded = ref(false)
const route = useRoute()

// è®¡ç®—å±æ€§
const isActive = computed(() => {
  return routeUtils.isCurrentRoute(props.item.name) ||
         routeUtils.isChildRoute(props.item.name)
})

const itemClasses = computed(() => [
  `nav-item-level-${props.level}`,
  {
    'nav-item-active': isActive.value,
    'nav-item-expanded': isExpanded.value,
    'nav-item-has-children': props.item.children && props.item.children.length > 0
  }
])

// æ–¹æ³•
const toggleExpanded = () => {
  isExpanded.value = !isExpanded.value
}

// ç›‘å¬è·¯ç”±å˜åŒ–ï¼Œè‡ªåŠ¨å±•å¼€æ¿€æ´»çš„èœå•
watch(route, () => {
  if (isActive.value && props.item.children) {
    isExpanded.value = true
  }
}, { immediate: true })
</script>

<!-- ç”¨æˆ·ä¸‹æ‹‰èœå•: UserDropdown.vue -->
<template>
  <div class="user-dropdown" ref="dropdownRef">
    <button
      @click="toggleDropdown"
      class="user-trigger"
      :class="{ active: isOpen }"
    >
      <img
        :src="user?.avatar || '/default-avatar.png'"
        :alt="user?.name"
        class="user-avatar"
      />
      <span class="user-name">{{ user?.name }}</span>
      <span class="dropdown-arrow">â–¼</span>
    </button>
    
    <Transition name="dropdown">
      <div v-if="isOpen" class="dropdown-menu">
        <div class="dropdown-header">
          <div class="user-info">
            <img
              :src="user?.avatar || '/default-avatar.png'"
              :alt="user?.name"
              class="user-avatar-large"
            />
            <div class="user-details">
              <div class="user-name">{{ user?.name }}</div>
              <div class="user-email">{{ user?.email }}</div>
            </div>
          </div>
        </div>
        
        <div class="dropdown-body">
          <router-link
            to="/user/profile"
            class="dropdown-item"
            @click="closeDropdown"
          >
            <span class="item-icon">ğŸ‘¤</span>
            <span class="item-text">ä¸ªäººèµ„æ–™</span>
          </router-link>
          
          <router-link
            to="/user/settings"
            class="dropdown-item"
            @click="closeDropdown"
          >
            <span class="item-icon">âš™ï¸</span>
            <span class="item-text">è®¾ç½®</span>
          </router-link>
          
          <router-link
            to="/user/notifications"
            class="dropdown-item"
            @click="closeDropdown"
          >
            <span class="item-icon">ğŸ””</span>
            <span class="item-text">é€šçŸ¥</span>
            <span v-if="unreadCount > 0" class="notification-badge">
              {{ unreadCount }}
            </span>
          </router-link>
          
          <div class="dropdown-divider"></div>
          
          <button
            @click="handleLogout"
            class="dropdown-item dropdown-item-danger"
          >
            <span class="item-icon">ğŸšª</span>
            <span class="item-text">é€€å‡ºç™»å½•</span>
          </button>
        </div>
      </div>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useRouter } from 'vue-router'
import { useUserStore } from '@/stores/user'
import { useNotificationStore } from '@/stores/notification'

// å“åº”å¼æ•°æ®
const isOpen = ref(false)
const dropdownRef = ref<HTMLElement>()

// Store
const userStore = useUserStore()
const notificationStore = useNotificationStore()
const router = useRouter()

// è®¡ç®—å±æ€§
const user = computed(() => userStore.currentUser)
const unreadCount = computed(() => notificationStore.unreadCount)

// æ–¹æ³•
const toggleDropdown = () => {
  isOpen.value = !isOpen.value
}

const closeDropdown = () => {
  isOpen.value = false
}

const handleLogout = async () => {
  try {
    await userStore.logout()
    router.push('/auth/login')
    notificationStore.showSuccess('å·²æˆåŠŸé€€å‡ºç™»å½•')
  } catch (error) {
    notificationStore.showError('é€€å‡ºç™»å½•å¤±è´¥')
  } finally {
    closeDropdown()
  }
}

// ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
const handleClickOutside = (event: MouseEvent) => {
  if (dropdownRef.value && !dropdownRef.value.contains(event.target as Node)) {
    closeDropdown()
  }
}

onMounted(() => {
  document.addEventListener('click', handleClickOutside)
})

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside)
})
</script>

<style scoped>
/* å¯¼èˆªæ ·å¼ */
.main-navigation {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: #fff;
  border-right: 1px solid #e0e0e0;
}

.nav-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid #e0e0e0;
}

.nav-logo {
  display: flex;
  align-items: center;
  gap: 8px;
  text-decoration: none;
  color: #333;
  font-weight: 600;
}

.nav-logo img {
  width: 32px;
  height: 32px;
}

.breadcrumb {
  display: flex;
  align-items: center;
  gap: 8px;
}

.breadcrumb-item {
  color: #666;
  text-decoration: none;
  font-size: 14px;
}

.breadcrumb-item:not(:last-child)::after {
  content: '/';
  margin-left: 8px;
  color: #ccc;
}

.breadcrumb-item.active {
  color: #333;
  font-weight: 500;
}

.nav-sidebar {
  flex: 1;
  overflow-y: auto;
}

.nav-menu {
  padding: 16px 0;
}

.nav-menu-item {
  margin-bottom: 4px;
}

.nav-item-header,
.nav-item-link {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  color: #666;
  text-decoration: none;
  transition: all 0.2s;
  cursor: pointer;
}

.nav-item-link:hover,
.nav-item-header:hover {
  background: #f5f5f5;
  color: #333;
}

.nav-item-link.active {
  background: #e3f2fd;
  color: #1976d2;
  border-right: 3px solid #1976d2;
}

.nav-item-content {
  display: flex;
  align-items: center;
  gap: 12px;
}

.nav-item-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
}

.nav-item-title {
  font-size: 14px;
}

.nav-item-arrow {
  font-size: 12px;
  transition: transform 0.2s;
}

.nav-item-arrow.expanded {
  transform: rotate(180deg);
}

.nav-submenu {
  background: #f9f9f9;
}

.nav-item-level-1 .nav-item-link,
.nav-item-level-1 .nav-item-header {
  padding-left: 52px;
}

/* ä¸‹æ‹‰èœå•æ ·å¼ */
.user-dropdown {
  position: relative;
}

.user-trigger {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background: none;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.user-trigger:hover,
.user-trigger.active {
  background: #f5f5f5;
}

.user-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
}

.user-name {
  font-size: 14px;
  color: #333;
}

.dropdown-arrow {
  font-size: 12px;
  color: #666;
  transition: transform 0.2s;
}

.user-trigger.active .dropdown-arrow {
  transform: rotate(180deg);
}

.dropdown-menu {
  position: absolute;
  top: 100%;
  right: 0;
  width: 280px;
  background: #fff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 1000;
}

.dropdown-header {
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
}

.user-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.user-avatar-large {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  object-fit: cover;
}

.user-details .user-name {
  font-weight: 500;
  color: #333;
  margin-bottom: 4px;
}

.user-details .user-email {
  font-size: 12px;
  color: #666;
}

.dropdown-body {
  padding: 8px 0;
}

.dropdown-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  color: #333;
  text-decoration: none;
  transition: background-color 0.2s;
  border: none;
  background: none;
  width: 100%;
  cursor: pointer;
}

.dropdown-item:hover {
  background: #f5f5f5;
}

.dropdown-item-danger {
  color: #d32f2f;
}

.dropdown-item-danger:hover {
  background: #ffebee;
}

.item-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
}

.item-text {
  flex: 1;
  font-size: 14px;
}

.notification-badge {
  background: #f44336;
  color: white;
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 10px;
  min-width: 18px;
  text-align: center;
}

.dropdown-divider {
  height: 1px;
  background: #e0e0e0;
  margin: 8px 0;
}

/* åŠ¨ç”» */
.submenu-enter-active,
.submenu-leave-active {
  transition: all 0.3s ease;
  overflow: hidden;
}

.submenu-enter-from,
.submenu-leave-to {
  max-height: 0;
  opacity: 0;
}

.submenu-enter-to,
.submenu-leave-from {
  max-height: 200px;
  opacity: 1;
}

.dropdown-enter-active,
.dropdown-leave-active {
  transition: all 0.2s ease;
}

.dropdown-enter-from,
.dropdown-leave-to {
  opacity: 0;
  transform: translateY(-8px);
}
</style>
```

</TabItem>
<TabItem value="pinia" label="PiniaçŠ¶æ€ç®¡ç†">

#### PiniaçŠ¶æ€ç®¡ç†å®è·µ

```typescript title="PiniaçŠ¶æ€ç®¡ç†å®Œæ•´å®ç°"
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useNotificationStore } from './notification'

// ç”¨æˆ·ç±»å‹å®šä¹‰
interface User {
  id: number
  name: string
  email: string
  avatar?: string
  role: 'admin' | 'user' | 'guest'
  permissions: string[]
  preferences: {
    theme: 'light' | 'dark' | 'auto'
    language: string
    notifications: boolean
  }
  createdAt: string
  lastLoginAt: string
}

interface LoginCredentials {
  email: string
  password: string
  remember?: boolean
}

interface RegisterData {
  name: string
  email: string
  password: string
  confirmPassword: string
}

// ç”¨æˆ·Store
export const useUserStore = defineStore('user', () => {
  // çŠ¶æ€
  const user = ref<User | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)
  const token = ref<string | null>(localStorage.getItem('token'))
  
  // è®¡ç®—å±æ€§
  const isAuthenticated = computed(() => !!user.value && !!token.value)
  const isAdmin = computed(() => user.value?.role === 'admin')
  const userName = computed(() => user.value?.name || '')
  const userAvatar = computed(() => user.value?.avatar || '/default-avatar.png')
  
  // æƒé™ç›¸å…³è®¡ç®—å±æ€§
  const userPermissions = computed(() => user.value?.permissions || [])
  const userRole = computed(() => user.value?.role || 'guest')
  
  // Actions
  const login = async (credentials: LoginCredentials) => {
    try {
      loading.value = true
      error.value = null
      
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      })
      
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || 'ç™»å½•å¤±è´¥')
      }
      
      const { user: userData, token: authToken } = await response.json()
      
      // ä¿å­˜ç”¨æˆ·ä¿¡æ¯å’Œtoken
      user.value = userData
      token.value = authToken
      
      // æ ¹æ®rememberé€‰é¡¹å†³å®šå­˜å‚¨æ–¹å¼
      if (credentials.remember) {
        localStorage.setItem('token', authToken)
        localStorage.setItem('user', JSON.stringify(userData))
      } else {
        sessionStorage.setItem('token', authToken)
        sessionStorage.setItem('user', JSON.stringify(userData))
      }
      
      // è®¾ç½®axiosé»˜è®¤header
      setAuthHeader(authToken)
      
      return userData
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'ç™»å½•å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  const register = async (data: RegisterData) => {
    try {
      loading.value = true
      error.value = null
      
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
      })
      
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || 'æ³¨å†Œå¤±è´¥')
      }
      
      const { user: userData, token: authToken } = await response.json()
      
      user.value = userData
      token.value = authToken
      
      localStorage.setItem('token', authToken)
      localStorage.setItem('user', JSON.stringify(userData))
      
      setAuthHeader(authToken)
      
      return userData
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'æ³¨å†Œå¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  const logout = async () => {
    try {
      // è°ƒç”¨åç«¯ç™»å‡ºæ¥å£
      if (token.value) {
        await fetch('/api/auth/logout', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token.value}`
          }
        })
      }
    } catch (err) {
      console.error('Logout API error:', err)
    } finally {
      // æ¸…é™¤æœ¬åœ°çŠ¶æ€
      user.value = null
      token.value = null
      error.value = null
      
      // æ¸…é™¤å­˜å‚¨
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      sessionStorage.removeItem('token')
      sessionStorage.removeItem('user')
      
      // æ¸…é™¤axios header
      setAuthHeader(null)
    }
  }
  
  const updateProfile = async (updates: Partial<User>) => {
    if (!user.value) throw new Error('ç”¨æˆ·æœªç™»å½•')
    
    try {
      loading.value = true
      
      const response = await fetch(`/api/users/${user.value.id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token.value}`
        },
        body: JSON.stringify(updates)
      })
      
      if (!response.ok) {
        throw new Error('æ›´æ–°å¤±è´¥')
      }
      
      const updatedUser = await response.json()
      user.value = updatedUser
      
      // æ›´æ–°æœ¬åœ°å­˜å‚¨
      const storage = localStorage.getItem('token') ? localStorage : sessionStorage
      storage.setItem('user', JSON.stringify(updatedUser))
      
      return updatedUser
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'æ›´æ–°å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  const changePassword = async (oldPassword: string, newPassword: string) => {
    try {
      loading.value = true
      
      const response = await fetch('/api/auth/change-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token.value}`
        },
        body: JSON.stringify({ oldPassword, newPassword })
      })
      
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.message || 'å¯†ç ä¿®æ”¹å¤±è´¥')
      }
      
      return true
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'å¯†ç ä¿®æ”¹å¤±è´¥'
      throw err
    } finally {
      loading.value = false
    }
  }
  
  const refreshToken = async () => {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token.value}`
        }
      })
      
      if (!response.ok) {
        throw new Error('Tokenåˆ·æ–°å¤±è´¥')
      }
      
      const { token: newToken } = await response.json()
      token.value = newToken
      
      const storage = localStorage.getItem('token') ? localStorage : sessionStorage
      storage.setItem('token', newToken)
      
      setAuthHeader(newToken)
      
      return newToken
    } catch (err) {
      // Tokenåˆ·æ–°å¤±è´¥ï¼Œæ‰§è¡Œç™»å‡º
      await logout()
      throw err
    }
  }
  
  const checkAuthStatus = async () => {
    const storedToken = localStorage.getItem('token') || sessionStorage.getItem('token')
    const storedUser = localStorage.getItem('user') || sessionStorage.getItem('user')
    
    if (storedToken && storedUser) {
      try {
        token.value = storedToken
        user.value = JSON.parse(storedUser)
        setAuthHeader(storedToken)
        
        // éªŒè¯tokenæœ‰æ•ˆæ€§
        const response = await fetch('/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${storedToken}`
          }
        })
        
        if (response.ok) {
          const userData = await response.json()
          user.value = userData
          
          // æ›´æ–°å­˜å‚¨çš„ç”¨æˆ·ä¿¡æ¯
          const storage = localStorage.getItem('token') ? localStorage : sessionStorage
          storage.setItem('user', JSON.stringify(userData))
        } else {
          // Tokenæ— æ•ˆï¼Œæ¸…é™¤çŠ¶æ€
          await logout()
        }
      } catch (err) {
        console.error('Auth check failed:', err)
        await logout()
      }
    }
  }
  
  // æƒé™æ£€æŸ¥æ–¹æ³•
  const hasPermission = (permission: string): boolean => {
    return userPermissions.value.includes(permission)
  }
  
  const hasAnyPermission = (permissions: string[]): boolean => {
    return permissions.some(permission => hasPermission(permission))
  }
  
  const hasAllPermissions = (permissions: string[]): boolean => {
    return permissions.every(permission => hasPermission(permission))
  }
  
  const hasRole = (role: string): boolean => {
    return userRole.value === role
  }
  
  const hasAnyRole = (roles: string[]): boolean => {
    return roles.includes(userRole.value)
  }
  
  // å·¥å…·æ–¹æ³•
  const setAuthHeader = (authToken: string | null) => {
    if (authToken) {
      // è®¾ç½®axiosé»˜è®¤headerï¼ˆå¦‚æœä½¿ç”¨axiosï¼‰
      // axios.defaults.headers.common['Authorization'] = `Bearer ${authToken}`
    } else {
      // æ¸…é™¤axiosé»˜è®¤header
      // delete axios.defaults.headers.common['Authorization']
    }
  }
  
  const clearError = () => {
    error.value = null
  }
  
  // è¿”å›storeæ¥å£
  return {
    // çŠ¶æ€
    user: readonly(user),
    loading: readonly(loading),
    error: readonly(error),
    token: readonly(token),
    
    // è®¡ç®—å±æ€§
    isAuthenticated,
    isAdmin,
    userName,
    userAvatar,
    userPermissions,
    userRole,
    
    // Actions
    login,
    register,
    logout,
    updateProfile,
    changePassword,
    refreshToken,
    checkAuthStatus,
    
    // æƒé™æ–¹æ³•
    hasPermission,
    hasAnyPermission,
    hasAllPermissions,
    hasRole,
    hasAnyRole,
    
    // å·¥å…·æ–¹æ³•
    clearError
  }
})

// stores/notification.ts
export const useNotificationStore = defineStore('notification', () => {
  // é€šçŸ¥ç±»å‹
  type NotificationType = 'success' | 'error' | 'warning' | 'info'
  
  interface Notification {
    id: string
    type: NotificationType
    title: string
    message?: string
    duration?: number
    persistent?: boolean
    actions?: Array<{
      label: string
      action: () => void
    }>
  }
  
  // çŠ¶æ€
  const notifications = ref<Notification[]>([])
  const unreadCount = ref(0)
  
  // Actions
  const addNotification = (notification: Omit<Notification, 'id'>) => {
    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9)
    const newNotification: Notification = {
      id,
      duration: 5000,
      persistent: false,
      ...notification
    }
    
    notifications.value.push(newNotification)
    
    // è‡ªåŠ¨ç§»é™¤éæŒä¹…åŒ–é€šçŸ¥
    if (!newNotification.persistent && newNotification.duration && newNotification.duration > 0) {
      setTimeout(() => {
        removeNotification(id)
      }, newNotification.duration)
    }
    
    return id
  }
  
  const removeNotification = (id: string) => {
    const index = notifications.value.findIndex(n => n.id === id)
    if (index > -1) {
      notifications.value.splice(index, 1)
    }
  }
  
  const clearAllNotifications = () => {
    notifications.value = []
  }
  
  // ä¾¿æ·æ–¹æ³•
  const showSuccess = (title: string, message?: string, options?: Partial<Notification>) => {
    return addNotification({ type: 'success', title, message, ...options })
  }
  
  const showError = (title: string, message?: string, options?: Partial<Notification>) => {
    return addNotification({ type: 'error', title, message, ...options })
  }
  
  const showWarning = (title: string, message?: string, options?: Partial<Notification>) => {
    return addNotification({ type: 'warning', title, message, ...options })
  }
  
  const showInfo = (title: string, message?: string, options?: Partial<Notification>) => {
    return addNotification({ type: 'info', title, message, ...options })
  }
  
  return {
    notifications: readonly(notifications),
    unreadCount: readonly(unreadCount),
    addNotification,
    removeNotification,
    clearAllNotifications,
    showSuccess,
    showError,
    showWarning,
    showInfo
  }
})

// stores/app.ts - åº”ç”¨å…¨å±€çŠ¶æ€
export const useAppStore = defineStore('app', () => {
  // çŠ¶æ€
  const loading = ref(false)
  const sidebarCollapsed = ref(false)
  const theme = ref<'light' | 'dark' | 'auto'>('light')
  const language = ref('zh-CN')
  
  // è®¡ç®—å±æ€§
  const isDarkMode = computed(() => {
    if (theme.value === 'auto') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches
    }
    return theme.value === 'dark'
  })
  
  // Actions
  const setLoading = (value: boolean) => {
    loading.value = value
  }
  
  const toggleSidebar = () => {
    sidebarCollapsed.value = !sidebarCollapsed.value
  }
  
  const setTheme = (newTheme: 'light' | 'dark' | 'auto') => {
    theme.value = newTheme
    localStorage.setItem('theme', newTheme)
    
    // åº”ç”¨ä¸»é¢˜åˆ°DOM
    document.documentElement.setAttribute('data-theme', newTheme)
  }
  
  const setLanguage = (lang: string) => {
    language.value = lang
    localStorage.setItem('language', lang)
  }
  
  const initializeApp = () => {
    // æ¢å¤ä¸»é¢˜è®¾ç½®
    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark' | 'auto'
    if (savedTheme) {
      setTheme(savedTheme)
    }
    
    // æ¢å¤è¯­è¨€è®¾ç½®
    const savedLanguage = localStorage.getItem('language')
    if (savedLanguage) {
      setLanguage(savedLanguage)
    }
    
    // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
    if (theme.value === 'auto') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      mediaQuery.addEventListener('change', () => {
        document.documentElement.setAttribute('data-theme', isDarkMode.value ? 'dark' : 'light')
      })
    }
  }
  
  return {
    loading: readonly(loading),
    sidebarCollapsed: readonly(sidebarCollapsed),
    theme: readonly(theme),
    language: readonly(language),
    isDarkMode,
    setLoading,
    toggleSidebar,
    setTheme,
    setLanguage,
    initializeApp
  }
})
```

</TabItem>
</Tabs>

## 4. Vueæ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

### 4.1 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

Vue 3åœ¨æ€§èƒ½æ–¹é¢æœ‰äº†æ˜¾è‘—æå‡ï¼Œä½†ä»éœ€è¦å¼€å‘è€…é‡‡ç”¨æ­£ç¡®çš„ä¼˜åŒ–ç­–ç•¥æ¥æ„å»ºé«˜æ€§èƒ½åº”ç”¨ã€‚

```mermaid
graph TB
    subgraph "Vueæ€§èƒ½ä¼˜åŒ–ç­–ç•¥"
        A[ç¼–è¯‘æ—¶ä¼˜åŒ–] --> A1[é™æ€æå‡]
        A --> A2[è¡¥ä¸æ ‡è®°]
        A --> A3[Tree Shaking]
        
        B[è¿è¡Œæ—¶ä¼˜åŒ–] --> B1[ç»„ä»¶ç¼“å­˜]
        B --> B2[è®¡ç®—å±æ€§ç¼“å­˜]
        B --> B3[äº‹ä»¶ç›‘å¬ä¼˜åŒ–]
        
        C[æ¸²æŸ“ä¼˜åŒ–] --> C1[è™šæ‹Ÿæ»šåŠ¨]
        C --> C2[æ‡’åŠ è½½]
        C --> C3[å¼‚æ­¥ç»„ä»¶]
        
        D[å†…å­˜ä¼˜åŒ–] --> D1[ç»„ä»¶å¸è½½æ¸…ç†]
        D --> D2[äº‹ä»¶ç›‘å¬å™¨æ¸…ç†]
        D --> D3[å®šæ—¶å™¨æ¸…ç†]
    end
```

#### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•

| ä¼˜åŒ–ç±»å‹ | æŠ€æœ¯æ–¹æ¡ˆ | é€‚ç”¨åœºæ™¯ | æ€§èƒ½æå‡ | å®ç°éš¾åº¦ |
|---------|----------|----------|----------|----------|
| **ç»„ä»¶ç¼“å­˜** | KeepAlive | é¢‘ç¹åˆ‡æ¢çš„ç»„ä»¶ | â­â­â­â­ | â­â­ |
| **è®¡ç®—å±æ€§** | computed() | å¤æ‚è®¡ç®—é€»è¾‘ | â­â­â­â­â­ | â­ |
| **è™šæ‹Ÿæ»šåŠ¨** | è‡ªå®šä¹‰å®ç° | å¤§åˆ—è¡¨æ¸²æŸ“ | â­â­â­â­â­ | â­â­â­â­ |
| **å¼‚æ­¥ç»„ä»¶** | defineAsyncComponent | ä»£ç åˆ†å‰² | â­â­â­â­ | â­â­ |
| **å“åº”å¼ä¼˜åŒ–** | shallowRef/shallowReactive | å¤§å¯¹è±¡å¤„ç† | â­â­â­ | â­â­â­ |

:::tip Vueæ€§èƒ½ä¼˜åŒ–åŸåˆ™
1. **æµ‹é‡ä¼˜å…ˆ**ï¼šä½¿ç”¨Vue DevToolsåˆ†ææ€§èƒ½ç“¶é¢ˆ
2. **æ¸è¿›ä¼˜åŒ–**ï¼šä»å½±å“æœ€å¤§çš„ä¼˜åŒ–å¼€å§‹
3. **é¿å…è¿‡æ—©ä¼˜åŒ–**ï¼šåœ¨ç¡®è®¤æ€§èƒ½é—®é¢˜åå†ä¼˜åŒ–
4. **ç”¨æˆ·ä½“éªŒå¯¼å‘**ï¼šå…³æ³¨ç”¨æˆ·æ„ŸçŸ¥çš„æ€§èƒ½æŒ‡æ ‡
5. **æŒç»­ç›‘æ§**ï¼šå»ºç«‹æ€§èƒ½ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
:::

---

Vue.jsä½œä¸ºç°ä»£å‰ç«¯å¼€å‘çš„é‡è¦æ¡†æ¶ï¼Œå…¶ç»„åˆå¼APIã€å“åº”å¼ç³»ç»Ÿå’Œä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿä¸ºå¼€å‘è€…æä¾›äº†å¼ºå¤§çš„å·¥å…·ã€‚é€šè¿‡æŒæ¡Vue 3çš„æ ¸å¿ƒç‰¹æ€§ã€ç»„ä»¶åŒ–å¼€å‘æ¨¡å¼å’Œæ€§èƒ½ä¼˜åŒ–æŠ€å·§ï¼Œå¯ä»¥æ„å»ºå‡ºé«˜è´¨é‡ã€é«˜æ€§èƒ½çš„ç°ä»£Webåº”ç”¨ã€‚