---
sidebar_position: 1
title: ç°ä»£å‰ç«¯å¼€å‘å…¨æ ˆæŒ‡å—
description: æ·±å…¥è§£æç°ä»£å‰ç«¯å¼€å‘æŠ€æœ¯æ ˆã€æ¶æ„æ¨¡å¼ã€æ€§èƒ½ä¼˜åŒ–ä¸å·¥ç¨‹åŒ–å®è·µ
authors: [Laby]
tags: [å‰ç«¯å¼€å‘, React, Vue, TypeScript, æ€§èƒ½ä¼˜åŒ–, å·¥ç¨‹åŒ–, å¾®å‰ç«¯, ç»„ä»¶åº“]
last_update:
  date: 2025-08-12
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# ç°ä»£å‰ç«¯å¼€å‘å…¨æ ˆæŒ‡å—

ç°ä»£å‰ç«¯å¼€å‘å·²ç»ä»ç®€å•çš„é¡µé¢åˆ¶ä½œæ¼”è¿›ä¸ºå¤æ‚çš„å·¥ç¨‹åŒ–ä½“ç³»ï¼Œæ¶µç›–äº†æ¡†æ¶é€‰å‹ã€æ¶æ„è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–ã€å·¥ç¨‹åŒ–å·¥å…·é“¾ç­‰å¤šä¸ªç»´åº¦ã€‚æœ¬æŒ‡å—å°†æ·±å…¥è§£æç°ä»£å‰ç«¯å¼€å‘çš„æ ¸å¿ƒæŠ€æœ¯å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºé«˜è´¨é‡çš„å‰ç«¯åº”ç”¨ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**ç°ä»£å‰ç«¯ = ç»„ä»¶åŒ–æ¶æ„ + å·¥ç¨‹åŒ–å·¥å…·é“¾ + æ€§èƒ½ä¼˜åŒ– + ç”¨æˆ·ä½“éªŒ**
- ğŸ¯ **ç»„ä»¶åŒ–æ¶æ„**ï¼šå¯å¤ç”¨ã€å¯ç»´æŠ¤çš„ç»„ä»¶ä½“ç³»
- ğŸ› ï¸ **å·¥ç¨‹åŒ–å·¥å…·é“¾**ï¼šè‡ªåŠ¨åŒ–æ„å»ºã€æµ‹è¯•ã€éƒ¨ç½²æµç¨‹
- âš¡ **æ€§èƒ½ä¼˜åŒ–**ï¼šé¦–å±åŠ è½½ã€è¿è¡Œæ—¶æ€§èƒ½ã€ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- ğŸ¨ **ç°ä»£åŒ–UI**ï¼šå“åº”å¼è®¾è®¡ã€äº¤äº’åŠ¨æ•ˆã€æ— éšœç¢è®¿é—®
- ğŸ”§ **å¼€å‘ä½“éªŒ**ï¼šçƒ­æ›´æ–°ã€ç±»å‹æ£€æŸ¥ã€è°ƒè¯•å·¥å…·
- ğŸŒ **è·¨å¹³å°èƒ½åŠ›**ï¼šWebã€ç§»åŠ¨ç«¯ã€æ¡Œé¢ç«¯ç»Ÿä¸€å¼€å‘
:::

## 1. å‰ç«¯æŠ€æœ¯æ ˆå…¨æ™¯å›¾

### 1.1 æŠ€æœ¯æ ˆæ¶æ„å±‚æ¬¡

ç°ä»£å‰ç«¯æŠ€æœ¯æ ˆå¯ä»¥åˆ†ä¸ºå¤šä¸ªå±‚æ¬¡ï¼Œæ¯ä¸ªå±‚æ¬¡éƒ½æœ‰å…¶ç‰¹å®šçš„èŒè´£å’ŒæŠ€æœ¯é€‰å‹ã€‚

```mermaid
graph TB
    subgraph "ç°ä»£å‰ç«¯æŠ€æœ¯æ ˆæ¶æ„"
        subgraph "ç”¨æˆ·ç•Œé¢å±‚"
            UI1[ç»„ä»¶åº“ Ant Design/Element Plus]
            UI2[CSSæ¡†æ¶ Tailwind/Bootstrap]
            UI3[å›¾æ ‡åº“ Iconify/FontAwesome]
        end
        
        subgraph "æ¡†æ¶å±‚"
            FW1[React 18+ / Vue 3+]
            FW2[Next.js / Nuxt.js]
            FW3[çŠ¶æ€ç®¡ç† Redux/Pinia]
        end
        
        subgraph "è¯­è¨€å±‚"
            LANG1[TypeScript]
            LANG2[JavaScript ES2023+]
            LANG3[CSS-in-JS / SCSS]
        end
        
        subgraph "å·¥å…·é“¾å±‚"
            TOOL1[æ„å»ºå·¥å…· Vite/Webpack]
            TOOL2[åŒ…ç®¡ç† pnpm/yarn]
            TOOL3[ä»£ç è´¨é‡ ESLint/Prettier]
        end
        
        subgraph "åŸºç¡€è®¾æ–½å±‚"
            INFRA1[CDN / é™æ€èµ„æº]
            INFRA2[ç›‘æ§ Sentry/Analytics]
            INFRA3[éƒ¨ç½² Vercel/Netlify]
        end
    end
```

#### æŠ€æœ¯é€‰å‹å¯¹æ¯”çŸ©é˜µ

| æŠ€æœ¯ç±»åˆ« | ä¸»æµæ–¹æ¡ˆ | ä¼˜åŠ¿ | é€‚ç”¨åœºæ™¯ | å­¦ä¹ æˆæœ¬ |
|---------|---------|------|----------|----------|
| **å‰ç«¯æ¡†æ¶** | React | ç”Ÿæ€ä¸°å¯Œã€çµæ´»æ€§é«˜ | å¤§å‹åº”ç”¨ã€å¤æ‚äº¤äº’ | â­â­â­ |
| | Vue | å­¦ä¹ æ›²çº¿å¹³ç¼“ã€æ–‡æ¡£å®Œå–„ | ä¸­å°å‹é¡¹ç›®ã€å¿«é€Ÿå¼€å‘ | â­â­ |
| | Angular | ä¼ä¸šçº§ã€å®Œæ•´è§£å†³æ–¹æ¡ˆ | å¤§å‹ä¼ä¸šåº”ç”¨ | â­â­â­â­ |
| **çŠ¶æ€ç®¡ç†** | Redux Toolkit | å¯é¢„æµ‹ã€æ—¶é—´æ—…è¡Œè°ƒè¯• | å¤æ‚çŠ¶æ€é€»è¾‘ | â­â­â­ |
| | Zustand | è½»é‡çº§ã€ç®€å•æ˜“ç”¨ | ä¸­å°å‹åº”ç”¨ | â­â­ |
| | Pinia | Vueç”Ÿæ€ã€ç»„åˆå¼API | Vueé¡¹ç›® | â­â­ |
| **æ„å»ºå·¥å…·** | Vite | å¿«é€Ÿå†·å¯åŠ¨ã€HMR | ç°ä»£é¡¹ç›®é¦–é€‰ | â­â­ |
| | Webpack | æˆç†Ÿç¨³å®šã€æ’ä»¶ä¸°å¯Œ | å¤æ‚é…ç½®éœ€æ±‚ | â­â­â­â­ |
| **CSSæ–¹æ¡ˆ** | Tailwind CSS | åŸå­åŒ–ã€é«˜åº¦å¯å®šåˆ¶ | å¿«é€ŸåŸå‹ã€è®¾è®¡ç³»ç»Ÿ | â­â­â­ |
| | CSS Modules | ä½œç”¨åŸŸéš”ç¦»ã€é›¶è¿è¡Œæ—¶ | ç»„ä»¶åŒ–å¼€å‘ | â­â­ |
| | Styled Components | CSS-in-JSã€åŠ¨æ€æ ·å¼ | Reactç”Ÿæ€ | â­â­â­ |### 1.2 å‰ç«¯å¼€
å‘ç”Ÿå‘½å‘¨æœŸ

ç°ä»£å‰ç«¯å¼€å‘éµå¾ªå®Œæ•´çš„è½¯ä»¶å¼€å‘ç”Ÿå‘½å‘¨æœŸï¼Œæ¯ä¸ªé˜¶æ®µéƒ½æœ‰ç›¸åº”çš„å·¥å…·å’Œæœ€ä½³å®è·µã€‚

<Tabs>
<TabItem value="planning" label="è§„åˆ’è®¾è®¡">

#### éœ€æ±‚åˆ†æä¸æŠ€æœ¯é€‰å‹

```mermaid
flowchart TD
    A[é¡¹ç›®éœ€æ±‚åˆ†æ] --> B{é¡¹ç›®è§„æ¨¡è¯„ä¼°}
    B -->|å°å‹é¡¹ç›®| C[Vue 3 + Vite]
    B -->|ä¸­å‹é¡¹ç›®| D[React + Next.js]
    B -->|å¤§å‹é¡¹ç›®| E[å¾®å‰ç«¯æ¶æ„]
    
    C --> F[æŠ€æœ¯æ ˆç¡®å®š]
    D --> F
    E --> F
    
    F --> G[æ¶æ„è®¾è®¡]
    G --> H[UI/UXè®¾è®¡]
    H --> I[å¼€å‘ç¯å¢ƒæ­å»º]
```

**æŠ€æœ¯é€‰å‹å†³ç­–å› ç´ **ï¼š
- **å›¢é˜ŸæŠ€èƒ½**ï¼šå›¢é˜Ÿå¯¹æŠ€æœ¯æ ˆçš„ç†Ÿæ‚‰ç¨‹åº¦
- **é¡¹ç›®è§„æ¨¡**ï¼šå°å‹ã€ä¸­å‹ã€å¤§å‹é¡¹ç›®çš„ä¸åŒéœ€æ±‚
- **æ€§èƒ½è¦æ±‚**ï¼šé¦–å±åŠ è½½ã€è¿è¡Œæ—¶æ€§èƒ½æŒ‡æ ‡
- **ç»´æŠ¤æˆæœ¬**ï¼šé•¿æœŸç»´æŠ¤å’Œæ‰©å±•çš„ä¾¿åˆ©æ€§
- **ç”Ÿæ€ç³»ç»Ÿ**ï¼šç¬¬ä¸‰æ–¹åº“ã€å·¥å…·é“¾çš„å®Œå–„ç¨‹åº¦

</TabItem>
<TabItem value="development" label="å¼€å‘é˜¶æ®µ">

#### å¼€å‘å·¥ä½œæµç¨‹

```typescript title="ç°ä»£å‰ç«¯å¼€å‘å·¥ä½œæµ"
// 1. é¡¹ç›®åˆå§‹åŒ–
const projectSetup = {
  packageManager: 'pnpm', // å¿«é€Ÿã€èŠ‚çœç£ç›˜ç©ºé—´
  buildTool: 'vite',      // å¿«é€Ÿæ„å»ºå’Œçƒ­æ›´æ–°
  framework: 'react',     // æˆ– vueã€angular
  language: 'typescript', // ç±»å‹å®‰å…¨
  linting: 'eslint',      // ä»£ç è´¨é‡
  formatting: 'prettier', // ä»£ç æ ¼å¼åŒ–
  testing: 'vitest',      // å•å…ƒæµ‹è¯•
  e2e: 'playwright'       // ç«¯åˆ°ç«¯æµ‹è¯•
};

// 2. å¼€å‘ç¯å¢ƒé…ç½®
const devEnvironment = {
  hotReload: true,        // çƒ­æ›´æ–°
  sourceMap: true,        // æºç æ˜ å°„
  typeChecking: true,     // ç±»å‹æ£€æŸ¥
  linting: 'onSave',      // ä¿å­˜æ—¶æ£€æŸ¥
  autoFormat: true        // è‡ªåŠ¨æ ¼å¼åŒ–
};

// 3. ä»£ç ç»„ç»‡ç»“æ„
const projectStructure = `
src/
â”œâ”€â”€ components/         # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ ui/            # åŸºç¡€UIç»„ä»¶
â”‚   â”œâ”€â”€ business/      # ä¸šåŠ¡ç»„ä»¶
â”‚   â””â”€â”€ layout/        # å¸ƒå±€ç»„ä»¶
â”œâ”€â”€ pages/             # é¡µé¢ç»„ä»¶
â”œâ”€â”€ hooks/             # è‡ªå®šä¹‰Hooks
â”œâ”€â”€ utils/             # å·¥å…·å‡½æ•°
â”œâ”€â”€ services/          # APIæœåŠ¡
â”œâ”€â”€ stores/            # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ styles/            # æ ·å¼æ–‡ä»¶
â”œâ”€â”€ types/             # TypeScriptç±»å‹å®šä¹‰
â””â”€â”€ tests/             # æµ‹è¯•æ–‡ä»¶
`;
```

**å¼€å‘æœ€ä½³å®è·µ**ï¼š
- **ç»„ä»¶åŒ–å¼€å‘**ï¼šå•ä¸€èŒè´£ã€å¯å¤ç”¨ã€å¯æµ‹è¯•
- **ç±»å‹å®‰å…¨**ï¼šä½¿ç”¨TypeScriptæä¾›ç±»å‹æ£€æŸ¥
- **ä»£ç è§„èŒƒ**ï¼šç»Ÿä¸€çš„ä»£ç é£æ ¼å’Œå‘½åè§„èŒƒ
- **ç‰ˆæœ¬æ§åˆ¶**ï¼šåˆç†çš„Gitå·¥ä½œæµå’Œæäº¤è§„èŒƒ
- **æ–‡æ¡£ç»´æŠ¤**ï¼šç»„ä»¶æ–‡æ¡£ã€APIæ–‡æ¡£ã€README

</TabItem>
<TabItem value="testing" label="æµ‹è¯•é˜¶æ®µ">

#### æµ‹è¯•ç­–ç•¥é‡‘å­—å¡”

```mermaid
pie
    title å‰ç«¯æµ‹è¯•é‡‘å­—å¡”
    
    "E2Eæµ‹è¯•" : 10
    "é›†æˆæµ‹è¯•" : 30  
    "å•å…ƒæµ‹è¯•" : 60
```

**æµ‹è¯•ç±»å‹ä¸å·¥å…·**ï¼š

| æµ‹è¯•ç±»å‹ | æµ‹è¯•èŒƒå›´ | æ¨èå·¥å…· | æµ‹è¯•æ¯”ä¾‹ |
|---------|---------|----------|----------|
| **å•å…ƒæµ‹è¯•** | å‡½æ•°ã€ç»„ä»¶ã€Hook | Vitest + Testing Library | 60% |
| **é›†æˆæµ‹è¯•** | ç»„ä»¶äº¤äº’ã€APIé›†æˆ | MSW + Testing Library | 30% |
| **E2Eæµ‹è¯•** | ç”¨æˆ·å®Œæ•´æµç¨‹ | Playwright + Cypress | 10% |

```typescript title="æµ‹è¯•ç¤ºä¾‹"
// å•å…ƒæµ‹è¯•ç¤ºä¾‹
import { render, screen } from '@testing-library/react';
import { Button } from './Button';

describe('Button Component', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('handles click events', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    screen.getByText('Click me').click();
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});

// E2Eæµ‹è¯•ç¤ºä¾‹
import { test, expect } from '@playwright/test';

test('user can complete checkout flow', async ({ page }) => {
  await page.goto('/products');
  await page.click('[data-testid="add-to-cart"]');
  await page.click('[data-testid="checkout"]');
  
  await expect(page.locator('[data-testid="success-message"]'))
    .toBeVisible();
});
```

</TabItem>
<TabItem value="deployment" label="éƒ¨ç½²ä¸Šçº¿">

#### CI/CDæµæ°´çº¿

```mermaid
graph LR
    A[ä»£ç æäº¤] --> B[ä»£ç æ£€æŸ¥]
    B --> C[å•å…ƒæµ‹è¯•]
    C --> D[æ„å»ºæ‰“åŒ…]
    D --> E[E2Eæµ‹è¯•]
    E --> F[éƒ¨ç½²é¢„è§ˆ]
    F --> G[äººå·¥å®¡æ ¸]
    G --> H[ç”Ÿäº§éƒ¨ç½²]
    H --> I[ç›‘æ§å‘Šè­¦]
```

**éƒ¨ç½²ç­–ç•¥**ï¼š
- **è“ç»¿éƒ¨ç½²**ï¼šé›¶åœæœºæ—¶é—´éƒ¨ç½²
- **é‡‘ä¸é›€å‘å¸ƒ**ï¼šæ¸è¿›å¼å‘å¸ƒï¼Œé™ä½é£é™©
- **å›æ»šæœºåˆ¶**ï¼šå¿«é€Ÿå›æ»šåˆ°ç¨³å®šç‰ˆæœ¬
- **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§åº”ç”¨çŠ¶æ€

</TabItem>
</Tabs>

## 2. Reactç”Ÿæ€ç³»ç»Ÿæ·±åº¦è§£æ

### 2.1 React 18+ æ–°ç‰¹æ€§ä¸æœ€ä½³å®è·µ

React 18å¼•å…¥äº†å¹¶å‘ç‰¹æ€§ã€è‡ªåŠ¨æ‰¹å¤„ç†ã€Suspenseæ”¹è¿›ç­‰é‡è¦æ›´æ–°ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½åº”ç”¨æä¾›äº†æ›´å¼ºå¤§çš„èƒ½åŠ›ã€‚

<Tabs>
<TabItem value="concurrent" label="å¹¶å‘ç‰¹æ€§">

#### å¹¶å‘æ¸²æŸ“ä¸Suspense

```typescript title="React 18å¹¶å‘ç‰¹æ€§ç¤ºä¾‹"
import { Suspense, lazy, startTransition, useDeferredValue } from 'react';

// 1. ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½
const LazyComponent = lazy(() => import('./LazyComponent'));

// 2. å¹¶å‘æ¸²æŸ“ç»„ä»¶
function SearchResults({ query }: { query: string }) {
  // å»¶è¿Ÿå€¼ï¼Œé™ä½æœç´¢è¾“å…¥çš„ä¼˜å…ˆçº§
  const deferredQuery = useDeferredValue(query);
  
  return (
    <div>
      <h2>æœç´¢ç»“æœ</h2>
      <Suspense fallback={<SearchSkeleton />}>
        <SearchList query={deferredQuery} />
      </Suspense>
    </div>
  );
}

// 3. ä½¿ç”¨startTransitionæ ‡è®°éç´§æ€¥æ›´æ–°
function SearchInput() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  
  const handleSearch = (value: string) => {
    setQuery(value); // ç´§æ€¥æ›´æ–°ï¼šç«‹å³æ›´æ–°è¾“å…¥æ¡†
    
    startTransition(() => {
      // éç´§æ€¥æ›´æ–°ï¼šæœç´¢ç»“æœå¯ä»¥å»¶è¿Ÿ
      setSearchResults(value);
    });
  };
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="æœç´¢..."
      />
      {isPending && <Spinner />}
    </div>
  );
}
```

**å¹¶å‘ç‰¹æ€§ä¼˜åŠ¿**ï¼š
- **å¯ä¸­æ–­æ¸²æŸ“**ï¼šReactå¯ä»¥æš‚åœæ¸²æŸ“å·¥ä½œï¼Œä¼˜å…ˆå¤„ç†ç”¨æˆ·äº¤äº’
- **æ—¶é—´åˆ‡ç‰‡**ï¼šå°†é•¿æ—¶é—´çš„æ¸²æŸ“å·¥ä½œåˆ†è§£ä¸ºå°å—
- **ä¼˜å…ˆçº§è°ƒåº¦**ï¼šæ ¹æ®æ›´æ–°çš„é‡è¦æ€§åˆ†é…ä¸åŒä¼˜å…ˆçº§
- **æ›´å¥½çš„ç”¨æˆ·ä½“éªŒ**ï¼šå‡å°‘é¡µé¢å¡é¡¿ï¼Œæå‡å“åº”æ€§

</TabItem>
<TabItem value="hooks" label="Hooksæœ€ä½³å®è·µ">

#### è‡ªå®šä¹‰Hooksè®¾è®¡æ¨¡å¼

```typescript title="é«˜è´¨é‡è‡ªå®šä¹‰Hooks"
// 1. æ•°æ®è·å–Hook
function useApi<T>(url: string, options?: RequestInit) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url, {
          ...options,
          signal: abortController.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err as Error);
        }
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
    
    return () => abortController.abort();
  }, [url, JSON.stringify(options)]);
  
  return { data, loading, error };
}

// 2. æœ¬åœ°å­˜å‚¨Hook
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  
  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);
  
  return [storedValue, setValue] as const;
}

// 3. é˜²æŠ–Hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// 4. ä½¿ç”¨ç¤ºä¾‹
function UserProfile({ userId }: { userId: string }) {
  const { data: user, loading, error } = useApi<User>(`/api/users/${userId}`);
  const [preferences, setPreferences] = useLocalStorage('userPreferences', {});
  
  if (loading) return <ProfileSkeleton />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return <NotFound />;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <UserSettings 
        preferences={preferences}
        onPreferencesChange={setPreferences}
      />
    </div>
  );
}
```

</TabItem>
<TabItem value="performance" label="æ€§èƒ½ä¼˜åŒ–">

#### Reactæ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```typescript title="Reactæ€§èƒ½ä¼˜åŒ–å®è·µ"
// 1. ç»„ä»¶è®°å¿†åŒ–
const ExpensiveComponent = memo(({ data, onUpdate }: Props) => {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: expensiveCalculation(item)
    }));
  }, [data]);
  
  const handleUpdate = useCallback((id: string, updates: Partial<Item>) => {
    onUpdate(id, updates);
  }, [onUpdate]);
  
  return (
    <div>
      {processedData.map(item => (
        <ItemCard 
          key={item.id}
          item={item}
          onUpdate={handleUpdate}
        />
      ))}
    </div>
  );
});

// 2. è™šæ‹Ÿæ»šåŠ¨
function VirtualList<T>({ 
  items, 
  itemHeight, 
  containerHeight,
  renderItem 
}: VirtualListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.min(
    visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
    items.length
  );
  
  const visibleItems = items.slice(visibleStart, visibleEnd);
  
  return (
    <div 
      style={{ height: containerHeight, overflow: 'auto' }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map((item, index) => (
          <div
            key={visibleStart + index}
            style={{
              position: 'absolute',
              top: (visibleStart + index) * itemHeight,
              height: itemHeight,
              width: '100%'
            }}
          >
            {renderItem(item, visibleStart + index)}
          </div>
        ))}
      </div>
    </div>
  );
}

// 3. é”™è¯¯è¾¹ç•Œ
class ErrorBoundary extends Component<
  { children: ReactNode; fallback: ComponentType<{ error: Error }> },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // å‘é€é”™è¯¯æŠ¥å‘Šåˆ°ç›‘æ§æœåŠ¡
    reportError(error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback;
      return <FallbackComponent error={this.state.error!} />;
    }
    
    return this.props.children;
  }
}
```

**æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥æ¸…å•**ï¼š
- âœ… ä½¿ç”¨React.memo()é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
- âœ… ä½¿ç”¨useMemo()ç¼“å­˜æ˜‚è´µçš„è®¡ç®—ç»“æœ
- âœ… ä½¿ç”¨useCallback()ç¨³å®šå‡½æ•°å¼•ç”¨
- âœ… å®ç°è™šæ‹Ÿæ»šåŠ¨å¤„ç†å¤§åˆ—è¡¨
- âœ… ä½¿ç”¨ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- âœ… ä¼˜åŒ–Bundleå¤§å°å’ŒåŠ è½½æ€§èƒ½
- âœ… ä½¿ç”¨é”™è¯¯è¾¹ç•Œå¤„ç†å¼‚å¸¸

</TabItem>
</Tabs>

### 2.2 çŠ¶æ€ç®¡ç†æ¶æ„è®¾è®¡

ç°ä»£Reactåº”ç”¨çš„çŠ¶æ€ç®¡ç†éœ€è¦è€ƒè™‘æœ¬åœ°çŠ¶æ€ã€å…¨å±€çŠ¶æ€ã€æœåŠ¡å™¨çŠ¶æ€ç­‰å¤šä¸ªç»´åº¦ï¼Œé€‰æ‹©åˆé€‚çš„çŠ¶æ€ç®¡ç†æ–¹æ¡ˆè‡³å…³é‡è¦ã€‚

<Tabs>
<TabItem value="redux-toolkit" label="Redux Toolkit">

#### ç°ä»£Reduxæœ€ä½³å®è·µ

```typescript title="Redux Toolkitå®Œæ•´å®ç°"
// 1. Storeé…ç½®
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import { userSlice } from './slices/userSlice';
import { apiSlice } from './api/apiSlice';

export const store = configureStore({
  reducer: {
    user: userSlice.reducer,
    api: apiSlice.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
      },
    }).concat(apiSlice.middleware),
  devTools: process.env.NODE_ENV !== 'production',
});

setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// 2. Sliceå®šä¹‰
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface UserState {
  currentUser: User | null;
  preferences: UserPreferences;
  loading: boolean;
  error: string | null;
}

const initialState: UserState = {
  currentUser: null,
  preferences: {
    theme: 'light',
    language: 'zh-CN',
    notifications: true,
  },
  loading: false,
  error: null,
};

export const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setUser: (state, action: PayloadAction<User>) => {
      state.currentUser = action.payload;
      state.error = null;
    },
    updatePreferences: (state, action: PayloadAction<Partial<UserPreferences>>) => {
      state.preferences = { ...state.preferences, ...action.payload };
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string>) => {
      state.error = action.payload;
      state.loading = false;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.loading = false;
        state.currentUser = action.payload;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'ç™»å½•å¤±è´¥';
      });
  },
});

// 3. å¼‚æ­¥Thunk
import { createAsyncThunk } from '@reduxjs/toolkit';

export const loginUser = createAsyncThunk(
  'user/login',
  async (credentials: LoginCredentials, { rejectWithValue }) => {
    try {
      const response = await authAPI.login(credentials);
      localStorage.setItem('token', response.token);
      return response.user;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// 4. RTK Query APIå®šä¹‰
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const apiSlice = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).user.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (builder) => ({
    getUsers: builder.query<User[], void>({
      query: () => '/users',
      providesTags: ['User'],
    }),
    getUserById: builder.query<User, string>({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }],
    }),
    updateUser: builder.mutation<User, { id: string; updates: Partial<User> }>({
      query: ({ id, updates }) => ({
        url: `/users/${id}`,
        method: 'PATCH',
        body: updates,
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }],
    }),
  }),
});

export const { useGetUsersQuery, useGetUserByIdQuery, useUpdateUserMutation } = apiSlice;

// 5. ç±»å‹å®‰å…¨çš„Hooks
import { useSelector, useDispatch } from 'react-redux';
import type { TypedUseSelectorHook } from 'react-redux';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

// 6. ç»„ä»¶ä¸­ä½¿ç”¨
function UserProfile({ userId }: { userId: string }) {
  const dispatch = useAppDispatch();
  const { currentUser, preferences, loading } = useAppSelector(state => state.user);
  const { data: user, error, isLoading } = useGetUserByIdQuery(userId);
  const [updateUser] = useUpdateUserMutation();
  
  const handleUpdatePreferences = (newPreferences: Partial<UserPreferences>) => {
    dispatch(userSlice.actions.updatePreferences(newPreferences));
  };
  
  const handleUpdateProfile = async (updates: Partial<User>) => {
    try {
      await updateUser({ id: userId, updates }).unwrap();
      toast.success('Profile updated successfully');
    } catch (error) {
      toast.error('Failed to update profile');
    }
  };
  
  if (isLoading) return <ProfileSkeleton />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div>
      <UserInfo user={user} onUpdate={handleUpdateProfile} />
      <UserSettings 
        preferences={preferences}
        onUpdate={handleUpdatePreferences}
      />
    </div>
  );
}
```

</TabItem>
<TabItem value="zustand" label="Zustandè½»é‡æ–¹æ¡ˆ">

#### ZustandçŠ¶æ€ç®¡ç†

```typescript title="Zustandå®ç°æ–¹æ¡ˆ"
import { create } from 'zustand';
import { devtools, persist, subscribeWithSelector } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

// 1. åŸºç¡€Storeå®šä¹‰
interface UserStore {
  // State
  user: User | null;
  preferences: UserPreferences;
  loading: boolean;
  error: string | null;
  
  // Actions
  setUser: (user: User) => void;
  updatePreferences: (preferences: Partial<UserPreferences>) => void;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  clearError: () => void;
}

export const useUserStore = create<UserStore>()(
  devtools(
    persist(
      subscribeWithSelector(
        immer((set, get) => ({
          // Initial state
          user: null,
          preferences: {
            theme: 'light',
            language: 'zh-CN',
            notifications: true,
          },
          loading: false,
          error: null,
          
          // Actions
          setUser: (user) => set((state) => {
            state.user = user;
            state.error = null;
          }),
          
          updatePreferences: (newPreferences) => set((state) => {
            state.preferences = { ...state.preferences, ...newPreferences };
          }),
          
          login: async (credentials) => {
            set((state) => {
              state.loading = true;
              state.error = null;
            });
            
            try {
              const response = await authAPI.login(credentials);
              set((state) => {
                state.user = response.user;
                state.loading = false;
              });
              localStorage.setItem('token', response.token);
            } catch (error) {
              set((state) => {
                state.error = error.message;
                state.loading = false;
              });
            }
          },
          
          logout: () => set((state) => {
            state.user = null;
            localStorage.removeItem('token');
          }),
          
          clearError: () => set((state) => {
            state.error = null;
          }),
        }))
      ),
      {
        name: 'user-store',
        partialize: (state) => ({ 
          user: state.user, 
          preferences: state.preferences 
        }),
      }
    ),
    { name: 'user-store' }
  )
);

// 2. è®¡ç®—å±æ€§å’Œé€‰æ‹©å™¨
export const useUserSelectors = () => {
  const isLoggedIn = useUserStore(state => !!state.user);
  const userName = useUserStore(state => state.user?.name || '');
  const isLoading = useUserStore(state => state.loading);
  const theme = useUserStore(state => state.preferences.theme);
  
  return { isLoggedIn, userName, isLoading, theme };
};

// 3. åˆ†ç¦»çš„Actions
export const userActions = {
  login: (credentials: LoginCredentials) => useUserStore.getState().login(credentials),
  logout: () => useUserStore.getState().logout(),
  updatePreferences: (preferences: Partial<UserPreferences>) => 
    useUserStore.getState().updatePreferences(preferences),
};

// 4. ç»„ä»¶ä¸­ä½¿ç”¨
function LoginForm() {
  const { loading, error } = useUserStore();
  const { isLoggedIn } = useUserSelectors();
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    await userActions.login(credentials);
  };
  
  if (isLoggedIn) {
    return <Navigate to="/dashboard" replace />;
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={credentials.email}
        onChange={(e) => setCredentials(prev => ({ ...prev, email: e.target.value }))}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={credentials.password}
        onChange={(e) => setCredentials(prev => ({ ...prev, password: e.target.value }))}
        placeholder="Password"
        required
      />
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
      {error && <ErrorMessage message={error} />}
    </form>
  );
}

// 5. ä¸­é—´ä»¶å’Œæ’ä»¶
const loggerMiddleware = (config) => (set, get, api) =>
  config(
    (...args) => {
      console.log('Previous state:', get());
      set(...args);
      console.log('New state:', get());
    },
    get,
    api
  );

// 6. å¤šStoreç»„åˆ
interface AppStore {
  userStore: UserStore;
  cartStore: CartStore;
  uiStore: UIStore;
}

export const useAppStore = create<AppStore>()((set, get) => ({
  userStore: useUserStore.getState(),
  cartStore: useCartStore.getState(),
  uiStore: useUIStore.getState(),
}));
```

</TabItem>
<TabItem value="server-state" label="æœåŠ¡å™¨çŠ¶æ€ç®¡ç†">

#### React Query/TanStack Query

```typescript title="æœåŠ¡å™¨çŠ¶æ€ç®¡ç†æœ€ä½³å®è·µ"
import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from '@tanstack/react-query';

// 1. Query Keyså·¥å‚
export const queryKeys = {
  all: ['todos'] as const,
  lists: () => [...queryKeys.all, 'list'] as const,
  list: (filters: string) => [...queryKeys.lists(), { filters }] as const,
  details: () => [...queryKeys.all, 'detail'] as const,
  detail: (id: number) => [...queryKeys.details(), id] as const,
};

// 2. APIå‡½æ•°
const todoAPI = {
  getAll: async (filters?: TodoFilters): Promise<Todo[]> => {
    const params = new URLSearchParams(filters);
    const response = await fetch(`/api/todos?${params}`);
    if (!response.ok) throw new Error('Failed to fetch todos');
    return response.json();
  },
  
  getById: async (id: number): Promise<Todo> => {
    const response = await fetch(`/api/todos/${id}`);
    if (!response.ok) throw new Error('Failed to fetch todo');
    return response.json();
  },
  
  create: async (todo: CreateTodoRequest): Promise<Todo> => {
    const response = await fetch('/api/todos', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(todo),
    });
    if (!response.ok) throw new Error('Failed to create todo');
    return response.json();
  },
  
  update: async ({ id, ...updates }: UpdateTodoRequest): Promise<Todo> => {
    const response = await fetch(`/api/todos/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates),
    });
    if (!response.ok) throw new Error('Failed to update todo');
    return response.json();
  },
  
  delete: async (id: number): Promise<void> => {
    const response = await fetch(`/api/todos/${id}`, { method: 'DELETE' });
    if (!response.ok) throw new Error('Failed to delete todo');
  },
};

// 3. è‡ªå®šä¹‰Hooks
export function useTodos(filters?: TodoFilters) {
  return useQuery({
    queryKey: queryKeys.list(JSON.stringify(filters)),
    queryFn: () => todoAPI.getAll(filters),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
    cacheTime: 10 * 60 * 1000, // 10åˆ†é’Ÿ
    refetchOnWindowFocus: false,
    retry: (failureCount, error) => {
      if (error.status === 404) return false;
      return failureCount < 3;
    },
  });
}

export function useTodo(id: number) {
  return useQuery({
    queryKey: queryKeys.detail(id),
    queryFn: () => todoAPI.getById(id),
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
  });
}

export function useCreateTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: todoAPI.create,
    onSuccess: (newTodo) => {
      // ä¹è§‚æ›´æ–°
      queryClient.setQueryData<Todo[]>(queryKeys.lists(), (old) => 
        old ? [...old, newTodo] : [newTodo]
      );
      
      // é‡æ–°è·å–åˆ—è¡¨æ•°æ®
      queryClient.invalidateQueries({ queryKey: queryKeys.lists() });
      
      toast.success('Todo created successfully');
    },
    onError: (error) => {
      toast.error(`Failed to create todo: ${error.message}`);
    },
  });
}

export function useUpdateTodo() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: todoAPI.update,
    onMutate: async (updatedTodo) => {
      // å–æ¶ˆç›¸å…³æŸ¥è¯¢
      await queryClient.cancelQueries({ queryKey: queryKeys.detail(updatedTodo.id) });
      
      // ä¿å­˜ä¹‹å‰çš„æ•°æ®
      const previousTodo = queryClient.getQueryData(queryKeys.detail(updatedTodo.id));
      
      // ä¹è§‚æ›´æ–°
      queryClient.setQueryData(queryKeys.detail(updatedTodo.id), updatedTodo);
      
      return { previousTodo };
    },
    onError: (err, updatedTodo, context) => {
      // å›æ»š
      if (context?.previousTodo) {
        queryClient.setQueryData(queryKeys.detail(updatedTodo.id), context.previousTodo);
      }
      toast.error(`Failed to update todo: ${err.message}`);
    },
    onSettled: (data, error, updatedTodo) => {
      // é‡æ–°è·å–æ•°æ®
      queryClient.invalidateQueries({ queryKey: queryKeys.detail(updatedTodo.id) });
    },
  });
}

// 4. æ— é™æ»šåŠ¨
export function useInfiniteTodos(filters?: TodoFilters) {
  return useInfiniteQuery({
    queryKey: ['todos', 'infinite', filters],
    queryFn: ({ pageParam = 0 }) => 
      todoAPI.getAll({ ...filters, page: pageParam, limit: 20 }),
    getNextPageParam: (lastPage, pages) => {
      return lastPage.length === 20 ? pages.length : undefined;
    },
    staleTime: 5 * 60 * 1000,
  });
}

// 5. ç»„ä»¶ä½¿ç”¨ç¤ºä¾‹
function TodoList({ filters }: { filters?: TodoFilters }) {
  const { data: todos, isLoading, error, refetch } = useTodos(filters);
  const createTodo = useCreateTodo();
  const updateTodo = useUpdateTodo();
  
  const handleCreate = (todoData: CreateTodoRequest) => {
    createTodo.mutate(todoData);
  };
  
  const handleToggle = (todo: Todo) => {
    updateTodo.mutate({
      id: todo.id,
      completed: !todo.completed,
    });
  };
  
  if (isLoading) return <TodoSkeleton />;
  if (error) return <ErrorMessage error={error} onRetry={refetch} />;
  
  return (
    <div>
      <CreateTodoForm onSubmit={handleCreate} isLoading={createTodo.isLoading} />
      <div className="todo-list">
        {todos?.map(todo => (
          <TodoItem
            key={todo.id}
            todo={todo}
            onToggle={handleToggle}
            isUpdating={updateTodo.isLoading}
          />
        ))}
      </div>
    </div>
  );
}
```

</TabItem>
</Tabs>

## 3. Vue.jsç”Ÿæ€ç³»ç»Ÿä¸ç»„åˆå¼API

### 3.1 Vue 3ç»„åˆå¼APIæ·±åº¦å®è·µ

Vue 3çš„ç»„åˆå¼APIä¸ºå¼€å‘è€…æä¾›äº†æ›´çµæ´»çš„é€»è¾‘å¤ç”¨å’Œæ›´å¥½çš„TypeScriptæ”¯æŒï¼Œæ˜¯ç°ä»£Vueå¼€å‘çš„æ ¸å¿ƒã€‚

<Tabs>
<TabItem value="composition-api" label="ç»„åˆå¼API">

#### ç»„åˆå¼APIæœ€ä½³å®è·µ

```vue title="Vue 3ç»„åˆå¼APIå®Œæ•´ç¤ºä¾‹"
<template>
  <div class="user-dashboard">
    <!-- ç”¨æˆ·ä¿¡æ¯å¡ç‰‡ -->
    <UserCard 
      :user="user" 
      :loading="userLoading"
      @update="handleUserUpdate"
    />
    
    <!-- æœç´¢å’Œè¿‡æ»¤ -->
    <div class="search-section">
      <input
        v-model="searchQuery"
        placeholder="æœç´¢ç”¨æˆ·..."
        class="search-input"
      />
      <select v-model="selectedRole" class="role-filter">
        <option value="">æ‰€æœ‰è§’è‰²</option>
        <option value="admin">ç®¡ç†å‘˜</option>
        <option value="user">æ™®é€šç”¨æˆ·</option>
      </select>
    </div>
    
    <!-- ç”¨æˆ·åˆ—è¡¨ -->
    <div class="user-list">
      <UserListItem
        v-for="user in filteredUsers"
        :key="user.id"
        :user="user"
        @edit="handleEditUser"
        @delete="handleDeleteUser"
      />
    </div>
    
    <!-- åˆ†é¡µ -->
    <Pagination
      :current="currentPage"
      :total="totalUsers"
      :page-size="pageSize"
      @change="handlePageChange"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, nextTick } from 'vue';
import { useRouter, useRoute } from 'vue-router';
import { storeToRefs } from 'pinia';
import { useUserStore } from '@/stores/user';
import { useNotification } from '@/composables/useNotification';
import { useDebounce } from '@/composables/useDebounce';
import type { User, UserRole } from '@/types/user';

// Propså’ŒEmitså®šä¹‰
interface Props {
  initialUserId?: string;
}

const props = withDefaults(defineProps<Props>(), {
  initialUserId: '',
});

const emit = defineEmits<{
  userSelected: [user: User];
  usersLoaded: [count: number];
}>();

// è·¯ç”±å’ŒçŠ¶æ€ç®¡ç†
const router = useRouter();
const route = useRoute();
const userStore = useUserStore();
const { user, users, loading: userLoading } = storeToRefs(userStore);
const { showSuccess, showError } = useNotification();

// å“åº”å¼æ•°æ®
const searchQuery = ref('');
const selectedRole = ref<UserRole | ''>('');
const currentPage = ref(1);
const pageSize = ref(10);
const totalUsers = ref(0);

// é˜²æŠ–æœç´¢
const debouncedSearchQuery = useDebounce(searchQuery, 300);

// è®¡ç®—å±æ€§
const filteredUsers = computed(() => {
  let result = users.value;
  
  // æœç´¢è¿‡æ»¤
  if (debouncedSearchQuery.value) {
    const query = debouncedSearchQuery.value.toLowerCase();
    result = result.filter(user => 
      user.name.toLowerCase().includes(query) ||
      user.email.toLowerCase().includes(query)
    );
  }
  
  // è§’è‰²è¿‡æ»¤
  if (selectedRole.value) {
    result = result.filter(user => user.role === selectedRole.value);
  }
  
  return result;
});

const hasUsers = computed(() => filteredUsers.value.length > 0);
const isFirstPage = computed(() => currentPage.value === 1);
const isLastPage = computed(() => {
  return currentPage.value >= Math.ceil(totalUsers.value / pageSize.value);
});

// æ–¹æ³•å®šä¹‰
const fetchUsers = async (page = 1) => {
  try {
    const result = await userStore.fetchUsers({
      page,
      pageSize: pageSize.value,
      search: debouncedSearchQuery.value,
      role: selectedRole.value || undefined,
    });
    
    totalUsers.value = result.total;
    emit('usersLoaded', result.total);
  } catch (error) {
    showError('è·å–ç”¨æˆ·åˆ—è¡¨å¤±è´¥');
    console.error('Failed to fetch users:', error);
  }
};

const handleUserUpdate = async (updates: Partial<User>) => {
  try {
    await userStore.updateUser(user.value!.id, updates);
    showSuccess('ç”¨æˆ·ä¿¡æ¯æ›´æ–°æˆåŠŸ');
  } catch (error) {
    showError('æ›´æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥');
  }
};

const handleEditUser = (user: User) => {
  emit('userSelected', user);
  router.push(`/users/${user.id}/edit`);
};

const handleDeleteUser = async (user: User) => {
  if (!confirm(`ç¡®å®šè¦åˆ é™¤ç”¨æˆ· ${user.name} å—ï¼Ÿ`)) return;
  
  try {
    await userStore.deleteUser(user.id);
    showSuccess('ç”¨æˆ·åˆ é™¤æˆåŠŸ');
    await fetchUsers(currentPage.value);
  } catch (error) {
    showError('åˆ é™¤ç”¨æˆ·å¤±è´¥');
  }
};

const handlePageChange = (page: number) => {
  currentPage.value = page;
  fetchUsers(page);
};

// ç›‘å¬å™¨
watch([debouncedSearchQuery, selectedRole], () => {
  currentPage.value = 1;
  fetchUsers(1);
});

watch(() => route.query, (newQuery) => {
  if (newQuery.search) {
    searchQuery.value = newQuery.search as string;
  }
  if (newQuery.role) {
    selectedRole.value = newQuery.role as UserRole;
  }
}, { immediate: true });

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  await fetchUsers();
  
  // å¦‚æœæœ‰åˆå§‹ç”¨æˆ·IDï¼Œé€‰ä¸­è¯¥ç”¨æˆ·
  if (props.initialUserId) {
    const initialUser = users.value.find(u => u.id === props.initialUserId);
    if (initialUser) {
      emit('userSelected', initialUser);
    }
  }
});

// æš´éœ²ç»™æ¨¡æ¿çš„æ–¹æ³•å’Œæ•°æ®
defineExpose({
  refreshUsers: () => fetchUsers(currentPage.value),
  resetFilters: () => {
    searchQuery.value = '';
    selectedRole.value = '';
    currentPage.value = 1;
  },
});
</script>

<style scoped>
.user-dashboard {
  padding: 20px;
  max-width: 1200px;
  margin: 0 auto;
}

.search-section {
  display: flex;
  gap: 16px;
  margin-bottom: 24px;
  align-items: center;
}

.search-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
}

.role-filter {
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  min-width: 120px;
}

.user-list {
  display: grid;
  gap: 16px;
  margin-bottom: 24px;
}

@media (max-width: 768px) {
  .search-section {
    flex-direction: column;
    align-items: stretch;
  }
}
</style>
```

</TabItem>
<TabItem value="composables" label="ç»„åˆå¼å‡½æ•°">

#### é«˜è´¨é‡Composablesè®¾è®¡

```typescript title="Vue 3 Composablesæœ€ä½³å®è·µ"
// 1. useApi - é€šç”¨APIè¯·æ±‚Hook
import { ref, unref, type Ref } from 'vue';
import type { MaybeRef } from '@vueuse/core';

interface UseApiOptions<T> {
  immediate?: boolean;
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
  transform?: (data: any) => T;
}

export function useApi<T = any>(
  url: MaybeRef<string>,
  options: UseApiOptions<T> = {}
) {
  const data = ref<T | null>(null);
  const loading = ref(false);
  const error = ref<Error | null>(null);
  
  const execute = async () => {
    try {
      loading.value = true;
      error.value = null;
      
      const response = await fetch(unref(url));
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      let result = await response.json();
      if (options.transform) {
        result = options.transform(result);
      }
      
      data.value = result;
      options.onSuccess?.(result);
      
      return result;
    } catch (err) {
      const errorObj = err instanceof Error ? err : new Error(String(err));
      error.value = errorObj;
      options.onError?.(errorObj);
      throw errorObj;
    } finally {
      loading.value = false;
    }
  };
  
  if (options.immediate !== false) {
    execute();
  }
  
  return {
    data: readonly(data),
    loading: readonly(loading),
    error: readonly(error),
    execute,
    refresh: execute,
  };
}

// 2. useLocalStorage - æœ¬åœ°å­˜å‚¨Hook
import { ref, watch, type Ref } from 'vue';

export function useLocalStorage<T>(
  key: string,
  defaultValue: T,
  options: {
    serializer?: {
      read: (value: string) => T;
      write: (value: T) => string;
    };
  } = {}
): [Ref<T>, (value: T) => void] {
  const serializer = options.serializer || {
    read: (v: string) => {
      try {
        return JSON.parse(v);
      } catch {
        return v as T;
      }
    },
    write: (v: T) => JSON.stringify(v),
  };
  
  const storedValue = ref<T>(defaultValue);
  
  // åˆå§‹åŒ–
  try {
    const item = localStorage.getItem(key);
    if (item !== null) {
      storedValue.value = serializer.read(item);
    }
  } catch (error) {
    console.error(`Error reading localStorage key "${key}":`, error);
  }
  
  // ç›‘å¬å˜åŒ–å¹¶åŒæ­¥åˆ°localStorage
  watch(
    storedValue,
    (newValue) => {
      try {
        localStorage.setItem(key, serializer.write(newValue));
      } catch (error) {
        console.error(`Error setting localStorage key "${key}":`, error);
      }
    },
    { deep: true }
  );
  
  const setValue = (value: T) => {
    storedValue.value = value;
  };
  
  return [storedValue, setValue];
}

// 3. useForm - è¡¨å•å¤„ç†Hook
import { reactive, computed } from 'vue';

interface ValidationRule<T = any> {
  required?: boolean;
  min?: number;
  max?: number;
  pattern?: RegExp;
  validator?: (value: T) => boolean | string;
}

interface FormField<T = any> {
  value: T;
  rules?: ValidationRule<T>[];
  error?: string;
  touched?: boolean;
}

export function useForm<T extends Record<string, any>>(
  initialValues: T,
  validationRules: Partial<Record<keyof T, ValidationRule[]>> = {}
) {
  const form = reactive<Record<keyof T, FormField>>(
    Object.keys(initialValues).reduce((acc, key) => {
      acc[key as keyof T] = {
        value: initialValues[key],
        rules: validationRules[key as keyof T] || [],
        error: '',
        touched: false,
      };
      return acc;
    }, {} as Record<keyof T, FormField>)
  );
  
  const validateField = (fieldName: keyof T): boolean => {
    const field = form[fieldName];
    const rules = field.rules || [];
    
    for (const rule of rules) {
      if (rule.required && (!field.value || field.value === '')) {
        field.error = 'æ­¤å­—æ®µä¸ºå¿…å¡«é¡¹';
        return false;
      }
      
      if (rule.min && field.value.length < rule.min) {
        field.error = `æœ€å°‘éœ€è¦${rule.min}ä¸ªå­—ç¬¦`;
        return false;
      }
      
      if (rule.max && field.value.length > rule.max) {
        field.error = `æœ€å¤šå…è®¸${rule.max}ä¸ªå­—ç¬¦`;
        return false;
      }
      
      if (rule.pattern && !rule.pattern.test(field.value)) {
        field.error = 'æ ¼å¼ä¸æ­£ç¡®';
        return false;
      }
      
      if (rule.validator) {
        const result = rule.validator(field.value);
        if (result !== true) {
          field.error = typeof result === 'string' ? result : 'éªŒè¯å¤±è´¥';
          return false;
        }
      }
    }
    
    field.error = '';
    return true;
  };
  
  const validateForm = (): boolean => {
    let isValid = true;
    Object.keys(form).forEach(key => {
      const fieldValid = validateField(key as keyof T);
      if (!fieldValid) isValid = false;
    });
    return isValid;
  };
  
  const resetForm = () => {
    Object.keys(form).forEach(key => {
      const field = form[key as keyof T];
      field.value = initialValues[key as keyof T];
      field.error = '';
      field.touched = false;
    });
  };
  
  const setFieldValue = (fieldName: keyof T, value: any) => {
    form[fieldName].value = value;
    form[fieldName].touched = true;
    validateField(fieldName);
  };
  
  const values = computed(() => {
    return Object.keys(form).reduce((acc, key) => {
      acc[key as keyof T] = form[key as keyof T].value;
      return acc;
    }, {} as T);
  });
  
  const errors = computed(() => {
    return Object.keys(form).reduce((acc, key) => {
      const error = form[key as keyof T].error;
      if (error) acc[key as keyof T] = error;
      return acc;
    }, {} as Partial<Record<keyof T, string>>);
  });
  
  const isValid = computed(() => {
    return Object.values(form).every(field => !field.error);
  });
  
  const isDirty = computed(() => {
    return Object.values(form).some(field => field.touched);
  });
  
  return {
    form,
    values,
    errors,
    isValid,
    isDirty,
    validateField,
    validateForm,
    resetForm,
    setFieldValue,
  };
}

// 4. useInfiniteScroll - æ— é™æ»šåŠ¨Hook
import { ref, onMounted, onUnmounted } from 'vue';

export function useInfiniteScroll(
  callback: () => void | Promise<void>,
  options: {
    threshold?: number;
    immediate?: boolean;
  } = {}
) {
  const { threshold = 100, immediate = true } = options;
  const loading = ref(false);
  const isEnd = ref(false);
  
  const handleScroll = async () => {
    if (loading.value || isEnd.value) return;
    
    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
    
    if (scrollTop + clientHeight >= scrollHeight - threshold) {
      loading.value = true;
      try {
        await callback();
      } catch (error) {
        console.error('Infinite scroll callback error:', error);
      } finally {
        loading.value = false;
      }
    }
  };
  
  onMounted(() => {
    if (immediate) {
      window.addEventListener('scroll', handleScroll);
    }
  });
  
  onUnmounted(() => {
    window.removeEventListener('scroll', handleScroll);
  });
  
  const start = () => {
    window.addEventListener('scroll', handleScroll);
  };
  
  const stop = () => {
    window.removeEventListener('scroll', handleScroll);
  };
  
  const setEnd = (end: boolean) => {
    isEnd.value = end;
  };
  
  return {
    loading: readonly(loading),
    isEnd: readonly(isEnd),
    start,
    stop,
    setEnd,
  };
}

// 5. ä½¿ç”¨ç¤ºä¾‹
export default defineComponent({
  setup() {
    // APIè¯·æ±‚
    const { data: users, loading, error, refresh } = useApi<User[]>('/api/users');
    
    // æœ¬åœ°å­˜å‚¨
    const [theme, setTheme] = useLocalStorage('theme', 'light');
    
    // è¡¨å•å¤„ç†
    const { form, values, errors, isValid, setFieldValue, validateForm } = useForm(
      { name: '', email: '', age: 0 },
      {
        name: [{ required: true, min: 2 }],
        email: [{ required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ }],
        age: [{ required: true, validator: (value) => value >= 18 || 'å¹´é¾„å¿…é¡»å¤§äº18å²' }],
      }
    );
    
    // æ— é™æ»šåŠ¨
    const { loading: scrollLoading } = useInfiniteScroll(async () => {
      // åŠ è½½æ›´å¤šæ•°æ®
      await loadMoreUsers();
    });
    
    return {
      users,
      loading,
      error,
      refresh,
      theme,
      setTheme,
      form,
      values,
      errors,
      isValid,
      setFieldValue,
      validateForm,
      scrollLoading,
    };
  },
});
```

</TabItem>
<TabItem value="pinia" label="PiniaçŠ¶æ€ç®¡ç†">

#### Piniaç°ä»£çŠ¶æ€ç®¡ç†

```typescript title="Pinia Storeæœ€ä½³å®è·µ"
// 1. ç”¨æˆ·Storeå®šä¹‰
import { defineStore } from 'pinia';
import { computed, ref } from 'vue';
import type { User, LoginCredentials, UserPreferences } from '@/types/user';
import { authAPI } from '@/services/auth';

export const useUserStore = defineStore('user', () => {
  // State
  const currentUser = ref<User | null>(null);
  const preferences = ref<UserPreferences>({
    theme: 'light',
    language: 'zh-CN',
    notifications: true,
  });
  const loading = ref(false);
  const error = ref<string | null>(null);
  
  // Getters
  const isLoggedIn = computed(() => !!currentUser.value);
  const userName = computed(() => currentUser.value?.name || '');
  const userRole = computed(() => currentUser.value?.role || 'guest');
  const isAdmin = computed(() => userRole.value === 'admin');
  
  // Actions
  const setUser = (user: User) => {
    currentUser.value = user;
    error.value = null;
  };
  
  const updatePreferences = (newPreferences: Partial<UserPreferences>) => {
    preferences.value = { ...preferences.value, ...newPreferences };
  };
  
  const login = async (credentials: LoginCredentials) => {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await authAPI.login(credentials);
      currentUser.value = response.user;
      localStorage.setItem('token', response.token);
      return response;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'ç™»å½•å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const logout = async () => {
    try {
      await authAPI.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      currentUser.value = null;
      localStorage.removeItem('token');
    }
  };
  
  const updateProfile = async (updates: Partial<User>) => {
    if (!currentUser.value) throw new Error('No user logged in');
    
    loading.value = true;
    try {
      const updatedUser = await authAPI.updateProfile(currentUser.value.id, updates);
      currentUser.value = { ...currentUser.value, ...updatedUser };
      return updatedUser;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'æ›´æ–°å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const clearError = () => {
    error.value = null;
  };
  
  // æŒä¹…åŒ–
  const $persist = {
    storage: localStorage,
    paths: ['currentUser', 'preferences'],
  };
  
  return {
    // State
    currentUser,
    preferences,
    loading,
    error,
    
    // Getters
    isLoggedIn,
    userName,
    userRole,
    isAdmin,
    
    // Actions
    setUser,
    updatePreferences,
    login,
    logout,
    updateProfile,
    clearError,
    
    // Persist config
    $persist,
  };
});

// 2. äº§å“Store
export const useProductStore = defineStore('product', () => {
  const products = ref<Product[]>([]);
  const currentProduct = ref<Product | null>(null);
  const loading = ref(false);
  const error = ref<string | null>(null);
  
  // åˆ†é¡µçŠ¶æ€
  const pagination = ref({
    page: 1,
    pageSize: 20,
    total: 0,
  });
  
  // è¿‡æ»¤å’Œæœç´¢
  const filters = ref({
    category: '',
    priceRange: [0, 1000],
    inStock: true,
  });
  
  const searchQuery = ref('');
  
  // Getters
  const filteredProducts = computed(() => {
    let result = products.value;
    
    if (searchQuery.value) {
      const query = searchQuery.value.toLowerCase();
      result = result.filter(product =>
        product.name.toLowerCase().includes(query) ||
        product.description.toLowerCase().includes(query)
      );
    }
    
    if (filters.value.category) {
      result = result.filter(product => product.category === filters.value.category);
    }
    
    if (filters.value.inStock) {
      result = result.filter(product => product.stock > 0);
    }
    
    const [minPrice, maxPrice] = filters.value.priceRange;
    result = result.filter(product => 
      product.price >= minPrice && product.price <= maxPrice
    );
    
    return result;
  });
  
  const productsByCategory = computed(() => {
    return products.value.reduce((acc, product) => {
      if (!acc[product.category]) {
        acc[product.category] = [];
      }
      acc[product.category].push(product);
      return acc;
    }, {} as Record<string, Product[]>);
  });
  
  // Actions
  const fetchProducts = async (params?: {
    page?: number;
    pageSize?: number;
    category?: string;
    search?: string;
  }) => {
    loading.value = true;
    error.value = null;
    
    try {
      const response = await productAPI.getProducts(params);
      products.value = response.data;
      pagination.value = {
        page: response.page,
        pageSize: response.pageSize,
        total: response.total,
      };
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'è·å–äº§å“å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const fetchProductById = async (id: string) => {
    loading.value = true;
    try {
      const product = await productAPI.getProductById(id);
      currentProduct.value = product;
      return product;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'è·å–äº§å“è¯¦æƒ…å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const createProduct = async (productData: CreateProductRequest) => {
    loading.value = true;
    try {
      const newProduct = await productAPI.createProduct(productData);
      products.value.unshift(newProduct);
      return newProduct;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'åˆ›å»ºäº§å“å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const updateProduct = async (id: string, updates: Partial<Product>) => {
    loading.value = true;
    try {
      const updatedProduct = await productAPI.updateProduct(id, updates);
      const index = products.value.findIndex(p => p.id === id);
      if (index !== -1) {
        products.value[index] = updatedProduct;
      }
      if (currentProduct.value?.id === id) {
        currentProduct.value = updatedProduct;
      }
      return updatedProduct;
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'æ›´æ–°äº§å“å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const deleteProduct = async (id: string) => {
    loading.value = true;
    try {
      await productAPI.deleteProduct(id);
      products.value = products.value.filter(p => p.id !== id);
      if (currentProduct.value?.id === id) {
        currentProduct.value = null;
      }
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'åˆ é™¤äº§å“å¤±è´¥';
      throw err;
    } finally {
      loading.value = false;
    }
  };
  
  const setFilters = (newFilters: Partial<typeof filters.value>) => {
    filters.value = { ...filters.value, ...newFilters };
  };
  
  const setSearchQuery = (query: string) => {
    searchQuery.value = query;
  };
  
  const clearFilters = () => {
    filters.value = {
      category: '',
      priceRange: [0, 1000],
      inStock: true,
    };
    searchQuery.value = '';
  };
  
  return {
    // State
    products,
    currentProduct,
    loading,
    error,
    pagination,
    filters,
    searchQuery,
    
    // Getters
    filteredProducts,
    productsByCategory,
    
    // Actions
    fetchProducts,
    fetchProductById,
    createProduct,
    updateProduct,
    deleteProduct,
    setFilters,
    setSearchQuery,
    clearFilters,
  };
});

// 3. Storeç»„åˆä½¿ç”¨
export function useStores() {
  const userStore = useUserStore();
  const productStore = useProductStore();
  
  return {
    userStore,
    productStore,
  };
}

// 4. ç»„ä»¶ä¸­ä½¿ç”¨
export default defineComponent({
  setup() {
    const { userStore, productStore } = useStores();
    const { isLoggedIn, userName } = storeToRefs(userStore);
    const { filteredProducts, loading } = storeToRefs(productStore);
    
    onMounted(() => {
      productStore.fetchProducts();
    });
    
    return {
      isLoggedIn,
      userName,
      filteredProducts,
      loading,
      login: userStore.login,
      logout: userStore.logout,
      setFilters: productStore.setFilters,
    };
  },
});
```

</TabItem>
</Tabs>

## 4. TypeScriptåœ¨å‰ç«¯å¼€å‘ä¸­çš„åº”ç”¨

### 4.1 TypeScripté«˜çº§ç±»å‹ç³»ç»Ÿ

TypeScriptä¸ºå‰ç«¯å¼€å‘æä¾›äº†å¼ºå¤§çš„ç±»å‹å®‰å…¨ä¿éšœï¼Œé€šè¿‡é«˜çº§ç±»å‹ç³»ç»Ÿå¯ä»¥æ„å»ºæ›´å¥å£®çš„åº”ç”¨ã€‚

<Tabs>
<TabItem value="advanced-types" label="é«˜çº§ç±»å‹">

#### é«˜çº§ç±»å‹å®šä¹‰ä¸åº”ç”¨

```typescript title="TypeScripté«˜çº§ç±»å‹å®è·µ"
// 1. å·¥å…·ç±»å‹å’Œæ¡ä»¶ç±»å‹
type NonNullable<T> = T extends null | undefined ? never : T;
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

// 2. æ˜ å°„ç±»å‹
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Required<T> = {
  [P in keyof T]-?: T[P];
};

type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 3. è‡ªå®šä¹‰å·¥å…·ç±»å‹
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P];
};

type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P];
};

// 4. å­—ç¬¦ä¸²æ¨¡æ¿ç±»å‹
type EventName<T extends string> = `on${Capitalize<T>}`;
type CSSProperty = `--${string}`;
type APIEndpoint<T extends string> = `/api/${T}`;

// ä½¿ç”¨ç¤ºä¾‹
type UserEvents = EventName<'click' | 'hover' | 'focus'>; // 'onClick' | 'onHover' | 'onFocus'
type UserAPI = APIEndpoint<'users' | 'posts'>; // '/api/users' | '/api/posts'

// 5. é€’å½’ç±»å‹
type JSONValue = 
  | string 
  | number 
  | boolean 
  | null 
  | JSONValue[] 
  | { [key: string]: JSONValue };

type TreeNode<T> = {
  value: T;
  children?: TreeNode<T>[];
};

// 6. å“ç‰Œç±»å‹ï¼ˆBranded Typesï¼‰
type Brand<T, B> = T & { __brand: B };
type UserId = Brand<string, 'UserId'>;
type Email = Brand<string, 'Email'>;
type URL = Brand<string, 'URL'>;

const createUserId = (id: string): UserId => id as UserId;
const createEmail = (email: string): Email => {
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    throw new Error('Invalid email format');
  }
  return email as Email;
};

// 7. å‡½æ•°é‡è½½ç±»å‹
interface APIClient {
  get<T>(url: string): Promise<T>;
  get<T>(url: string, config: RequestConfig): Promise<T>;
  post<T, D>(url: string, data: D): Promise<T>;
  post<T, D>(url: string, data: D, config: RequestConfig): Promise<T>;
}

// 8. æ³›å‹çº¦æŸ
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

// 9. ç´¢å¼•è®¿é—®ç±»å‹
type Person = {
  name: string;
  age: number;
  address: {
    street: string;
    city: string;
  };
};

type PersonName = Person['name']; // string
type PersonAddress = Person['address']; // { street: string; city: string; }
type PersonAddressCity = Person['address']['city']; // string

// 10. é”®å€¼æ˜ å°„ç±»å‹
type APIResponse<T> = {
  data: T;
  status: number;
  message: string;
};

type UserResponse = APIResponse<User>;
type ProductResponse = APIResponse<Product[]>;

// 11. æ¡ä»¶ç±»å‹çš„å®é™…åº”ç”¨
type ApiFunction<T> = T extends (...args: any[]) => Promise<infer R>
  ? (...args: Parameters<T>) => Promise<ApiResponse<R>>
  : never;

// åŸå§‹å‡½æ•°
declare function fetchUser(id: string): Promise<User>;
declare function fetchProducts(): Promise<Product[]>;

// åŒ…è£…åçš„APIå‡½æ•°ç±»å‹
type WrappedFetchUser = ApiFunction<typeof fetchUser>;
type WrappedFetchProducts = ApiFunction<typeof fetchProducts>;
```

</TabItem>
<TabItem value="react-typescript" label="React + TypeScript">

#### Reactç»„ä»¶ç±»å‹å®šä¹‰æœ€ä½³å®è·µ

```typescript title="React TypeScriptæœ€ä½³å®è·µ"
// 1. ç»„ä»¶Propsç±»å‹å®šä¹‰
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  children: React.ReactNode;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  className?: string;
  'data-testid'?: string;
}

// ä½¿ç”¨React.FCçš„æ›¿ä»£æ–¹æ¡ˆï¼ˆæ¨èï¼‰
const Button = ({ 
  variant = 'primary', 
  size = 'medium', 
  disabled = false,
  loading = false,
  children,
  onClick,
  className,
  ...rest 
}: ButtonProps) => {
  const baseClasses = 'btn';
  const variantClasses = {
    primary: 'btn-primary',
    secondary: 'btn-secondary',
    danger: 'btn-danger',
  };
  const sizeClasses = {
    small: 'btn-sm',
    medium: 'btn-md',
    large: 'btn-lg',
  };
  
  const classes = [
    baseClasses,
    variantClasses[variant],
    sizeClasses[size],
    className,
  ].filter(Boolean).join(' ');
  
  return (
    <button
      className={classes}
      disabled={disabled || loading}
      onClick={onClick}
      {...rest}
    >
      {loading ? <Spinner size="small" /> : children}
    </button>
  );
};

// 2. æ³›å‹ç»„ä»¶
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string | number;
  loading?: boolean;
  emptyMessage?: string;
  className?: string;
}

function List<T>({
  items,
  renderItem,
  keyExtractor,
  loading = false,
  emptyMessage = 'No items found',
  className,
}: ListProps<T>) {
  if (loading) {
    return <div className="loading">Loading...</div>;
  }
  
  if (items.length === 0) {
    return <div className="empty-state">{emptyMessage}</div>;
  }
  
  return (
    <div className={className}>
      {items.map((item, index) => (
        <div key={keyExtractor(item)}>
          {renderItem(item, index)}
        </div>
      ))}
    </div>
  );
}

// ä½¿ç”¨æ³›å‹ç»„ä»¶
const UserList = () => {
  const users: User[] = [/* ... */];
  
  return (
    <List
      items={users}
      keyExtractor={(user) => user.id}
      renderItem={(user) => (
        <div>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      )}
      emptyMessage="No users found"
    />
  );
};

// 3. é«˜é˜¶ç»„ä»¶ç±»å‹
type WithLoadingProps = {
  loading: boolean;
};

function withLoading<P extends object>(
  Component: React.ComponentType<P>
): React.ComponentType<P & WithLoadingProps> {
  return ({ loading, ...props }: P & WithLoadingProps) => {
    if (loading) {
      return <div>Loading...</div>;
    }
    return <Component {...(props as P)} />;
  };
}

// ä½¿ç”¨HOC
const UserProfileWithLoading = withLoading(UserProfile);

// 4. Render Propsç±»å‹
interface DataFetcherProps<T> {
  url: string;
  children: (data: {
    data: T | null;
    loading: boolean;
    error: Error | null;
    refetch: () => void;
  }) => React.ReactNode;
}

function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [url]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return <>{children({ data, loading, error, refetch: fetchData })}</>;
}

// ä½¿ç”¨Render Props
const UserProfile = ({ userId }: { userId: string }) => (
  <DataFetcher<User> url={`/api/users/${userId}`}>
    {({ data: user, loading, error, refetch }) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      if (!user) return <div>User not found</div>;
      
      return (
        <div>
          <h1>{user.name}</h1>
          <p>{user.email}</p>
          <button onClick={refetch}>Refresh</button>
        </div>
      );
    }}
  </DataFetcher>
);

// 5. Contextç±»å‹å®šä¹‰
interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  loading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  
  const login = async (credentials: LoginCredentials) => {
    setLoading(true);
    try {
      const response = await authAPI.login(credentials);
      setUser(response.user);
    } finally {
      setLoading(false);
    }
  };
  
  const logout = () => {
    setUser(null);
    localStorage.removeItem('token');
  };
  
  const value: AuthContextType = {
    user,
    login,
    logout,
    loading,
  };
  
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// 6. è‡ªå®šä¹‰Hookç±»å‹
interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

function useApi<T>(url: string): UseApiResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [url]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { data, loading, error, refetch: fetchData };
}

// 7. äº‹ä»¶å¤„ç†ç±»å‹
interface FormProps {
  onSubmit: (data: FormData) => void;
  onChange: (field: string, value: any) => void;
}

const Form: React.FC<FormProps> = ({ onSubmit, onChange }) => {
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    onSubmit(formData);
  };
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e.target.name, e.target.value);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="username" onChange={handleInputChange} />
      <button type="submit">Submit</button>
    </form>
  );
};

// 8. Refç±»å‹
interface ModalRef {
  open: () => void;
  close: () => void;
}

const Modal = forwardRef<ModalRef, { children: React.ReactNode }>(
  ({ children }, ref) => {
    const [isOpen, setIsOpen] = useState(false);
    
    useImperativeHandle(ref, () => ({
      open: () => setIsOpen(true),
      close: () => setIsOpen(false),
    }));
    
    if (!isOpen) return null;
    
    return (
      <div className="modal">
        <div className="modal-content">
          {children}
          <button onClick={() => setIsOpen(false)}>Close</button>
        </div>
      </div>
    );
  }
);

// ä½¿ç”¨Ref
const App = () => {
  const modalRef = useRef<ModalRef>(null);
  
  return (
    <div>
      <button onClick={() => modalRef.current?.open()}>Open Modal</button>
      <Modal ref={modalRef}>
        <p>Modal content</p>
      </Modal>
    </div>
  );
};
```

</TabItem>
<TabItem value="type-safety" label="ç±»å‹å®‰å…¨å®è·µ">

#### ç±»å‹å®‰å…¨æœ€ä½³å®è·µ

```typescript title="ç±»å‹å®‰å…¨å®è·µæŒ‡å—"
// 1. ä¸¥æ ¼çš„tsconfig.jsoné…ç½®
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  }
}

// 2. ç±»å‹å®ˆå«ï¼ˆType Guardsï¼‰
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'name' in obj &&
    'email' in obj
  );
}

function isApiError(error: unknown): error is ApiError {
  return (
    error instanceof Error &&
    'status' in error &&
    'code' in error
  );
}

// ä½¿ç”¨ç±»å‹å®ˆå«
function handleApiResponse(response: unknown) {
  if (isUser(response)) {
    // TypeScriptçŸ¥é“è¿™é‡Œresponseæ˜¯Userç±»å‹
    console.log(response.name);
  } else if (isApiError(response)) {
    // TypeScriptçŸ¥é“è¿™é‡Œresponseæ˜¯ApiErrorç±»å‹
    console.error(`API Error: ${response.status} - ${response.message}`);
  }
}

// 3. æ–­è¨€å‡½æ•°ï¼ˆAssertion Functionsï¼‰
function assertIsNumber(value: unknown): asserts value is number {
  if (typeof value !== 'number') {
    throw new Error('Expected number');
  }
}

function assertIsUser(obj: unknown): asserts obj is User {
  if (!isUser(obj)) {
    throw new Error('Expected User object');
  }
}

// ä½¿ç”¨æ–­è¨€å‡½æ•°
function processUserData(data: unknown) {
  assertIsUser(data);
  // è¿™é‡ŒTypeScriptçŸ¥é“dataæ˜¯Userç±»å‹
  console.log(data.name);
}

// 4. åˆ¤åˆ«è”åˆç±»å‹ï¼ˆDiscriminated Unionsï¼‰
type LoadingState = {
  status: 'loading';
};

type SuccessState = {
  status: 'success';
  data: any;
};

type ErrorState = {
  status: 'error';
  error: string;
};

type AsyncState = LoadingState | SuccessState | ErrorState;

function handleAsyncState(state: AsyncState) {
  switch (state.status) {
    case 'loading':
      return <div>Loading...</div>;
    case 'success':
      // TypeScriptçŸ¥é“è¿™é‡Œstateæœ‰dataå±æ€§
      return <div>Data: {JSON.stringify(state.data)}</div>;
    case 'error':
      // TypeScriptçŸ¥é“è¿™é‡Œstateæœ‰errorå±æ€§
      return <div>Error: {state.error}</div>;
    default:
      // ç¡®ä¿æ‰€æœ‰æƒ…å†µéƒ½è¢«å¤„ç†
      const _exhaustiveCheck: never = state;
      return _exhaustiveCheck;
  }
}

// 5. æ¨¡æ¿å­—é¢é‡ç±»å‹çš„å®é™…åº”ç”¨
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type ApiEndpoint = `/api/${string}`;
type ApiCall<M extends HttpMethod, E extends ApiEndpoint> = {
  method: M;
  endpoint: E;
  data?: M extends 'GET' | 'DELETE' ? never : any;
};

// ç±»å‹å®‰å…¨çš„APIè°ƒç”¨
const getUserCall: ApiCall<'GET', '/api/users'> = {
  method: 'GET',
  endpoint: '/api/users',
  // data: {} // è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºGETè¯·æ±‚ä¸åº”è¯¥æœ‰data
};

const createUserCall: ApiCall<'POST', '/api/users'> = {
  method: 'POST',
  endpoint: '/api/users',
  data: { name: 'John', email: 'john@example.com' }
};

// 6. é€’å½’ç±»å‹çš„å®é™…åº”ç”¨
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

type Config = {
  database: {
    host: string;
    port: number;
    credentials: {
      username: string;
      password: string;
    };
  };
  api: {
    baseUrl: string;
    timeout: number;
  };
};

type ReadonlyConfig = DeepReadonly<Config>;
// æ‰€æœ‰åµŒå¥—å±æ€§éƒ½å˜ä¸ºreadonly

// 7. æ¡ä»¶ç±»å‹çš„å®é™…åº”ç”¨
type NonNullable<T> = T extends null | undefined ? never : T;
type FunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;

class UserService {
  name = 'UserService';
  version = '1.0.0';
  
  getUser(id: string): Promise<User> {
    return Promise.resolve({} as User);
  }
  
  createUser(data: CreateUserRequest): Promise<User> {
    return Promise.resolve({} as User);
  }
  
  updateUser(id: string, data: Partial<User>): Promise<User> {
    return Promise.resolve({} as User);
  }
}

type UserServiceMethods = FunctionProperties<UserService>;
// åªåŒ…å«æ–¹æ³•çš„ç±»å‹ï¼š{ getUser: ..., createUser: ..., updateUser: ... }

// 8. ç±»å‹å®‰å…¨çš„ç¯å¢ƒå˜é‡
interface EnvironmentVariables {
  NODE_ENV: 'development' | 'production' | 'test';
  API_BASE_URL: string;
  DATABASE_URL: string;
  JWT_SECRET: string;
}

function getEnvVar<K extends keyof EnvironmentVariables>(
  key: K
): EnvironmentVariables[K] {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Environment variable ${key} is not defined`);
  }
  return value as EnvironmentVariables[K];
}

// ç±»å‹å®‰å…¨çš„ä½¿ç”¨
const nodeEnv = getEnvVar('NODE_ENV'); // ç±»å‹ä¸º 'development' | 'production' | 'test'
const apiUrl = getEnvVar('API_BASE_URL'); // ç±»å‹ä¸º string

// 9. ç±»å‹å®‰å…¨çš„äº‹ä»¶ç³»ç»Ÿ
type EventMap = {
  'user:login': { userId: string; timestamp: number };
  'user:logout': { userId: string };
  'order:created': { orderId: string; userId: string; amount: number };
  'order:cancelled': { orderId: string; reason: string };
};

class TypedEventEmitter {
  private listeners: {
    [K in keyof EventMap]?: Array<(data: EventMap[K]) => void>;
  } = {};
  
  on<K extends keyof EventMap>(
    event: K,
    listener: (data: EventMap[K]) => void
  ): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(listener);
  }
  
  emit<K extends keyof EventMap>(event: K, data: EventMap[K]): void {
    const eventListeners = this.listeners[event];
    if (eventListeners) {
      eventListeners.forEach(listener => listener(data));
    }
  }
}

// ç±»å‹å®‰å…¨çš„ä½¿ç”¨
const emitter = new TypedEventEmitter();

emitter.on('user:login', (data) => {
  // dataçš„ç±»å‹è‡ªåŠ¨æ¨æ–­ä¸º { userId: string; timestamp: number }
  console.log(`User ${data.userId} logged in at ${data.timestamp}`);
});

emitter.emit('user:login', {
  userId: '123',
  timestamp: Date.now()
});

// 10. ç±»å‹å®‰å…¨çš„è·¯ç”±ç³»ç»Ÿ
type RouteParams = {
  '/': {};
  '/users': {};
  '/users/:id': { id: string };
  '/users/:id/posts': { id: string };
  '/users/:id/posts/:postId': { id: string; postId: string };
};

function navigate<T extends keyof RouteParams>(
  path: T,
  ...args: RouteParams[T] extends {} 
    ? [RouteParams[T]] extends [{}] 
      ? [] 
      : [RouteParams[T]]
    : [RouteParams[T]]
): void {
  // è·¯ç”±å¯¼èˆªé€»è¾‘
  console.log('Navigating to:', path, args);
}

// ç±»å‹å®‰å…¨çš„ä½¿ç”¨
navigate('/'); // OK
navigate('/users'); // OK
navigate('/users/:id', { id: '123' }); // OK
navigate('/users/:id/posts/:postId', { id: '123', postId: '456' }); // OK
// navigate('/users/:id'); // é”™è¯¯ï¼šç¼ºå°‘å‚æ•°
// navigate('/users/:id', { id: 123 }); // é”™è¯¯ï¼šidåº”è¯¥æ˜¯stringç±»å‹
```

</TabItem>
</Tabs>

## 5. å‰ç«¯æ€§èƒ½ä¼˜åŒ–å…¨æ–¹ä½æŒ‡å—

### 5.1 åŠ è½½æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

å‰ç«¯æ€§èƒ½ä¼˜åŒ–æ˜¯æå‡ç”¨æˆ·ä½“éªŒçš„å…³é”®ï¼Œéœ€è¦ä»å¤šä¸ªç»´åº¦è¿›è¡Œç³»ç»Ÿæ€§ä¼˜åŒ–ã€‚

<Tabs>
<TabItem value="bundle-optimization" label="æ‰“åŒ…ä¼˜åŒ–">

#### ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½

```typescript title="ä»£ç åˆ†å‰²æœ€ä½³å®è·µ"
// 1. è·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

// æ‡’åŠ è½½ç»„ä»¶
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const UserProfile = lazy(() => import('./pages/UserProfile'));

// é¢„åŠ è½½å…³é”®è·¯ç”±
const AdminPanel = lazy(() => 
  import(/* webpackChunkName: "admin" */ './pages/AdminPanel')
);

// æ¡ä»¶åŠ è½½
const AdvancedFeatures = lazy(() => 
  import(/* webpackChunkName: "advanced" */ './components/AdvancedFeatures')
);

function App() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/profile" element={<UserProfile />} />
        <Route path="/admin" element={<AdminPanel />} />
      </Routes>
    </Suspense>
  );
}

// 2. ç»„ä»¶çº§åˆ«çš„æ‡’åŠ è½½
const LazyModal = lazy(() => import('./components/Modal'));
const LazyChart = lazy(() => import('./components/Chart'));

function Dashboard() {
  const [showModal, setShowModal] = useState(false);
  const [showChart, setShowChart] = useState(false);
  
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* æ¡ä»¶æ¸²æŸ“æ‡’åŠ è½½ç»„ä»¶ */}
      {showModal && (
        <Suspense fallback={<div>Loading modal...</div>}>
          <LazyModal onClose={() => setShowModal(false)} />
        </Suspense>
      )}
      
      {showChart && (
        <Suspense fallback={<ChartSkeleton />}>
          <LazyChart data={chartData} />
        </Suspense>
      )}
      
      <button onClick={() => setShowModal(true)}>Open Modal</button>
      <button onClick={() => setShowChart(true)}>Show Chart</button>
    </div>
  );
}

// 3. åŠ¨æ€å¯¼å…¥å·¥å…·å‡½æ•°
async function loadUtility() {
  const { heavyUtilityFunction } = await import('./utils/heavyUtils');
  return heavyUtilityFunction;
}

// 4. é¢„åŠ è½½ç­–ç•¥
function usePreloadRoute(routePath: string) {
  useEffect(() => {
    const timer = setTimeout(() => {
      // åœ¨ç©ºé—²æ—¶é—´é¢„åŠ è½½è·¯ç”±
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => {
          import(/* webpackChunkName: "[request]" */ `./pages/${routePath}`);
        });
      }
    }, 2000);
    
    return () => clearTimeout(timer);
  }, [routePath]);
}

// 5. Webpacké…ç½®ä¼˜åŒ–
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // ç¬¬ä¸‰æ–¹åº“å•ç‹¬æ‰“åŒ…
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: 10,
        },
        // å…¬å…±ç»„ä»¶
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          priority: 5,
          reuseExistingChunk: true,
        },
        // Reactç›¸å…³åº“
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          chunks: 'all',
          priority: 20,
        },
      },
    },
    // è¿è¡Œæ—¶ä»£ç å•ç‹¬æå–
    runtimeChunk: {
      name: 'runtime',
    },
  },
};

// 6. Viteé…ç½®ä¼˜åŒ–
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // ç¬¬ä¸‰æ–¹åº“åˆ†åŒ…
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
          ui: ['antd', '@ant-design/icons'],
          utils: ['lodash', 'dayjs'],
        },
      },
    },
    // å¯ç”¨å‹ç¼©
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      },
    },
  },
});
```

</TabItem>
<TabItem value="resource-optimization" label="èµ„æºä¼˜åŒ–">

#### é™æ€èµ„æºä¼˜åŒ–ç­–ç•¥

```typescript title="èµ„æºä¼˜åŒ–å®è·µ"
// 1. å›¾ç‰‡ä¼˜åŒ–ç»„ä»¶
import { useState, useRef, useEffect } from 'react';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  loading?: 'lazy' | 'eager';
  placeholder?: string;
  className?: string;
}

const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  width,
  height,
  loading = 'lazy',
  placeholder,
  className,
}) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  
  // ç”Ÿæˆä¸åŒå°ºå¯¸çš„å›¾ç‰‡URL
  const generateSrcSet = (baseSrc: string) => {
    const sizes = [320, 640, 960, 1280, 1920];
    return sizes
      .map(size => `${baseSrc}?w=${size} ${size}w`)
      .join(', ');
  };
  
  // WebPæ”¯æŒæ£€æµ‹
  const supportsWebP = () => {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  };
  
  // è·å–ä¼˜åŒ–åçš„å›¾ç‰‡URL
  const getOptimizedSrc = (originalSrc: string) => {
    if (supportsWebP()) {
      return originalSrc.replace(/\.(jpg|jpeg|png)$/i, '.webp');
    }
    return originalSrc;
  };
  
  useEffect(() => {
    if (!imgRef.current) return;
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            img.src = getOptimizedSrc(src);
            observer.unobserve(img);
          }
        });
      },
      { threshold: 0.1 }
    );
    
    if (loading === 'lazy') {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src, loading]);
  
  return (
    <div className={`image-container ${className || ''}`}>
      {!isLoaded && placeholder && (
        <div className="image-placeholder">
          <img src={placeholder} alt="" />
        </div>
      )}
      
      <img
        ref={imgRef}
        alt={alt}
        width={width}
        height={height}
        loading={loading}
        srcSet={loading === 'eager' ? generateSrcSet(src) : undefined}
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        onLoad={() => setIsLoaded(true)}
        onError={() => setError(true)}
        style={{
          opacity: isLoaded ? 1 : 0,
          transition: 'opacity 0.3s ease',
        }}
      />
      
      {error && (
        <div className="image-error">
          Failed to load image
        </div>
      )}
    </div>
  );
};

// 2. å­—ä½“ä¼˜åŒ–
// CSSä¸­çš„å­—ä½“ä¼˜åŒ–
const fontOptimizationCSS = `
/* å­—ä½“é¢„åŠ è½½ */
@font-face {
  font-family: 'CustomFont';
  src: url('/fonts/custom-font.woff2') format('woff2'),
       url('/fonts/custom-font.woff') format('woff');
  font-display: swap; /* é‡è¦ï¼šé¿å…å­—ä½“åŠ è½½é˜»å¡ */
  font-weight: 400;
  font-style: normal;
}

/* å­—ä½“å­é›†åŒ– */
@font-face {
  font-family: 'CustomFont';
  src: url('/fonts/custom-font-latin.woff2') format('woff2');
  font-display: swap;
  unicode-range: U+0000-00FF, U+0131, U+0152-0153;
}

/* ç³»ç»Ÿå­—ä½“æ ˆ */
body {
  font-family: 
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    'Roboto',
    'Oxygen',
    'Ubuntu',
    'Cantarell',
    'Fira Sans',
    'Droid Sans',
    'Helvetica Neue',
    sans-serif;
}
`;

// 3. CSSä¼˜åŒ–
const cssOptimization = `
/* å…³é”®CSSå†…è” */
<style>
  /* é¦–å±å…³é”®æ ·å¼ */
  .header { /* ... */ }
  .hero { /* ... */ }
  .navigation { /* ... */ }
</style>

/* éå…³é”®CSSå»¶è¿ŸåŠ è½½ */
<link rel="preload" href="/css/non-critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/css/non-critical.css"></noscript>
`;

// 4. JavaScriptä¼˜åŒ–
// ä½¿ç”¨Web Workerså¤„ç†é‡è®¡ç®—
class PerformanceWorker {
  private worker: Worker | null = null;
  
  constructor() {
    if (typeof Worker !== 'undefined') {
      this.worker = new Worker('/workers/performance-worker.js');
    }
  }
  
  async processLargeDataset(data: any[]): Promise<any> {
    if (!this.worker) {
      // Fallback to main thread
      return this.processInMainThread(data);
    }
    
    return new Promise((resolve, reject) => {
      this.worker!.postMessage({ type: 'PROCESS_DATA', data });
      
      this.worker!.onmessage = (event) => {
        if (event.data.type === 'PROCESS_COMPLETE') {
          resolve(event.data.result);
        } else if (event.data.type === 'PROCESS_ERROR') {
          reject(new Error(event.data.error));
        }
      };
    });
  }
  
  private processInMainThread(data: any[]): any {
    // ä¸»çº¿ç¨‹å¤„ç†é€»è¾‘
    return data.map(item => ({ ...item, processed: true }));
  }
  
  destroy() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
  }
}

// 5. Service Workerç¼“å­˜ç­–ç•¥
// service-worker.js
const CACHE_NAME = 'app-cache-v1';
const STATIC_ASSETS = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js',
  '/manifest.json',
];

// å®‰è£…äº‹ä»¶ - ç¼“å­˜é™æ€èµ„æº
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(STATIC_ASSETS))
  );
});

// ç½‘ç»œè¯·æ±‚æ‹¦æˆª - ç¼“å­˜ç­–ç•¥
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // APIè¯·æ±‚ - ç½‘ç»œä¼˜å…ˆç­–ç•¥
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          const responseClone = response.clone();
          caches.open(CACHE_NAME)
            .then((cache) => cache.put(request, responseClone));
          return response;
        })
        .catch(() => caches.match(request))
    );
    return;
  }
  
  // é™æ€èµ„æº - ç¼“å­˜ä¼˜å…ˆç­–ç•¥
  event.respondWith(
    caches.match(request)
      .then((response) => {
        if (response) {
          return response;
        }
        return fetch(request);
      })
  );
});
```

</TabItem>
<TabItem value="runtime-optimization" label="è¿è¡Œæ—¶ä¼˜åŒ–">

#### è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–

```typescript title="è¿è¡Œæ—¶æ€§èƒ½ä¼˜åŒ–ç­–ç•¥"
// 1. è™šæ‹Ÿæ»šåŠ¨å®ç°
import { useState, useEffect, useMemo, useCallback } from 'react';

interface VirtualScrollProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  overscan?: number;
}

function VirtualScroll<T>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5,
}: VirtualScrollProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  
  // è®¡ç®—å¯è§èŒƒå›´
  const visibleRange = useMemo(() => {
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(
      start + Math.ceil(containerHeight / itemHeight) + overscan,
      items.length
    );
    
    return {
      start: Math.max(0, start - overscan),
      end,
    };
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);
  
  // å¯è§é¡¹ç›®
  const visibleItems = useMemo(() => {
    return items.slice(visibleRange.start, visibleRange.end);
  }, [items, visibleRange]);
  
  // æ»šåŠ¨å¤„ç†
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);
  
  // æ€»é«˜åº¦
  const totalHeight = items.length * itemHeight;
  
  // åç§»é‡
  const offsetY = visibleRange.start * itemHeight;
  
  return (
    <div
      style={{
        height: containerHeight,
        overflow: 'auto',
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={visibleRange.start + index}
              style={{ height: itemHeight }}
            >
              {renderItem(item, visibleRange.start + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// 2. é˜²æŠ–å’ŒèŠ‚æµHook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

function useThrottle<T>(value: T, limit: number): T {
  const [throttledValue, setThrottledValue] = useState<T>(value);
  const lastRan = useRef(Date.now());
  
  useEffect(() => {
    const handler = setTimeout(() => {
      if (Date.now() - lastRan.current >= limit) {
        setThrottledValue(value);
        lastRan.current = Date.now();
      }
    }, limit - (Date.now() - lastRan.current));
    
    return () => clearTimeout(handler);
  }, [value, limit]);
  
  return throttledValue;
}

// 3. å†…å­˜æ³„æ¼é˜²æŠ¤
function useEventListener<T extends keyof WindowEventMap>(
  eventName: T,
  handler: (event: WindowEventMap[T]) => void,
  element: Window | HTMLElement = window
) {
  const savedHandler = useRef(handler);
  
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  
  useEffect(() => {
    const eventListener = (event: Event) => {
      savedHandler.current(event as WindowEventMap[T]);
    };
    
    element.addEventListener(eventName, eventListener);
    
    return () => {
      element.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// 4. æ€§èƒ½ç›‘æ§Hook
function usePerformanceMonitor() {
  const [metrics, setMetrics] = useState({
    renderTime: 0,
    memoryUsage: 0,
    fps: 0,
  });
  
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();
    let animationId: number;
    
    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime >= lastTime + 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        
        setMetrics(prev => ({
          ...prev,
          fps,
          memoryUsage: (performance as any).memory?.usedJSHeapSize || 0,
        }));
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      animationId = requestAnimationFrame(measureFPS);
    };
    
    animationId = requestAnimationFrame(measureFPS);
    
    return () => cancelAnimationFrame(animationId);
  }, []);
  
  const measureRenderTime = useCallback((componentName: string) => {
    const startTime = performance.now();
    
    return () => {
      const endTime = performance.now();
      const renderTime = endTime - startTime;
      
      console.log(`${componentName} render time: ${renderTime.toFixed(2)}ms`);
      
      setMetrics(prev => ({
        ...prev,
        renderTime,
      }));
    };
  }, []);
  
  return { metrics, measureRenderTime };
}

// 5. ç»„ä»¶æ€§èƒ½åˆ†æ
const withPerformanceTracking = <P extends object>(
  WrappedComponent: React.ComponentType<P>,
  componentName: string
) => {
  return React.memo((props: P) => {
    const { measureRenderTime } = usePerformanceMonitor();
    
    useEffect(() => {
      const endMeasure = measureRenderTime(componentName);
      return endMeasure;
    });
    
    return <WrappedComponent {...props} />;
  });
};

// 6. é•¿åˆ—è¡¨ä¼˜åŒ–
interface OptimizedListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  getItemKey: (item: T, index: number) => string | number;
  estimatedItemHeight?: number;
  threshold?: number;
}

function OptimizedList<T>({
  items,
  renderItem,
  getItemKey,
  estimatedItemHeight = 50,
  threshold = 100,
}: OptimizedListProps<T>) {
  const [visibleItems, setVisibleItems] = useState<T[]>([]);
  const [hasMore, setHasMore] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // æ— é™æ»šåŠ¨
  const { loading } = useInfiniteScroll(
    async () => {
      const startIndex = visibleItems.length;
      const endIndex = Math.min(startIndex + threshold, items.length);
      
      if (startIndex >= items.length) {
        setHasMore(false);
        return;
      }
      
      const newItems = items.slice(startIndex, endIndex);
      setVisibleItems(prev => [...prev, ...newItems]);
    },
    { threshold: 200 }
  );
  
  // åˆå§‹åŒ–
  useEffect(() => {
    const initialItems = items.slice(0, threshold);
    setVisibleItems(initialItems);
    setHasMore(items.length > threshold);
  }, [items, threshold]);
  
  return (
    <div ref={containerRef} className="optimized-list">
      {visibleItems.map((item, index) => (
        <div key={getItemKey(item, index)} className="list-item">
          {renderItem(item, index)}
        </div>
      ))}
      
      {loading && <div className="loading">Loading more...</div>}
      {!hasMore && <div className="end">No more items</div>}
    </div>
  );
}

// 7. ä½¿ç”¨ç¤ºä¾‹
function App() {
  const [searchQuery, setSearchQuery] = useState('');
  const debouncedQuery = useDebounce(searchQuery, 300);
  const { metrics } = usePerformanceMonitor();
  
  const largeDataset = useMemo(() => 
    Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      name: `Item ${i}`,
      value: Math.random() * 100,
    }))
  , []);
  
  const filteredData = useMemo(() => 
    largeDataset.filter(item => 
      item.name.toLowerCase().includes(debouncedQuery.toLowerCase())
    )
  , [largeDataset, debouncedQuery]);
  
  return (
    <div>
      <div className="performance-metrics">
        <span>FPS: {metrics.fps}</span>
        <span>Memory: {(metrics.memoryUsage / 1024 / 1024).toFixed(2)}MB</span>
      </div>
      
      <input
        type="text"
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        placeholder="Search items..."
      />
      
      <VirtualScroll
        items={filteredData}
        itemHeight={60}
        containerHeight={400}
        renderItem={(item) => (
          <div className="item">
            <h3>{item.name}</h3>
            <p>Value: {item.value.toFixed(2)}</p>
          </div>
        )}
      />
    </div>
  );
}
```

</TabItem>
</Tabs>

## 6. ç°ä»£CSSä¸æ ·å¼è§£å†³æ–¹æ¡ˆ

### 6.1 CSS-in-JSä¸åŸå­åŒ–CSS

ç°ä»£å‰ç«¯å¼€å‘ä¸­ï¼ŒCSSçš„ç»„ç»‡å’Œç®¡ç†æ–¹å¼å‘ç”Ÿäº†é‡å¤§å˜é©ï¼Œä»ä¼ ç»Ÿçš„CSSæ–‡ä»¶åˆ°CSS-in-JSï¼Œå†åˆ°åŸå­åŒ–CSSã€‚

<Tabs>
<TabItem value="css-in-js" label="CSS-in-JS">

#### Styled Componentsä¸Emotion

```typescript title="CSS-in-JSæœ€ä½³å®è·µ"
// 1. Styled ComponentsåŸºç¡€ç”¨æ³•
import styled, { css, ThemeProvider, createGlobalStyle } from 'styled-components';

// ä¸»é¢˜å®šä¹‰
const theme = {
  colors: {
    primary: '#007bff',
    secondary: '#6c757d',
    success: '#28a745',
    danger: '#dc3545',
    warning: '#ffc107',
    info: '#17a2b8',
    light: '#f8f9fa',
    dark: '#343a40',
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '3rem',
  },
  breakpoints: {
    mobile: '576px',
    tablet: '768px',
    desktop: '992px',
    wide: '1200px',
  },
  shadows: {
    sm: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
    md: '0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)',
    lg: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)',
  },
};

// å…¨å±€æ ·å¼
const GlobalStyle = createGlobalStyle`
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    line-height: 1.6;
    color: ${props => props.theme.colors.dark};
    background-color: ${props => props.theme.colors.light};
  }
  
  a {
    color: ${props => props.theme.colors.primary};
    text-decoration: none;
    
    &:hover {
      text-decoration: underline;
    }
  }
`;

// 2. åŸºç¡€ç»„ä»¶æ ·å¼
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  disabled?: boolean;
}

const Button = styled.button<ButtonProps>`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: none;
  border-radius: 4px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  
  /* å°ºå¯¸å˜ä½“ */
  ${props => {
    switch (props.size) {
      case 'small':
        return css`
          padding: ${props.theme.spacing.xs} ${props.theme.spacing.sm};
          font-size: 0.875rem;
        `;
      case 'large':
        return css`
          padding: ${props.theme.spacing.md} ${props.theme.spacing.lg};
          font-size: 1.125rem;
        `;
      default:
        return css`
          padding: ${props.theme.spacing.sm} ${props.theme.spacing.md};
          font-size: 1rem;
        `;
    }
  }}
  
  /* é¢œè‰²å˜ä½“ */
  ${props => {
    const color = props.theme.colors[props.variant || 'primary'];
    return css`
      background-color: ${color};
      color: white;
      
      &:hover:not(:disabled) {
        background-color: ${color}dd;
        transform: translateY(-1px);
        box-shadow: ${props.theme.shadows.md};
      }
      
      &:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: ${props.theme.shadows.sm};
      }
    `;
  }}
  
  /* å…¨å®½åº¦ */
  ${props => props.fullWidth && css`
    width: 100%;
  `}
  
  /* ç¦ç”¨çŠ¶æ€ */
  ${props => props.disabled && css`
    opacity: 0.6;
    cursor: not-allowed;
    
    &:hover {
      transform: none;
      box-shadow: none;
    }
  `}
  
  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: ${props => props.theme.breakpoints.mobile}) {
    padding: ${props => props.theme.spacing.sm};
    font-size: 0.875rem;
  }
`;

// 3. å¤æ‚ç»„ä»¶æ ·å¼
const Card = styled.div`
  background: white;
  border-radius: 8px;
  box-shadow: ${props => props.theme.shadows.sm};
  overflow: hidden;
  transition: box-shadow 0.2s ease-in-out;
  
  &:hover {
    box-shadow: ${props => props.theme.shadows.md};
  }
`;

const CardHeader = styled.div`
  padding: ${props => props.theme.spacing.lg};
  border-bottom: 1px solid ${props => props.theme.colors.light};
  
  h3 {
    margin: 0;
    color: ${props => props.theme.colors.dark};
  }
`;

const CardBody = styled.div`
  padding: ${props => props.theme.spacing.lg};
`;

const CardFooter = styled.div`
  padding: ${props => props.theme.spacing.md} ${props => props.theme.spacing.lg};
  background-color: ${props => props.theme.colors.light};
  border-top: 1px solid #dee2e6;
  
  display: flex;
  justify-content: flex-end;
  gap: ${props => props.theme.spacing.sm};
`;

// 4. åŠ¨ç”»å’Œè¿‡æ¸¡
const fadeIn = css`
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
`;

const AnimatedContainer = styled.div`
  ${fadeIn}
  animation: fadeIn 0.3s ease-out;
`;

// 5. å“åº”å¼å·¥å…·
const media = {
  mobile: (styles: TemplateStringsArray | string) => css`
    @media (max-width: ${props => props.theme.breakpoints.mobile}) {
      ${styles}
    }
  `,
  tablet: (styles: TemplateStringsArray | string) => css`
    @media (max-width: ${props => props.theme.breakpoints.tablet}) {
      ${styles}
    }
  `,
  desktop: (styles: TemplateStringsArray | string) => css`
    @media (min-width: ${props => props.theme.breakpoints.desktop}) {
      ${styles}
    }
  `,
};

const ResponsiveGrid = styled.div`
  display: grid;
  gap: ${props => props.theme.spacing.md};
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  
  ${media.mobile`
    grid-template-columns: 1fr;
    gap: ${props => props.theme.spacing.sm};
  `}
`;

// 6. ä½¿ç”¨ç¤ºä¾‹
function App() {
  return (
    <ThemeProvider theme={theme}>
      <GlobalStyle />
      <div>
        <ResponsiveGrid>
          <Card>
            <CardHeader>
              <h3>Card Title</h3>
            </CardHeader>
            <CardBody>
              <p>Card content goes here...</p>
            </CardBody>
            <CardFooter>
              <Button variant="secondary" size="small">
                Cancel
              </Button>
              <Button variant="primary" size="small">
                Save
              </Button>
            </CardFooter>
          </Card>
        </ResponsiveGrid>
      </div>
    </ThemeProvider>
  );
}
```

</TabItem>
<TabItem value="tailwind" label="Tailwind CSS">

#### åŸå­åŒ–CSSæœ€ä½³å®è·µ

```typescript title="Tailwind CSSé«˜çº§åº”ç”¨"
// 1. Tailwindé…ç½®æ–‡ä»¶
// tailwind.config.js
module.exports = {
  content: [
    './src/**/*.{js,jsx,ts,tsx}',
    './public/index.html',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          100: '#dbeafe',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
          900: '#1e3a8a',
        },
        gray: {
          50: '#f9fafb',
          100: '#f3f4f6',
          200: '#e5e7eb',
          300: '#d1d5db',
          400: '#9ca3af',
          500: '#6b7280',
          600: '#4b5563',
          700: '#374151',
          800: '#1f2937',
          900: '#111827',
        },
      },
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
      },
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'slide-up': 'slideUp 0.3s ease-out',
        'bounce-in': 'bounceIn 0.6s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(100%)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        bounceIn: {
          '0%': { transform: 'scale(0.3)', opacity: '0' },
          '50%': { transform: 'scale(1.05)' },
          '70%': { transform: 'scale(0.9)' },
          '100%': { transform: 'scale(1)', opacity: '1' },
        },
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
    require('@tailwindcss/aspect-ratio'),
  ],
};

// 2. ç»„ä»¶ç±»åç»„åˆå·¥å…·
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// 3. å¯å¤ç”¨çš„æ ·å¼å˜ä½“
const buttonVariants = {
  variant: {
    default: 'bg-primary-600 text-white hover:bg-primary-700',
    destructive: 'bg-red-600 text-white hover:bg-red-700',
    outline: 'border border-gray-300 bg-white text-gray-700 hover:bg-gray-50',
    secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200',
    ghost: 'text-gray-700 hover:bg-gray-100',
    link: 'text-primary-600 underline-offset-4 hover:underline',
  },
  size: {
    default: 'h-10 px-4 py-2',
    sm: 'h-9 rounded-md px-3',
    lg: 'h-11 rounded-md px-8',
    icon: 'h-10 w-10',
  },
};

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: keyof typeof buttonVariants.variant;
  size?: keyof typeof buttonVariants.size;
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', ...props }, ref) => {
    return (
      <button
        className={cn(
          'inline-flex items-center justify-center rounded-md text-sm font-medium',
          'ring-offset-white transition-colors focus-visible:outline-none',
          'focus-visible:ring-2 focus-visible:ring-primary-600 focus-visible:ring-offset-2',
          'disabled:pointer-events-none disabled:opacity-50',
          buttonVariants.variant[variant],
          buttonVariants.size[size],
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);

// 4. å¤æ‚å¸ƒå±€ç»„ä»¶
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border border-gray-200 bg-white text-gray-950 shadow-sm',
      className
    )}
    {...props}
  />
));

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));

// 5. å“åº”å¼è®¾è®¡æ¨¡å¼
const ResponsiveGrid = ({ children }: { children: React.ReactNode }) => (
  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
    {children}
  </div>
);

const ResponsiveContainer = ({ children }: { children: React.ReactNode }) => (
  <div className="container mx-auto px-4 sm:px-6 lg:px-8">
    {children}
  </div>
);

// 6. åŠ¨ç”»å’Œäº¤äº’
const AnimatedCard = ({ children }: { children: React.ReactNode }) => (
  <div className="group relative overflow-hidden rounded-lg bg-white shadow-md transition-all duration-300 hover:shadow-xl hover:-translate-y-1">
    <div className="absolute inset-0 bg-gradient-to-r from-primary-600 to-primary-700 opacity-0 transition-opacity duration-300 group-hover:opacity-10" />
    <div className="relative z-10">
      {children}
    </div>
  </div>
);

const LoadingSpinner = () => (
  <div className="inline-block h-4 w-4 animate-spin rounded-full border-2 border-solid border-current border-r-transparent motion-reduce:animate-[spin_1.5s_linear_infinite]" />
);

// 7. è¡¨å•ç»„ä»¶
const Input = React.forwardRef<
  HTMLInputElement,
  React.InputHTMLAttributes<HTMLInputElement>
>(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        'flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2',
        'text-sm ring-offset-white file:border-0 file:bg-transparent file:text-sm file:font-medium',
        'placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2',
        'focus-visible:ring-primary-600 focus-visible:ring-offset-2',
        'disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      ref={ref}
      {...props}
    />
  );
});

const Label = React.forwardRef<
  HTMLLabelElement,
  React.LabelHTMLAttributes<HTMLLabelElement>
>(({ className, ...props }, ref) => (
  <label
    ref={ref}
    className={cn(
      'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70',
      className
    )}
    {...props}
  />
));

// 8. ä½¿ç”¨ç¤ºä¾‹
function Dashboard() {
  return (
    <ResponsiveContainer>
      <div className="space-y-8">
        {/* é¡µé¢æ ‡é¢˜ */}
        <div className="border-b border-gray-200 pb-4">
          <h1 className="text-3xl font-bold tracking-tight text-gray-900">
            Dashboard
          </h1>
          <p className="mt-2 text-gray-600">
            Welcome back! Here's what's happening with your projects.
          </p>
        </div>
        
        {/* ç»Ÿè®¡å¡ç‰‡ */}
        <ResponsiveGrid>
          {[
            { title: 'Total Users', value: '12,345', change: '+12%' },
            { title: 'Revenue', value: '$45,678', change: '+8%' },
            { title: 'Orders', value: '1,234', change: '+23%' },
            { title: 'Conversion', value: '3.2%', change: '-2%' },
          ].map((stat, index) => (
            <AnimatedCard key={index}>
              <Card>
                <CardHeader className="pb-2">
                  <CardTitle className="text-sm font-medium text-gray-600">
                    {stat.title}
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="text-2xl font-bold">{stat.value}</div>
                  <p className={cn(
                    'text-xs',
                    stat.change.startsWith('+') 
                      ? 'text-green-600' 
                      : 'text-red-600'
                  )}>
                    {stat.change} from last month
                  </p>
                </CardContent>
              </Card>
            </AnimatedCard>
          ))}
        </ResponsiveGrid>
        
        {/* æ“ä½œæŒ‰é’® */}
        <div className="flex flex-wrap gap-4">
          <Button>Create New Project</Button>
          <Button variant="outline">Import Data</Button>
          <Button variant="ghost">View Reports</Button>
        </div>
      </div>
    </ResponsiveContainer>
  );
}
```

</TabItem>
<TabItem value="css-modules" label="CSS Modules">

#### CSS Modulesæ¨¡å—åŒ–æ–¹æ¡ˆ

```typescript title="CSS Modulesæœ€ä½³å®è·µ"
// 1. Button.module.css
.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.375rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.primary {
  background-color: #3b82f6;
  color: white;
}

.primary:hover:not(:disabled) {
  background-color: #2563eb;
  transform: translateY(-1px);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.secondary {
  background-color: #6b7280;
  color: white;
}

.outline {
  background-color: transparent;
  color: #374151;
  border: 1px solid #d1d5db;
}

.outline:hover:not(:disabled) {
  background-color: #f9fafb;
}

.small {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.large {
  padding: 0.75rem 1.5rem;
  font-size: 1.125rem;
}

.fullWidth {
  width: 100%;
}

.loading {
  position: relative;
  color: transparent;
}

.loading::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 1rem;
  height: 1rem;
  border: 2px solid currentColor;
  border-radius: 50%;
  border-top-color: transparent;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

// 2. Button.tsx
import React from 'react';
import styles from './Button.module.css';
import { cn } from '@/utils/cn';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  loading?: boolean;
  children: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'medium',
  fullWidth = false,
  loading = false,
  className,
  disabled,
  children,
  ...props
}) => {
  const buttonClasses = cn(
    styles.button,
    styles[variant],
    styles[size],
    {
      [styles.fullWidth]: fullWidth,
      [styles.loading]: loading,
    },
    className
  );

  return (
    <button
      className={buttonClasses}
      disabled={disabled || loading}
      {...props}
    >
      {children}
    </button>
  );
};

// 3. Card.module.css
.card {
  background: white;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
  overflow: hidden;
  transition: box-shadow 0.2s ease-in-out;
}

.card:hover {
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

.header {
  padding: 1.5rem;
  border-bottom: 1px solid #e5e7eb;
}

.title {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
}

.subtitle {
  margin: 0.5rem 0 0 0;
  font-size: 0.875rem;
  color: #6b7280;
}

.body {
  padding: 1.5rem;
}

.footer {
  padding: 1rem 1.5rem;
  background-color: #f9fafb;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
}

.interactive {
  cursor: pointer;
}

.interactive:hover {
  transform: translateY(-2px);
}

// 4. Card.tsx
import React from 'react';
import styles from './Card.module.css';
import { cn } from '@/utils/cn';

interface CardProps {
  children: React.ReactNode;
  interactive?: boolean;
  className?: string;
  onClick?: () => void;
}

interface CardHeaderProps {
  title: string;
  subtitle?: string;
  className?: string;
}

interface CardBodyProps {
  children: React.ReactNode;
  className?: string;
}

interface CardFooterProps {
  children: React.ReactNode;
  className?: string;
}

export const Card: React.FC<CardProps> = ({
  children,
  interactive = false,
  className,
  onClick,
}) => {
  return (
    <div
      className={cn(
        styles.card,
        {
          [styles.interactive]: interactive,
        },
        className
      )}
      onClick={onClick}
    >
      {children}
    </div>
  );
};

export const CardHeader: React.FC<CardHeaderProps> = ({
  title,
  subtitle,
  className,
}) => {
  return (
    <div className={cn(styles.header, className)}>
      <h3 className={styles.title}>{title}</h3>
      {subtitle && <p className={styles.subtitle}>{subtitle}</p>}
    </div>
  );
};

export const CardBody: React.FC<CardBodyProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn(styles.body, className)}>
      {children}
    </div>
  );
};

export const CardFooter: React.FC<CardFooterProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn(styles.footer, className)}>
      {children}
    </div>
  );
};

// 5. Layout.module.css
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}

.grid {
  display: grid;
  gap: 1rem;
}

.gridCols1 {
  grid-template-columns: 1fr;
}

.gridCols2 {
  grid-template-columns: repeat(2, 1fr);
}

.gridCols3 {
  grid-template-columns: repeat(3, 1fr);
}

.gridCols4 {
  grid-template-columns: repeat(4, 1fr);
}

.gridAutoFit {
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}

@media (max-width: 768px) {
  .container {
    padding: 0 0.5rem;
  }
  
  .gridCols2,
  .gridCols3,
  .gridCols4 {
    grid-template-columns: 1fr;
  }
  
  .gridAutoFit {
    grid-template-columns: 1fr;
  }
}

// 6. Layout.tsx
import React from 'react';
import styles from './Layout.module.css';
import { cn } from '@/utils/cn';

interface ContainerProps {
  children: React.ReactNode;
  className?: string;
}

interface GridProps {
  children: React.ReactNode;
  cols?: 1 | 2 | 3 | 4 | 'auto-fit';
  className?: string;
}

export const Container: React.FC<ContainerProps> = ({
  children,
  className,
}) => {
  return (
    <div className={cn(styles.container, className)}>
      {children}
    </div>
  );
};

export const Grid: React.FC<GridProps> = ({
  children,
  cols = 'auto-fit',
  className,
}) => {
  const gridClass = cols === 'auto-fit' 
    ? styles.gridAutoFit 
    : styles[`gridCols${cols}` as keyof typeof styles];

  return (
    <div className={cn(styles.grid, gridClass, className)}>
      {children}
    </div>
  );
};

// 7. ä½¿ç”¨ç¤ºä¾‹
import React from 'react';
import { Container, Grid } from './components/Layout';
import { Card, CardHeader, CardBody, CardFooter } from './components/Card';
import { Button } from './components/Button';

function App() {
  const products = [
    { id: 1, name: 'Product 1', price: '$99' },
    { id: 2, name: 'Product 2', price: '$149' },
    { id: 3, name: 'Product 3', price: '$199' },
  ];

  return (
    <Container>
      <h1>Product Catalog</h1>
      
      <Grid cols={3}>
        {products.map((product) => (
          <Card key={product.id} interactive>
            <CardHeader 
              title={product.name}
              subtitle={`Starting at ${product.price}`}
            />
            <CardBody>
              <p>Product description goes here...</p>
            </CardBody>
            <CardFooter>
              <Button variant="outline" size="small">
                Learn More
              </Button>
              <Button size="small">
                Add to Cart
              </Button>
            </CardFooter>
          </Card>
        ))}
      </Grid>
    </Container>
  );
}

export default App;
```

</TabItem>
</Tabs>