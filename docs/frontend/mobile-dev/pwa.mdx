---
sidebar_position: 3
title: æ¸è¿›å¼Webåº”ç”¨(PWA)è¯¦è§£
description: æ·±å…¥è§£æPWAæŠ€æœ¯ã€Service Workersã€ç¦»çº¿åŠŸèƒ½ä¸æ¨é€é€šçŸ¥å®ç°
authors: [Laby]
tags: [PWA, Service Workers, ç¦»çº¿åº”ç”¨, æ¨é€é€šçŸ¥, Webåº”ç”¨, ç§»åŠ¨å¼€å‘]
last_update:
  date: 2025-08-14
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# æ¸è¿›å¼Webåº”ç”¨(PWA)è¯¦è§£

æ¸è¿›å¼Webåº”ç”¨(Progressive Web App)æ˜¯ä¸€ç§ä½¿ç”¨ç°ä»£WebæŠ€æœ¯æ„å»ºçš„åº”ç”¨ç¨‹åºï¼Œæä¾›ç±»ä¼¼åŸç”Ÿåº”ç”¨çš„ç”¨æˆ·ä½“éªŒã€‚PWAç»“åˆäº†Webå’ŒåŸç”Ÿåº”ç”¨çš„æœ€ä½³ç‰¹æ€§ï¼Œå¯ä»¥åœ¨ä»»ä½•è®¾å¤‡ä¸Šè¿è¡Œï¼Œå¹¶æä¾›ç¦»çº¿åŠŸèƒ½ã€æ¨é€é€šçŸ¥å’Œå®‰è£…ä½“éªŒã€‚

:::tip æ ¸å¿ƒä»·å€¼
**PWA = WebæŠ€æœ¯ + åŸç”Ÿä½“éªŒ + æ¸è¿›å¢å¼º + è·¨å¹³å°**
- ğŸŒ **WebæŠ€æœ¯åŸºç¡€**ï¼šä½¿ç”¨HTMLã€CSSã€JavaScriptæ„å»º
- ğŸ“± **åŸç”Ÿåº”ç”¨ä½“éªŒ**ï¼šå…¨å±æ˜¾ç¤ºã€å¯åŠ¨ç”»é¢ã€åº”ç”¨å›¾æ ‡
- ğŸ”„ **ç¦»çº¿åŠŸèƒ½**ï¼šService Workerså®ç°ç¦»çº¿ç¼“å­˜å’ŒåŒæ­¥
- ğŸ”” **æ¨é€é€šçŸ¥**ï¼šå®æ—¶æ¶ˆæ¯æ¨é€ï¼Œæå‡ç”¨æˆ·å‚ä¸åº¦
- ğŸ“¦ **å¯å®‰è£…æ€§**ï¼šå¯æ·»åŠ åˆ°ä¸»å±å¹•ï¼Œæ— éœ€åº”ç”¨å•†åº—
- âš¡ **æ¸è¿›å¢å¼º**ï¼šåœ¨æ”¯æŒçš„æµè§ˆå™¨ä¸Šæä¾›æ›´å¥½çš„ä½“éªŒ
:::

## 1. PWAæ ¸å¿ƒæ¦‚å¿µ

### 1.1 PWAç‰¹æ€§æ¦‚è§ˆ

PWAå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒç‰¹æ€§ï¼Œä½¿å…¶èƒ½å¤Ÿæä¾›æ¥è¿‘åŸç”Ÿåº”ç”¨çš„ä½“éªŒï¼š

```mermaid
graph TB
    subgraph "PWAæ ¸å¿ƒç‰¹æ€§"
        A[æ¸è¿›å¼] --> A1[åŸºç¡€åŠŸèƒ½åœ¨æ‰€æœ‰æµè§ˆå™¨å·¥ä½œ]
        A --> A2[é«˜çº§åŠŸèƒ½åœ¨ç°ä»£æµè§ˆå™¨å¢å¼º]
        
        B[å“åº”å¼] --> B1[é€‚é…å„ç§å±å¹•å°ºå¯¸]
        B --> B2[æ”¯æŒä¸åŒè®¾å¤‡ç±»å‹]
        
        C[ç¦»çº¿ä¼˜å…ˆ] --> C1[Service Workersç¼“å­˜]
        C --> C2[ç¦»çº¿æ•°æ®åŒæ­¥]
        
        D[ç±»åº”ç”¨ä½“éªŒ] --> D1[å…¨å±æ˜¾ç¤º]
        D --> D2[å¯åŠ¨ç”»é¢]
        D --> D3[åº”ç”¨å›¾æ ‡]
        
        E[å®‰å…¨] --> E1[HTTPSå¿…éœ€]
        E --> E2[å®‰å…¨ä¸Šä¸‹æ–‡]
        
        F[å¯å‘ç°] --> F1[æœç´¢å¼•æ“å¯ç´¢å¼•]
        F --> F2[Webåº”ç”¨æ¸…å•]
        
        G[å¯å®‰è£…] --> G1[æ·»åŠ åˆ°ä¸»å±å¹•]
        G --> G2[ç‹¬ç«‹çª—å£è¿è¡Œ]
        
        H[å¯é“¾æ¥] --> H1[URLå¯åˆ†äº«]
        H --> H2[æ·±åº¦é“¾æ¥æ”¯æŒ]
    end
```

### 1.2 PWAæŠ€æœ¯æ ˆ

| æŠ€æœ¯ç»„ä»¶ | ä½œç”¨ | å¿…éœ€æ€§ | æµè§ˆå™¨æ”¯æŒ |
|---------|------|--------|------------|
| **Webåº”ç”¨æ¸…å•** | å®šä¹‰åº”ç”¨å…ƒæ•°æ®å’Œå®‰è£…è¡Œä¸º | å¿…éœ€ | å¹¿æ³›æ”¯æŒ |
| **Service Workers** | ç¦»çº¿ç¼“å­˜ã€åå°åŒæ­¥ã€æ¨é€é€šçŸ¥ | å¿…éœ€ | ç°ä»£æµè§ˆå™¨ |
| **HTTPS** | å®‰å…¨ä¸Šä¸‹æ–‡è¦æ±‚ | å¿…éœ€ | æ‰€æœ‰æµè§ˆå™¨ |
| **å“åº”å¼è®¾è®¡** | é€‚é…ä¸åŒè®¾å¤‡ | æ¨è | æ‰€æœ‰æµè§ˆå™¨ |
| **App Shellæ¶æ„** | å¿«é€ŸåŠ è½½çš„åº”ç”¨å¤–å£³ | æ¨è | æ‰€æœ‰æµè§ˆå™¨ |

## 2. Service Workersè¯¦è§£

### 2.1 Service WorkersåŸºç¡€

Service Workersæ˜¯PWAçš„æ ¸å¿ƒæŠ€æœ¯ï¼Œè¿è¡Œåœ¨åå°çš„JavaScriptè„šæœ¬ï¼Œå……å½“Webåº”ç”¨å’Œç½‘ç»œä¹‹é—´çš„ä»£ç†ã€‚

```mermaid
graph LR
    subgraph "Service Workersæ¶æ„"
        A[Webåº”ç”¨] --> B[Service Worker]
        B --> C[ç¼“å­˜å­˜å‚¨]
        B --> D[ç½‘ç»œè¯·æ±‚]
        B --> E[åå°åŒæ­¥]
        B --> F[æ¨é€é€šçŸ¥]
        
        G[æµè§ˆå™¨] --> B
        H[æœåŠ¡å™¨] --> B
    end
```

<Tabs>
<TabItem value="registration" label="æ³¨å†Œä¸ç”Ÿå‘½å‘¨æœŸ">

#### Service Workeræ³¨å†Œä¸ç”Ÿå‘½å‘¨æœŸ

```javascript title="Service Workeræ³¨å†Œ"
// main.js - ä¸»åº”ç”¨æ–‡ä»¶
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/' // Service Workerçš„ä½œç”¨åŸŸ
      });
      
      console.log('Service Workeræ³¨å†ŒæˆåŠŸ:', registration.scope);
      
      // ç›‘å¬Service WorkerçŠ¶æ€å˜åŒ–
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        console.log('å‘ç°æ–°çš„Service Worker');
        
        newWorker.addEventListener('statechange', () => {
          console.log('Service WorkerçŠ¶æ€:', newWorker.state);
          
          if (newWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // æœ‰æ–°ç‰ˆæœ¬å¯ç”¨
              showUpdateAvailableNotification();
            } else {
              // é¦–æ¬¡å®‰è£…å®Œæˆ
              showCachedNotification();
            }
          }
        });
      });
      
      // ç›‘å¬Service Workeræ§åˆ¶å™¨å˜åŒ–
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        console.log('Service Workeræ§åˆ¶å™¨å·²æ›´æ–°');
        window.location.reload();
      });
      
    } catch (error) {
      console.error('Service Workeræ³¨å†Œå¤±è´¥:', error);
    }
  });
}

// æ˜¾ç¤ºæ›´æ–°å¯ç”¨é€šçŸ¥
function showUpdateAvailableNotification() {
  const notification = document.createElement('div');
  notification.className = 'update-notification';
  notification.innerHTML = `
    <div class="notification-content">
      <p>æ–°ç‰ˆæœ¬å¯ç”¨ï¼</p>
      <button onclick="updateServiceWorker()">æ›´æ–°</button>
      <button onclick="dismissNotification()">ç¨å</button>
    </div>
  `;
  document.body.appendChild(notification);
}

// æ›´æ–°Service Worker
async function updateServiceWorker() {
  const registration = await navigator.serviceWorker.getRegistration();
  if (registration && registration.waiting) {
    // å‘ç­‰å¾…ä¸­çš„Service Workerå‘é€æ¶ˆæ¯
    registration.waiting.postMessage({ type: 'SKIP_WAITING' });
  }
}

// Service Workerç”Ÿå‘½å‘¨æœŸç®¡ç†
class ServiceWorkerManager {
  constructor() {
    this.registration = null;
    this.isUpdateAvailable = false;
  }
  
  async init() {
    if (!('serviceWorker' in navigator)) {
      console.warn('Service Workerä¸è¢«æ”¯æŒ');
      return;
    }
    
    try {
      this.registration = await navigator.serviceWorker.register('/sw.js');
      this.setupEventListeners();
      console.log('Service Workerç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error('Service Workeræ³¨å†Œå¤±è´¥:', error);
    }
  }
  
  setupEventListeners() {
    // ç›‘å¬æ›´æ–°
    this.registration.addEventListener('updatefound', () => {
      const newWorker = this.registration.installing;
      this.trackInstalling(newWorker);
    });
    
    // ç›‘å¬æ¶ˆæ¯
    navigator.serviceWorker.addEventListener('message', (event) => {
      this.handleMessage(event.data);
    });
    
    // ç›‘å¬æ§åˆ¶å™¨å˜åŒ–
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      window.location.reload();
    });
  }
  
  trackInstalling(worker) {
    worker.addEventListener('statechange', () => {
      if (worker.state === 'installed') {
        this.isUpdateAvailable = true;
        this.notifyUpdateAvailable();
      }
    });
  }
  
  notifyUpdateAvailable() {
    // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶
    window.dispatchEvent(new CustomEvent('sw-update-available'));
  }
  
  async skipWaiting() {
    if (this.registration && this.registration.waiting) {
      this.registration.waiting.postMessage({ type: 'SKIP_WAITING' });
    }
  }
  
  handleMessage(data) {
    switch (data.type) {
      case 'SW_UPDATED':
        console.log('Service Workerå·²æ›´æ–°');
        break;
      case 'CACHE_UPDATED':
        console.log('ç¼“å­˜å·²æ›´æ–°');
        break;
    }
  }
}

// ä½¿ç”¨Service Workerç®¡ç†å™¨
const swManager = new ServiceWorkerManager();
swManager.init();

// ç›‘å¬æ›´æ–°äº‹ä»¶
window.addEventListener('sw-update-available', () => {
  showUpdateAvailableNotification();
});
```

</TabItem>
<TabItem value="caching" label="ç¼“å­˜ç­–ç•¥">

#### Service Workerç¼“å­˜ç­–ç•¥

```javascript title="Service Workerç¼“å­˜å®ç°"
// sw.js - Service Workeræ–‡ä»¶
const CACHE_NAME = 'pwa-cache-v1';
const STATIC_CACHE = 'static-cache-v1';
const DYNAMIC_CACHE = 'dynamic-cache-v1';

// éœ€è¦ç¼“å­˜çš„é™æ€èµ„æº
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  '/css/styles.css',
  '/js/app.js',
  '/images/icon-192.png',
  '/images/icon-512.png',
  '/offline.html'
];

// å®‰è£…äº‹ä»¶ - ç¼“å­˜é™æ€èµ„æº
self.addEventListener('install', (event) => {
  console.log('Service Worker: å®‰è£…ä¸­...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('Service Worker: ç¼“å­˜é™æ€èµ„æº');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        console.log('Service Worker: å®‰è£…å®Œæˆ');
        return self.skipWaiting(); // ç«‹å³æ¿€æ´»æ–°çš„Service Worker
      })
  );
});

// æ¿€æ´»äº‹ä»¶ - æ¸…ç†æ—§ç¼“å­˜
self.addEventListener('activate', (event) => {
  console.log('Service Worker: æ¿€æ´»ä¸­...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
              console.log('Service Worker: åˆ é™¤æ—§ç¼“å­˜', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('Service Worker: æ¿€æ´»å®Œæˆ');
        return self.clients.claim(); // ç«‹å³æ§åˆ¶æ‰€æœ‰å®¢æˆ·ç«¯
      })
  );
});

// æ‹¦æˆªç½‘ç»œè¯·æ±‚
self.addEventListener('fetch', (event) => {
  event.respondWith(
    handleFetch(event.request)
  );
});

// è¯·æ±‚å¤„ç†ç­–ç•¥
async function handleFetch(request) {
  const url = new URL(request.url);
  
  // é™æ€èµ„æºï¼šç¼“å­˜ä¼˜å…ˆç­–ç•¥
  if (STATIC_ASSETS.includes(url.pathname)) {
    return cacheFirst(request);
  }
  
  // APIè¯·æ±‚ï¼šç½‘ç»œä¼˜å…ˆç­–ç•¥
  if (url.pathname.startsWith('/api/')) {
    return networkFirst(request);
  }
  
  // å›¾ç‰‡èµ„æºï¼šç¼“å­˜ä¼˜å…ˆç­–ç•¥
  if (request.destination === 'image') {
    return cacheFirst(request);
  }
  
  // HTMLé¡µé¢ï¼šç½‘ç»œä¼˜å…ˆç­–ç•¥
  if (request.mode === 'navigate') {
    return networkFirst(request, '/offline.html');
  }
  
  // å…¶ä»–èµ„æºï¼šç½‘ç»œä¼˜å…ˆç­–ç•¥
  return networkFirst(request);
}

// ç¼“å­˜ä¼˜å…ˆç­–ç•¥
async function cacheFirst(request) {
  try {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    const networkResponse = await fetch(request);
    
    // ç¼“å­˜æˆåŠŸçš„å“åº”
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.error('ç¼“å­˜ä¼˜å…ˆç­–ç•¥å¤±è´¥:', error);
    return new Response('ç¦»çº¿çŠ¶æ€', { status: 503 });
  }
}

// ç½‘ç»œä¼˜å…ˆç­–ç•¥
async function networkFirst(request, fallbackUrl = null) {
  try {
    const networkResponse = await fetch(request);
    
    // ç¼“å­˜æˆåŠŸçš„å“åº”
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.log('ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œå°è¯•ç¼“å­˜:', request.url);
    
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // è¿”å›ç¦»çº¿é¡µé¢
    if (fallbackUrl) {
      const fallbackResponse = await caches.match(fallbackUrl);
      if (fallbackResponse) {
        return fallbackResponse;
      }
    }
    
    return new Response('ç¦»çº¿çŠ¶æ€', { status: 503 });
  }
}

// ä»…ç½‘ç»œç­–ç•¥ï¼ˆç”¨äºå…³é”®APIï¼‰
async function networkOnly(request) {
  return fetch(request);
}

// ä»…ç¼“å­˜ç­–ç•¥ï¼ˆç”¨äºé™æ€èµ„æºï¼‰
async function cacheOnly(request) {
  return caches.match(request);
}

// æœ€å¿«å“åº”ç­–ç•¥ï¼ˆåŒæ—¶è¯·æ±‚ç½‘ç»œå’Œç¼“å­˜ï¼‰
async function staleWhileRevalidate(request) {
  const cachedResponse = caches.match(request);
  const networkResponse = fetch(request).then((response) => {
    if (response.ok) {
      const cache = caches.open(DYNAMIC_CACHE);
      cache.then((c) => c.put(request, response.clone()));
    }
    return response;
  });
  
  return cachedResponse || networkResponse;
}

// ç¼“å­˜ç®¡ç†å·¥å…·
class CacheManager {
  static async clearOldCaches(currentCaches) {
    const cacheNames = await caches.keys();
    const deletePromises = cacheNames
      .filter(name => !currentCaches.includes(name))
      .map(name => caches.delete(name));
    
    return Promise.all(deletePromises);
  }
  
  static async getCacheSize(cacheName) {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    let totalSize = 0;
    
    for (const key of keys) {
      const response = await cache.match(key);
      if (response) {
        const blob = await response.blob();
        totalSize += blob.size;
      }
    }
    
    return totalSize;
  }
  
  static async limitCacheSize(cacheName, maxSize) {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    
    while (await this.getCacheSize(cacheName) > maxSize && keys.length > 0) {
      const oldestKey = keys.shift();
      await cache.delete(oldestKey);
    }
  }
}

// æ¶ˆæ¯å¤„ç†
self.addEventListener('message', (event) => {
  const { type, payload } = event.data;
  
  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'GET_CACHE_SIZE':
      CacheManager.getCacheSize(payload.cacheName)
        .then(size => {
          event.ports[0].postMessage({ size });
        });
      break;
      
    case 'CLEAR_CACHE':
      caches.delete(payload.cacheName)
        .then(() => {
          event.ports[0].postMessage({ success: true });
        });
      break;
  }
});
```

</TabItem>
<TabItem value="background-sync" label="åå°åŒæ­¥">

#### åå°åŒæ­¥å®ç°

```javascript title="åå°åŒæ­¥åŠŸèƒ½"
// sw.js - åå°åŒæ­¥åŠŸèƒ½
// åå°åŒæ­¥äº‹ä»¶
self.addEventListener('sync', (event) => {
  console.log('åå°åŒæ­¥äº‹ä»¶:', event.tag);
  
  switch (event.tag) {
    case 'background-sync':
      event.waitUntil(doBackgroundSync());
      break;
    case 'send-messages':
      event.waitUntil(sendPendingMessages());
      break;
    case 'upload-data':
      event.waitUntil(uploadPendingData());
      break;
  }
});

// æ‰§è¡Œåå°åŒæ­¥
async function doBackgroundSync() {
  try {
    console.log('æ‰§è¡Œåå°åŒæ­¥...');
    
    // åŒæ­¥ç¦»çº¿æ•°æ®
    await syncOfflineData();
    
    // å‘é€å¾…å‘é€çš„æ¶ˆæ¯
    await sendPendingMessages();
    
    // ä¸Šä¼ å¾…ä¸Šä¼ çš„æ–‡ä»¶
    await uploadPendingFiles();
    
    console.log('åå°åŒæ­¥å®Œæˆ');
    
    // é€šçŸ¥å®¢æˆ·ç«¯åŒæ­¥å®Œæˆ
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        timestamp: Date.now()
      });
    });
    
  } catch (error) {
    console.error('åå°åŒæ­¥å¤±è´¥:', error);
    throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œè®©æµè§ˆå™¨é‡è¯•
  }
}

// åŒæ­¥ç¦»çº¿æ•°æ®
async function syncOfflineData() {
  const db = await openIndexedDB();
  const pendingData = await getPendingData(db);
  
  for (const data of pendingData) {
    try {
      const response = await fetch('/api/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (response.ok) {
        await removePendingData(db, data.id);
        console.log('æ•°æ®åŒæ­¥æˆåŠŸ:', data.id);
      }
    } catch (error) {
      console.error('æ•°æ®åŒæ­¥å¤±è´¥:', data.id, error);
    }
  }
}

// å‘é€å¾…å‘é€çš„æ¶ˆæ¯
async function sendPendingMessages() {
  const db = await openIndexedDB();
  const pendingMessages = await getPendingMessages(db);
  
  for (const message of pendingMessages) {
    try {
      const response = await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(message)
      });
      
      if (response.ok) {
        await removePendingMessage(db, message.id);
        console.log('æ¶ˆæ¯å‘é€æˆåŠŸ:', message.id);
      }
    } catch (error) {
      console.error('æ¶ˆæ¯å‘é€å¤±è´¥:', message.id, error);
    }
  }
}

// IndexedDBæ“ä½œ
function openIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('PWADatabase', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // åˆ›å»ºå­˜å‚¨å¯¹è±¡
      if (!db.objectStoreNames.contains('pendingData')) {
        const store = db.createObjectStore('pendingData', { keyPath: 'id' });
        store.createIndex('timestamp', 'timestamp', { unique: false });
      }
      
      if (!db.objectStoreNames.contains('pendingMessages')) {
        const store = db.createObjectStore('pendingMessages', { keyPath: 'id' });
        store.createIndex('timestamp', 'timestamp', { unique: false });
      }
    };
  });
}

// è·å–å¾…åŒæ­¥æ•°æ®
function getPendingData(db) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['pendingData'], 'readonly');
    const store = transaction.objectStore('pendingData');
    const request = store.getAll();
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

// ä¸»åº”ç”¨ä¸­çš„åå°åŒæ­¥ç®¡ç†
class BackgroundSyncManager {
  constructor() {
    this.isOnline = navigator.onLine;
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // ç›‘å¬ç½‘ç»œçŠ¶æ€å˜åŒ–
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.triggerSync();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline = false;
    });
    
    // ç›‘å¬Service Workeræ¶ˆæ¯
    navigator.serviceWorker.addEventListener('message', (event) => {
      if (event.data.type === 'SYNC_COMPLETE') {
        this.handleSyncComplete(event.data);
      }
    });
  }
  
  // æ·»åŠ æ•°æ®åˆ°åŒæ­¥é˜Ÿåˆ—
  async addToSyncQueue(data) {
    const db = await this.openDB();
    const transaction = db.transaction(['pendingData'], 'readwrite');
    const store = transaction.objectStore('pendingData');
    
    const syncData = {
      id: Date.now() + Math.random(),
      ...data,
      timestamp: Date.now()
    };
    
    await store.add(syncData);
    
    // å¦‚æœåœ¨çº¿ï¼Œç«‹å³å°è¯•åŒæ­¥
    if (this.isOnline) {
      this.triggerSync();
    }
  }
  
  // è§¦å‘åå°åŒæ­¥
  async triggerSync() {
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      const registration = await navigator.serviceWorker.ready;
      await registration.sync.register('background-sync');
    }
  }
  
  // å¤„ç†åŒæ­¥å®Œæˆ
  handleSyncComplete(data) {
    console.log('åå°åŒæ­¥å®Œæˆ:', data.timestamp);
    
    // è§¦å‘è‡ªå®šä¹‰äº‹ä»¶
    window.dispatchEvent(new CustomEvent('sync-complete', {
      detail: data
    }));
  }
  
  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('PWADatabase', 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const syncManager = new BackgroundSyncManager();

// æ·»åŠ æ•°æ®åˆ°åŒæ­¥é˜Ÿåˆ—
document.getElementById('saveButton').addEventListener('click', async () => {
  const formData = {
    name: document.getElementById('name').value,
    email: document.getElementById('email').value,
    message: document.getElementById('message').value
  };
  
  try {
    if (navigator.onLine) {
      // åœ¨çº¿æ—¶ç›´æ¥å‘é€
      const response = await fetch('/api/data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (response.ok) {
        showMessage('æ•°æ®ä¿å­˜æˆåŠŸ');
      } else {
        throw new Error('ä¿å­˜å¤±è´¥');
      }
    } else {
      // ç¦»çº¿æ—¶æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
      await syncManager.addToSyncQueue(formData);
      showMessage('æ•°æ®å·²ä¿å­˜åˆ°ç¦»çº¿é˜Ÿåˆ—ï¼Œå°†åœ¨ç½‘ç»œæ¢å¤æ—¶åŒæ­¥');
    }
  } catch (error) {
    // ä¿å­˜å¤±è´¥æ—¶ä¹Ÿæ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
    await syncManager.addToSyncQueue(formData);
    showMessage('æ•°æ®å·²ä¿å­˜åˆ°ç¦»çº¿é˜Ÿåˆ—');
  }
});

// ç›‘å¬åŒæ­¥å®Œæˆäº‹ä»¶
window.addEventListener('sync-complete', (event) => {
  showMessage('ç¦»çº¿æ•°æ®åŒæ­¥å®Œæˆ');
});
```

</TabItem>
</Tabs>

## 3. Webåº”ç”¨æ¸…å•(Manifest)

### 3.1 æ¸…å•æ–‡ä»¶é…ç½®

Webåº”ç”¨æ¸…å•æ˜¯ä¸€ä¸ªJSONæ–‡ä»¶ï¼Œå®šä¹‰äº†PWAçš„å…ƒæ•°æ®å’Œè¡Œä¸ºã€‚

<Tabs>
<TabItem value="basic-manifest" label="åŸºç¡€æ¸…å•">

#### åŸºç¡€æ¸…å•é…ç½®

```json title="manifest.json"
{
  "name": "æˆ‘çš„PWAåº”ç”¨",
  "short_name": "PWAåº”ç”¨",
  "description": "ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„æ¸è¿›å¼Webåº”ç”¨ç¤ºä¾‹",
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#2196F3",
  "background_color": "#ffffff",
  "lang": "zh-CN",
  "dir": "ltr",
  
  "icons": [
    {
      "src": "/images/icon-72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/images/icon-384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  
  "categories": ["productivity", "utilities"],
  "screenshots": [
    {
      "src": "/images/screenshot-mobile.png",
      "sizes": "640x1136",
      "type": "image/png",
      "form_factor": "narrow"
    },
    {
      "src": "/images/screenshot-desktop.png",
      "sizes": "1280x720",
      "type": "image/png",
      "form_factor": "wide"
    }
  ]
}
```

</TabItem>
<TabItem value="advanced-manifest" label="é«˜çº§é…ç½®">

#### é«˜çº§æ¸…å•é…ç½®

```json title="é«˜çº§manifest.jsoné…ç½®"
{
  "name": "é«˜çº§PWAåº”ç”¨",
  "short_name": "é«˜çº§PWA",
  "description": "å…·æœ‰é«˜çº§åŠŸèƒ½çš„æ¸è¿›å¼Webåº”ç”¨",
  "start_url": "/?utm_source=pwa&utm_medium=homescreen",
  "scope": "/",
  "id": "/",
  "display": "standalone",
  "display_override": ["window-controls-overlay", "minimal-ui"],
  "orientation": "any",
  "theme_color": "#1976D2",
  "background_color": "#fafafa",
  "lang": "zh-CN",
  "dir": "ltr",
  
  "icons": [
    {
      "src": "/images/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-192-maskable.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/images/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/images/icon-512-maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  
  "shortcuts": [
    {
      "name": "æ–°å»ºæ–‡æ¡£",
      "short_name": "æ–°å»º",
      "description": "å¿«é€Ÿåˆ›å»ºæ–°æ–‡æ¡£",
      "url": "/new-document",
      "icons": [
        {
          "src": "/images/shortcut-new.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "æœ€è¿‘æ–‡æ¡£",
      "short_name": "æœ€è¿‘",
      "description": "æŸ¥çœ‹æœ€è¿‘ç¼–è¾‘çš„æ–‡æ¡£",
      "url": "/recent-documents",
      "icons": [
        {
          "src": "/images/shortcut-recent.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    }
  ],
  
  "categories": ["productivity", "business", "utilities"],
  "iarc_rating_id": "e84b072d-71b3-4d3e-86ae-31a8ce4e53b7",
  
  "prefer_related_applications": false,
  "related_applications": [
    {
      "platform": "play",
      "url": "https://play.google.com/store/apps/details?id=com.example.app",
      "id": "com.example.app"
    },
    {
      "platform": "itunes",
      "url": "https://apps.apple.com/app/example-app/id123456789"
    }
  ],
  
  "protocol_handlers": [
    {
      "protocol": "mailto",
      "url": "/compose?to=%s"
    },
    {
      "protocol": "web+pwa",
      "url": "/handle-protocol?url=%s"
    }
  ],
  
  "file_handlers": [
    {
      "action": "/open-file",
      "accept": {
        "text/plain": [".txt"],
        "application/json": [".json"],
        "image/*": [".png", ".jpg", ".jpeg", ".gif"]
      }
    }
  ],
  
  "share_target": {
    "action": "/share",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url",
      "files": [
        {
          "name": "files",
          "accept": ["image/*", "text/plain"]
        }
      ]
    }
  },
  
  "launch_handler": {
    "client_mode": "navigate-existing"
  },
  
  "edge_side_panel": {
    "preferred_width": 400
  }
}
```

</TabItem>
<TabItem value="manifest-validation" label="æ¸…å•éªŒè¯">

#### æ¸…å•æ–‡ä»¶éªŒè¯ä¸ä¼˜åŒ–

```javascript title="æ¸…å•æ–‡ä»¶éªŒè¯å·¥å…·"
class ManifestValidator {
  constructor(manifest) {
    this.manifest = manifest;
    this.errors = [];
    this.warnings = [];
  }
  
  validate() {
    this.validateRequired();
    this.validateIcons();
    this.validateDisplay();
    this.validateUrls();
    this.validateColors();
    this.validateScreenshots();
    
    return {
      isValid: this.errors.length === 0,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  
  validateRequired() {
    const required = ['name', 'start_url', 'display', 'icons'];
    
    required.forEach(field => {
      if (!this.manifest[field]) {
        this.errors.push(`ç¼ºå°‘å¿…éœ€å­—æ®µ: ${field}`);
      }
    });
    
    if (!this.manifest.short_name && this.manifest.name.length > 12) {
      this.warnings.push('å»ºè®®æä¾›short_nameï¼Œå› ä¸ºnameå¤ªé•¿');
    }
  }
  
  validateIcons() {
    if (!this.manifest.icons || this.manifest.icons.length === 0) {
      this.errors.push('è‡³å°‘éœ€è¦ä¸€ä¸ªå›¾æ ‡');
      return;
    }
    
    const requiredSizes = ['192x192', '512x512'];
    const availableSizes = this.manifest.icons.map(icon => icon.sizes);
    
    requiredSizes.forEach(size => {
      if (!availableSizes.includes(size)) {
        this.errors.push(`ç¼ºå°‘${size}å°ºå¯¸çš„å›¾æ ‡`);
      }
    });
    
    // æ£€æŸ¥maskableå›¾æ ‡
    const hasMaskable = this.manifest.icons.some(icon => 
      icon.purpose && icon.purpose.includes('maskable')
    );
    
    if (!hasMaskable) {
      this.warnings.push('å»ºè®®æä¾›maskableå›¾æ ‡ä»¥æ”¯æŒè‡ªé€‚åº”å›¾æ ‡');
    }
    
    // éªŒè¯å›¾æ ‡URL
    this.manifest.icons.forEach((icon, index) => {
      if (!icon.src) {
        this.errors.push(`å›¾æ ‡${index}ç¼ºå°‘srcå±æ€§`);
      }
      
      if (!icon.sizes) {
        this.warnings.push(`å›¾æ ‡${index}ç¼ºå°‘sizeså±æ€§`);
      }
      
      if (!icon.type) {
        this.warnings.push(`å›¾æ ‡${index}ç¼ºå°‘typeå±æ€§`);
      }
    });
  }
  
  validateDisplay() {
    const validDisplayModes = [
      'fullscreen', 'standalone', 'minimal-ui', 'browser'
    ];
    
    if (!validDisplayModes.includes(this.manifest.display)) {
      this.errors.push(`æ— æ•ˆçš„displayå€¼: ${this.manifest.display}`);
    }
  }
  
  validateUrls() {
    const urlFields = ['start_url', 'scope'];
    
    urlFields.forEach(field => {
      if (this.manifest[field]) {
        try {
          new URL(this.manifest[field], window.location.origin);
        } catch (error) {
          this.errors.push(`${field}ä¸æ˜¯æœ‰æ•ˆçš„URL: ${this.manifest[field]}`);
        }
      }
    });
    
    // éªŒè¯scopeåŒ…å«start_url
    if (this.manifest.scope && this.manifest.start_url) {
      const scope = new URL(this.manifest.scope, window.location.origin);
      const startUrl = new URL(this.manifest.start_url, window.location.origin);
      
      if (!startUrl.pathname.startsWith(scope.pathname)) {
        this.warnings.push('start_urlåº”è¯¥åœ¨scopeèŒƒå›´å†…');
      }
    }
  }
  
  validateColors() {
    const colorFields = ['theme_color', 'background_color'];
    
    colorFields.forEach(field => {
      if (this.manifest[field]) {
        if (!this.isValidColor(this.manifest[field])) {
          this.errors.push(`${field}ä¸æ˜¯æœ‰æ•ˆçš„é¢œè‰²å€¼: ${this.manifest[field]}`);
        }
      }
    });
  }
  
  validateScreenshots() {
    if (this.manifest.screenshots) {
      this.manifest.screenshots.forEach((screenshot, index) => {
        if (!screenshot.src) {
          this.errors.push(`æˆªå›¾${index}ç¼ºå°‘srcå±æ€§`);
        }
        
        if (!screenshot.sizes) {
          this.warnings.push(`æˆªå›¾${index}ç¼ºå°‘sizeså±æ€§`);
        }
        
        if (!screenshot.type) {
          this.warnings.push(`æˆªå›¾${index}ç¼ºå°‘typeå±æ€§`);
        }
      });
    }
  }
  
  isValidColor(color) {
    const style = new Option().style;
    style.color = color;
    return style.color !== '';
  }
}

// æ¸…å•æ–‡ä»¶ç”Ÿæˆå™¨
class ManifestGenerator {
  constructor() {
    this.manifest = {
      name: '',
      short_name: '',
      description: '',
      start_url: '/',
      scope: '/',
      display: 'standalone',
      theme_color: '#000000',
      background_color: '#ffffff',
      icons: []
    };
  }
  
  setBasicInfo(name, shortName, description) {
    this.manifest.name = name;
    this.manifest.short_name = shortName;
    this.manifest.description = description;
    return this;
  }
  
  setUrls(startUrl, scope) {
    this.manifest.start_url = startUrl;
    this.manifest.scope = scope;
    return this;
  }
  
  setDisplay(display, orientation = 'any') {
    this.manifest.display = display;
    this.manifest.orientation = orientation;
    return this;
  }
  
  setColors(themeColor, backgroundColor) {
    this.manifest.theme_color = themeColor;
    this.manifest.background_color = backgroundColor;
    return this;
  }
  
  addIcon(src, sizes, type = 'image/png', purpose = 'any') {
    this.manifest.icons.push({
      src,
      sizes,
      type,
      purpose
    });
    return this;
  }
  
  addShortcut(name, url, description, iconSrc) {
    if (!this.manifest.shortcuts) {
      this.manifest.shortcuts = [];
    }
    
    this.manifest.shortcuts.push({
      name,
      url,
      description,
      icons: iconSrc ? [{
        src: iconSrc,
        sizes: '96x96',
        type: 'image/png'
      }] : []
    });
    return this;
  }
  
  generate() {
    return JSON.stringify(this.manifest, null, 2);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const generator = new ManifestGenerator()
  .setBasicInfo('æˆ‘çš„åº”ç”¨', 'åº”ç”¨', 'è¿™æ˜¯ä¸€ä¸ªPWAåº”ç”¨')
  .setUrls('/', '/')
  .setDisplay('standalone', 'portrait')
  .setColors('#2196F3', '#ffffff')
  .addIcon('/icon-192.png', '192x192')
  .addIcon('/icon-512.png', '512x512')
  .addShortcut('æ–°å»º', '/new', 'åˆ›å»ºæ–°å†…å®¹', '/shortcut-new.png');

const manifestJson = generator.generate();
console.log(manifestJson);

// éªŒè¯ç”Ÿæˆçš„æ¸…å•
const validator = new ManifestValidator(JSON.parse(manifestJson));
const result = validator.validate();
console.log('éªŒè¯ç»“æœ:', result);
```

</TabItem>
</Tabs> 