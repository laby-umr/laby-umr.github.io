---
sidebar_position: 3
title: å‰ç«¯æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥è¯¦è§£
description: æ·±å…¥è§£æDOMæ“ä½œä¼˜åŒ–ã€é‡æ’é‡ç»˜æ§åˆ¶ã€è™šæ‹Ÿæ»šåŠ¨ä¸Reactæ¸²æŸ“æ€§èƒ½æœ€ä½³å®è·µ
authors: [Laby]
tags: [æ¸²æŸ“ä¼˜åŒ–, DOMæ“ä½œ, é‡æ’é‡ç»˜, è™šæ‹Ÿæ»šåŠ¨, Reactæ€§èƒ½, é˜²æŠ–èŠ‚æµ]
last_update:
  date: 2025-08-14
  author: Laby
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# å‰ç«¯æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥è¯¦è§£

æ¸²æŸ“ä¼˜åŒ–æ˜¯å‰ç«¯æ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒç¯èŠ‚ï¼Œç›´æ¥å½±å“ç”¨æˆ·ç•Œé¢çš„æµç•…åº¦å’Œå“åº”æ€§ã€‚é€šè¿‡ç³»ç»ŸåŒ–çš„æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥ï¼Œå¯ä»¥å®ç°60fpsçš„ä¸æ»‘ä½“éªŒï¼Œæå‡ç”¨æˆ·æ»¡æ„åº¦å’Œåº”ç”¨æ€§èƒ½ã€‚

:::tip æ ¸å¿ƒä»·å€¼
**æ¸²æŸ“ä¼˜åŒ– = DOMä¼˜åŒ– + é‡æ’é‡ç»˜æ§åˆ¶ + äº‹ä»¶ä¼˜åŒ– + è™šæ‹ŸåŒ–æŠ€æœ¯**
- ğŸ¯ **DOMæ“ä½œä¼˜åŒ–**ï¼šå‡å°‘DOMæ“ä½œæ¬¡æ•°ï¼Œæ‰¹é‡å¤„ç†æ›´æ–°
- ğŸ”„ **é‡æ’é‡ç»˜æ§åˆ¶**ï¼šé¿å…å¼ºåˆ¶åŒæ­¥å¸ƒå±€ï¼Œä½¿ç”¨GPUåŠ é€Ÿ
- âš¡ **äº‹ä»¶ä¼˜åŒ–**ï¼šé˜²æŠ–èŠ‚æµï¼Œäº‹ä»¶å§”æ‰˜å‡å°‘å†…å­˜å ç”¨
- ğŸ“Š **è™šæ‹ŸåŒ–æŠ€æœ¯**ï¼šå¤§æ•°æ®åˆ—è¡¨æ¸²æŸ“ä¼˜åŒ–
- ğŸ§  **Reactä¼˜åŒ–**ï¼šmemoã€useMemoã€useCallbackåˆç†ä½¿ç”¨
- ğŸ“ˆ **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æ¸²æŸ“æ€§èƒ½æŒ‡æ ‡
:::

## 1. æµè§ˆå™¨æ¸²æŸ“æœºåˆ¶

### 1.1 æ¸²æŸ“æµæ°´çº¿

ç†è§£æµè§ˆå™¨æ¸²æŸ“æµæ°´çº¿æ˜¯ä¼˜åŒ–çš„åŸºç¡€ï¼Œæ¯ä¸ªæ­¥éª¤éƒ½å¯èƒ½æˆä¸ºæ€§èƒ½ç“¶é¢ˆã€‚

```mermaid
graph LR
    subgraph "æµè§ˆå™¨æ¸²æŸ“æµæ°´çº¿"
        A[HTMLè§£æ] --> B[DOMæ„å»º]
        C[CSSè§£æ] --> D[CSSOMæ„å»º]
        B --> E[æ¸²æŸ“æ ‘æ„å»º]
        D --> E
        E --> F[å¸ƒå±€Layout]
        F --> G[ç»˜åˆ¶Paint]
        G --> H[åˆæˆComposite]
        
        subgraph "æ€§èƒ½å½±å“"
            F --> F1[é‡æ’Reflow]
            G --> G1[é‡ç»˜Repaint]
            H --> H1[åˆæˆå±‚]
        end
    end
```

#### æ¸²æŸ“æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æ“ä½œç±»å‹ | è§¦å‘é˜¶æ®µ | æ€§èƒ½å½±å“ | ä¼˜åŒ–ç­–ç•¥ | ç¤ºä¾‹å±æ€§ |
|---------|----------|----------|----------|----------|
| **é‡æ’+é‡ç»˜+åˆæˆ** | Layout â†’ Paint â†’ Composite | æœ€é«˜ | é¿å…æˆ–æ‰¹é‡æ“ä½œ | width, height, margin |
| **é‡ç»˜+åˆæˆ** | Paint â†’ Composite | ä¸­ç­‰ | ä½¿ç”¨åˆæˆå±‚ | color, background |
| **ä»…åˆæˆ** | Composite | æœ€ä½ | ä¼˜å…ˆä½¿ç”¨ | transform, opacity |
| **æ— å½±å“** | - | æ—  | ç†æƒ³çŠ¶æ€ | è¯»å–è®¡ç®—æ ·å¼ |

## 2. DOMæ“ä½œä¼˜åŒ–ç­–ç•¥

### 2.1 æ‰¹é‡DOMæ“ä½œæŠ€æœ¯

DOMæ“ä½œæ˜¯æ¸²æŸ“æ€§èƒ½çš„ä¸»è¦ç“¶é¢ˆï¼Œé€šè¿‡æ‰¹é‡æ“ä½œå’ŒDocumentFragmentå¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½ã€‚

<Tabs>
<TabItem value="batch-operations" label="æ‰¹é‡æ“ä½œ">

#### DOMæ‰¹é‡æ“ä½œæœ€ä½³å®è·µ

```javascript title="DOMæ‰¹é‡æ“ä½œä¼˜åŒ–å¯¹æ¯”"
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šé¢‘ç¹DOMæ“ä½œ
function inefficientDOMOperations() {
  const list = document.getElementById('product-list');
  const products = getProducts(); // å‡è®¾è¿”å›1000ä¸ªäº§å“
  
  // æ¯æ¬¡appendChildéƒ½ä¼šè§¦å‘é‡æ’é‡ç»˜
  products.forEach(product => {
    const item = document.createElement('div');
    item.className = 'product-item';
    item.innerHTML = `
      <h3>${product.name}</h3>
      <p>Â¥${product.price}</p>
      <button onclick="addToCart(${product.id})">åŠ å…¥è´­ç‰©è½¦</button>
    `;
    list.appendChild(item); // è§¦å‘1000æ¬¡é‡æ’ï¼
  });
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ‰¹é‡DOMæ“ä½œ
function efficientDOMOperations() {
  const list = document.getElementById('product-list');
  const products = getProducts();
  const fragment = document.createDocumentFragment();
  
  // åœ¨å†…å­˜ä¸­æ„å»ºDOMç»“æ„
  products.forEach(product => {
    const item = document.createElement('div');
    item.className = 'product-item';
    item.innerHTML = `
      <h3>${product.name}</h3>
      <p>Â¥${product.price}</p>
      <button onclick="addToCart(${product.id})">åŠ å…¥è´­ç‰©è½¦</button>
    `;
    fragment.appendChild(item); // åœ¨å†…å­˜ä¸­æ“ä½œ
  });
  
  list.appendChild(fragment); // åªè§¦å‘1æ¬¡é‡æ’ï¼
}

// ğŸš€ é«˜çº§ç¤ºä¾‹ï¼šè™šæ‹ŸDOMæ‰¹é‡æ›´æ–°
class DOMBatcher {
  constructor() {
    this.updates = [];
    this.isScheduled = false;
  }
  
  scheduleUpdate(element, property, value) {
    this.updates.push({ element, property, value });
    
    if (!this.isScheduled) {
      this.isScheduled = true;
      requestAnimationFrame(() => this.flushUpdates());
    }
  }
  
  flushUpdates() {
    // æ‰¹é‡åº”ç”¨æ‰€æœ‰æ›´æ–°
    this.updates.forEach(({ element, property, value }) => {
      element.style[property] = value;
    });
    
    this.updates = [];
    this.isScheduled = false;
  }
}

// ä½¿ç”¨æ‰¹é‡æ›´æ–°å™¨
const batcher = new DOMBatcher();

function animateElements() {
  const elements = document.querySelectorAll('.animated-item');
  
  elements.forEach((element, index) => {
    // è°ƒåº¦æ›´æ–°è€Œä¸æ˜¯ç«‹å³æ‰§è¡Œ
    batcher.scheduleUpdate(element, 'transform', `translateX(${index * 10}px)`);
    batcher.scheduleUpdate(element, 'opacity', '0.8');
  });
}
```

</TabItem>
<TabItem value="fragment-usage" label="DocumentFragment">

#### DocumentFragmenté«˜çº§ç”¨æ³•

```javascript title="DocumentFragmentæœ€ä½³å®è·µ"
// åŸºç¡€DocumentFragmentä½¿ç”¨
class DOMBuilder {
  constructor() {
    this.fragment = document.createDocumentFragment();
  }
  
  // åˆ›å»ºäº§å“å¡ç‰‡
  createProductCard(product) {
    const card = document.createElement('div');
    card.className = 'product-card';
    card.dataset.productId = product.id;
    
    card.innerHTML = `
      <div class="product-image">
        <img src="${product.image}" alt="${product.name}" loading="lazy">
        ${!product.inStock ? '<div class="out-of-stock">ç¼ºè´§</div>' : ''}
      </div>
      <div class="product-info">
        <h3 class="product-name">${product.name}</h3>
        <p class="product-price">Â¥${product.price}</p>
        <div class="product-rating">
          ${this.createStarRating(product.rating)}
        </div>
        <button class="add-to-cart-btn" ${!product.inStock ? 'disabled' : ''}>
          ${product.inStock ? 'åŠ å…¥è´­ç‰©è½¦' : 'ç¼ºè´§'}
        </button>
      </div>
    `;
    
    return card;
  }
  
  // åˆ›å»ºæ˜Ÿçº§è¯„åˆ†
  createStarRating(rating) {
    const stars = [];
    for (let i = 1; i <= 5; i++) {
      const starClass = i <= rating ? 'star-filled' : 'star-empty';
      stars.push(`<span class="star ${starClass}">â˜…</span>`);
    }
    return stars.join('');
  }
  
  // æ‰¹é‡åˆ›å»ºå¹¶æ·»åŠ äº§å“
  buildProductGrid(products, container) {
    // æ¸…ç©ºç°æœ‰å†…å®¹
    container.innerHTML = '';
    
    // æ‰¹é‡åˆ›å»ºäº§å“å¡ç‰‡
    products.forEach(product => {
      const card = this.createProductCard(product);
      this.fragment.appendChild(card);
    });
    
    // ä¸€æ¬¡æ€§æ·»åŠ åˆ°DOM
    container.appendChild(this.fragment);
    
    // é‡ç½®fragmentä»¥ä¾¿é‡ç”¨
    this.fragment = document.createDocumentFragment();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const domBuilder = new DOMBuilder();
const productContainer = document.getElementById('product-grid');

// åˆå§‹åŠ è½½äº§å“
fetch('/api/products')
  .then(response => response.json())
  .then(products => {
    domBuilder.buildProductGrid(products, productContainer);
  });
```

</TabItem>
</Tabs>

## 3. é‡æ’é‡ç»˜ä¼˜åŒ–ç­–ç•¥

### 3.1 é¿å…å¼ºåˆ¶åŒæ­¥å¸ƒå±€

å¼ºåˆ¶åŒæ­¥å¸ƒå±€æ˜¯æ€§èƒ½æ€æ‰‹ï¼Œäº†è§£å¦‚ä½•é¿å…æ˜¯ä¼˜åŒ–çš„å…³é”®ã€‚

:::warning æ€§èƒ½é™·é˜±
è¯»å–å¸ƒå±€å±æ€§ï¼ˆå¦‚offsetWidthã€scrollTopï¼‰ä¼šå¼ºåˆ¶æµè§ˆå™¨ç«‹å³è®¡ç®—å¸ƒå±€ï¼Œæ‰“æ–­æ¸²æŸ“æµæ°´çº¿ï¼
:::

<Tabs>
<TabItem value="layout-thrashing" label="å¸ƒå±€æŠ–åŠ¨">

#### é¿å…å¸ƒå±€æŠ–åŠ¨

```javascript title="å¸ƒå±€æŠ–åŠ¨ä¼˜åŒ–å¯¹æ¯”"
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šå¸ƒå±€æŠ–åŠ¨
function layoutThrashing() {
  const elements = document.querySelectorAll('.animated-item');
  
  elements.forEach(element => {
    // è¯»å–å¸ƒå±€å±æ€§ï¼Œå¼ºåˆ¶åŒæ­¥å¸ƒå±€
    const width = element.offsetWidth;
    const height = element.offsetHeight;
    
    // ä¿®æ”¹æ ·å¼ï¼Œè§¦å‘é‡æ’
    element.style.width = width + 10 + 'px';
    element.style.height = height + 10 + 'px';
    
    // å†æ¬¡è¯»å–ï¼Œåˆä¸€æ¬¡å¼ºåˆ¶åŒæ­¥å¸ƒå±€
    const newWidth = element.offsetWidth;
    console.log('New width:', newWidth);
  });
}

// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šæ‰¹é‡è¯»å†™åˆ†ç¦»
function optimizedLayout() {
  const elements = document.querySelectorAll('.animated-item');
  const measurements = [];
  
  // ç¬¬ä¸€é˜¶æ®µï¼šæ‰¹é‡è¯»å–
  elements.forEach(element => {
    measurements.push({
      element,
      width: element.offsetWidth,
      height: element.offsetHeight
    });
  });
  
  // ç¬¬äºŒé˜¶æ®µï¼šæ‰¹é‡å†™å…¥
  measurements.forEach(({ element, width, height }) => {
    element.style.width = width + 10 + 'px';
    element.style.height = height + 10 + 'px';
  });
  
  // ç¬¬ä¸‰é˜¶æ®µï¼šæ‰¹é‡è¯»å–æ–°å€¼ï¼ˆå¦‚æœéœ€è¦ï¼‰
  measurements.forEach(({ element }) => {
    const newWidth = element.offsetWidth;
    console.log('New width:', newWidth);
  });
}
```

</TabItem>
<TabItem value="gpu-acceleration" label="GPUåŠ é€Ÿ">

#### åˆ©ç”¨GPUåŠ é€Ÿ

```javascript title="GPUåŠ é€Ÿä¼˜åŒ–ç­–ç•¥"
// CSS GPUåŠ é€Ÿå±æ€§
const gpuAcceleratedProperties = {
  // ä¼˜å…ˆä½¿ç”¨çš„GPUåŠ é€Ÿå±æ€§
  transform: 'translateX(100px) scale(1.2)',
  opacity: '0.8',
  filter: 'blur(2px)',
  
  // é¿å…ä½¿ç”¨çš„CPUå¯†é›†å±æ€§
  // left: '100px',        // è§¦å‘é‡æ’
  // width: '200px',       // è§¦å‘é‡æ’
  // background: 'red',    // è§¦å‘é‡ç»˜
};

// åˆ›å»ºåˆæˆå±‚çš„æŠ€å·§
class GPUAccelerator {
  static createCompositeLayer(element) {
    // æ–¹æ³•1ï¼šä½¿ç”¨transform3då¼ºåˆ¶åˆ›å»ºåˆæˆå±‚
    element.style.transform = 'translateZ(0)';
    
    // æ–¹æ³•2ï¼šä½¿ç”¨will-changeæç¤ºæµè§ˆå™¨
    element.style.willChange = 'transform, opacity';
    
    // æ–¹æ³•3ï¼šä½¿ç”¨backface-visibility
    element.style.backfaceVisibility = 'hidden';
  }
  
  static optimizeAnimation(element, keyframes, options = {}) {
    // ç¡®ä¿åŠ¨ç”»åœ¨åˆæˆå±‚ä¸Šè¿è¡Œ
    this.createCompositeLayer(element);
    
    // ä½¿ç”¨Web Animations API
    const animation = element.animate(keyframes, {
      duration: 1000,
      easing: 'ease-out',
      fill: 'forwards',
      ...options
    });
    
    // åŠ¨ç”»ç»“æŸåæ¸…ç†will-change
    animation.addEventListener('finish', () => {
      element.style.willChange = 'auto';
    });
    
    return animation;
  }
}
```

</TabItem>
</Tabs>

## 4. è™šæ‹Ÿæ»šåŠ¨ä¸å¤§æ•°æ®æ¸²æŸ“

### 4.1 è™šæ‹Ÿæ»šåŠ¨æ ¸å¿ƒåŸç†

è™šæ‹Ÿæ»šåŠ¨æ˜¯å¤„ç†å¤§é‡æ•°æ®åˆ—è¡¨çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œåªæ¸²æŸ“å¯è§†åŒºåŸŸå†…çš„å…ƒç´ ï¼Œå¤§å¹…æå‡æ€§èƒ½ã€‚

```mermaid
graph TB
    subgraph "è™šæ‹Ÿæ»šåŠ¨åŸç†"
        A[æ€»æ•°æ®: 10000æ¡] --> B[å¯è§†åŒºåŸŸè®¡ç®—]
        B --> C[æ¸²æŸ“èŒƒå›´: 20-40]
        C --> D[DOMå…ƒç´ : 20ä¸ª]
        
        E[æ»šåŠ¨äº‹ä»¶] --> F[é‡æ–°è®¡ç®—èŒƒå›´]
        F --> G[æ›´æ–°DOM]
        G --> H[å›æ”¶ä¸å¯è§å…ƒç´ ]
    end
```

<Tabs>
<TabItem value="basic-virtual-scroll" label="åŸºç¡€è™šæ‹Ÿæ»šåŠ¨">

#### åŸºç¡€è™šæ‹Ÿæ»šåŠ¨å®ç°

```javascript title="é«˜æ€§èƒ½è™šæ‹Ÿæ»šåŠ¨å™¨"
class VirtualScroller {
  constructor(options) {
    this.container = options.container;
    this.itemHeight = options.itemHeight;
    this.items = options.items || [];
    this.renderItem = options.renderItem;
    this.bufferSize = options.bufferSize || 5; // ç¼“å†²åŒºå¤§å°
    
    this.scrollTop = 0;
    this.containerHeight = 0;
    this.visibleStart = 0;
    this.visibleEnd = 0;
    this.renderedItems = new Map();
    
    this.init();
  }
  
  init() {
    this.setupContainer();
    this.calculateDimensions();
    this.bindEvents();
    this.render();
  }
  
  setupContainer() {
    this.container.style.position = 'relative';
    this.container.style.overflow = 'auto';
    
    // åˆ›å»ºå†…å®¹å®¹å™¨
    this.content = document.createElement('div');
    this.content.style.position = 'relative';
    this.content.style.height = `${this.items.length * this.itemHeight}px`;
    this.container.appendChild(this.content);
  }
  
  calculateDimensions() {
    this.containerHeight = this.container.clientHeight;
    this.visibleCount = Math.ceil(this.containerHeight / this.itemHeight);
  }
  
  bindEvents() {
    this.container.addEventListener('scroll', this.handleScroll.bind(this), {
      passive: true
    });
    
    // ç›‘å¬å®¹å™¨å°ºå¯¸å˜åŒ–
    if (window.ResizeObserver) {
      this.resizeObserver = new ResizeObserver(() => {
        this.calculateDimensions();
        this.render();
      });
      this.resizeObserver.observe(this.container);
    }
  }
  
  handleScroll() {
    const newScrollTop = this.container.scrollTop;
    
    // é˜²æŠ–ä¼˜åŒ–
    if (Math.abs(newScrollTop - this.scrollTop) < this.itemHeight / 2) {
      return;
    }
    
    this.scrollTop = newScrollTop;
    this.render();
  }
  
  calculateVisibleRange() {
    const start = Math.floor(this.scrollTop / this.itemHeight);
    const end = Math.min(
      start + this.visibleCount + this.bufferSize * 2,
      this.items.length
    );
    
    this.visibleStart = Math.max(0, start - this.bufferSize);
    this.visibleEnd = end;
  }
  
  render() {
    this.calculateVisibleRange();
    
    // ç§»é™¤ä¸åœ¨å¯è§†èŒƒå›´å†…çš„å…ƒç´ 
    this.cleanupInvisibleItems();
    
    // æ¸²æŸ“å¯è§†èŒƒå›´å†…çš„å…ƒç´ 
    for (let i = this.visibleStart; i < this.visibleEnd; i++) {
      if (!this.renderedItems.has(i)) {
        this.renderItemAt(i);
      }
    }
  }
  
  renderItemAt(index) {
    const item = this.items[index];
    const element = this.renderItem(item, index);
    
    // è®¾ç½®å…ƒç´ ä½ç½®
    element.style.position = 'absolute';
    element.style.top = `${index * this.itemHeight}px`;
    element.style.height = `${this.itemHeight}px`;
    element.style.width = '100%';
    element.dataset.index = index;
    
    this.content.appendChild(element);
    this.renderedItems.set(index, element);
  }
  
  cleanupInvisibleItems() {
    const toRemove = [];
    
    this.renderedItems.forEach((element, index) => {
      if (index < this.visibleStart || index >= this.visibleEnd) {
        toRemove.push(index);
      }
    });
    
    toRemove.forEach(index => {
      const element = this.renderedItems.get(index);
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
      this.renderedItems.delete(index);
    });
  }
  
  // æ›´æ–°æ•°æ®
  updateItems(newItems) {
    this.items = newItems;
    this.content.style.height = `${this.items.length * this.itemHeight}px`;
    
    // æ¸…ç©ºæ‰€æœ‰æ¸²æŸ“çš„å…ƒç´ 
    this.renderedItems.forEach(element => {
      if (element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    this.renderedItems.clear();
    
    this.render();
  }
  
  // æ»šåŠ¨åˆ°æŒ‡å®šç´¢å¼•
  scrollToIndex(index) {
    const targetScrollTop = index * this.itemHeight;
    this.container.scrollTop = targetScrollTop;
  }
  
  // é”€æ¯
  destroy() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    this.container.removeEventListener('scroll', this.handleScroll);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const virtualScroller = new VirtualScroller({
  container: document.getElementById('virtual-list'),
  itemHeight: 50,
  items: Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`,
    description: `Description for item ${i}`
  })),
  renderItem: (item, index) => {
    const div = document.createElement('div');
    div.className = 'virtual-item';
    div.innerHTML = `
      <div class="item-content">
        <h4>${item.name}</h4>
        <p>${item.description}</p>
        <small>Index: ${index}</small>
      </div>
    `;
    return div;
  },
  bufferSize: 10
});
```

</TabItem>
</Tabs>

## 5. Reactæ¸²æŸ“ä¼˜åŒ–ä¸“é¢˜

### 5.1 React.memoä¼˜åŒ–

React.memoæ˜¯Reactä¸­ç”¨äºä¼˜åŒ–å‡½æ•°ç»„ä»¶æ¸²æŸ“çš„é‡è¦å·¥å…·ã€‚

```typescript title="React.memoæœ€ä½³å®è·µ"
import React, { memo, useMemo, useCallback, useState } from 'react';

// åŸºç¡€memoä½¿ç”¨
interface UserCardProps {
  user: {
    id: number;
    name: string;
    email: string;
    avatar?: string;
  };
  onEdit: (id: number) => void;
  onDelete: (id: number) => void;
}

const UserCard = memo<UserCardProps>(({ user, onEdit, onDelete }) => {
  console.log('UserCard render:', user.name);
  
  return (
    <div className="user-card">
      <img src={user.avatar || '/default-avatar.png'} alt={user.name} />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
      <div className="user-actions">
        <button onClick={() => onEdit(user.id)}>ç¼–è¾‘</button>
        <button onClick={() => onDelete(user.id)}>åˆ é™¤</button>
      </div>
    </div>
  );
});

// ä½¿ç”¨ç¤ºä¾‹
const App: React.FC = () => {
  const [users, setUsers] = useState([
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' }
  ]);
  
  const [counter, setCounter] = useState(0);
  
  // ä½¿ç”¨useCallbackä¼˜åŒ–å›è°ƒå‡½æ•°
  const handleEditUser = useCallback((id: number) => {
    console.log('Edit user:', id);
  }, []);
  
  const handleDeleteUser = useCallback((id: number) => {
    setUsers(prev => prev.filter(user => user.id !== id));
  }, []);
  
  return (
    <div className="app">
      <h1>React.memoä¼˜åŒ–ç¤ºä¾‹</h1>
      
      {/* è®¡æ•°å™¨ä¸ä¼šå½±å“UserCardçš„é‡æ–°æ¸²æŸ“ */}
      <div>
        <p>è®¡æ•°å™¨: {counter}</p>
        <button onClick={() => setCounter(c => c + 1)}>å¢åŠ </button>
      </div>
      
      <div className="user-list">
        <h2>ç”¨æˆ·åˆ—è¡¨</h2>
        {users.map(user => (
          <UserCard
            key={user.id}
            user={user}
            onEdit={handleEditUser}
            onDelete={handleDeleteUser}
          />
        ))}
      </div>
    </div>
  );
};
```

## 6. æ€§èƒ½ç›‘æ§ä¸è°ƒè¯•

### 6.1 æ¸²æŸ“æ€§èƒ½ç›‘æ§å·¥å…·

å»ºç«‹å®Œå–„çš„æ€§èƒ½ç›‘æ§ä½“ç³»æ˜¯æŒç»­ä¼˜åŒ–çš„åŸºç¡€ã€‚

```typescript title="æ¸²æŸ“æ€§èƒ½ç›‘æ§ç³»ç»Ÿ"
// ç»¼åˆæ€§èƒ½ç›‘æ§ç±»
class RenderingPerformanceMonitor {
  private observers: Map<string, PerformanceObserver> = new Map();
  private metrics: Map<string, any[]> = new Map();
  private isMonitoring = false;
  
  constructor(private options: {
    enableFPS?: boolean;
    enableMemory?: boolean;
    enablePaint?: boolean;
    reportInterval?: number;
  } = {}) {
    this.options = {
      enableFPS: true,
      enableMemory: true,
      enablePaint: true,
      reportInterval: 5000,
      ...options
    };
  }
  
  start() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    
    if (this.options.enableFPS) {
      this.startFPSMonitoring();
    }
    
    if (this.options.enableMemory) {
      this.startMemoryMonitoring();
    }
    
    // å®šæœŸæŠ¥å‘Š
    setInterval(() => {
      this.generateReport();
    }, this.options.reportInterval);
  }
  
  private startFPSMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const countFrames = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastTime >= 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        this.recordMetric('fps', { value: fps, timestamp: currentTime });
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      if (this.isMonitoring) {
        requestAnimationFrame(countFrames);
      }
    };
    
    requestAnimationFrame(countFrames);
  }
  
  private startMemoryMonitoring() {
    if (!('memory' in performance)) return;
    
    const checkMemory = () => {
      const memory = (performance as any).memory;
      this.recordMetric('memory', {
        used: memory.usedJSHeapSize,
        total: memory.totalJSHeapSize,
        limit: memory.jsHeapSizeLimit,
        timestamp: performance.now()
      });
      
      if (this.isMonitoring) {
        setTimeout(checkMemory, 1000);
      }
    };
    
    checkMemory();
  }
  
  private recordMetric(type: string, data: any) {
    if (!this.metrics.has(type)) {
      this.metrics.set(type, []);
    }
    
    const metrics = this.metrics.get(type)!;
    metrics.push(data);
    
    // ä¿æŒæœ€è¿‘100æ¡è®°å½•
    if (metrics.length > 100) {
      metrics.shift();
    }
  }
  
  generateReport() {
    const report: any = {
      timestamp: new Date().toISOString(),
      metrics: {}
    };
    
    this.metrics.forEach((data, type) => {
      if (data.length === 0) return;
      
      switch (type) {
        case 'fps':
          const fpsValues = data.map(d => d.value);
          report.metrics.fps = {
            current: fpsValues[fpsValues.length - 1],
            average: fpsValues.reduce((sum, v) => sum + v, 0) / fpsValues.length,
            min: Math.min(...fpsValues),
            max: Math.max(...fpsValues)
          };
          break;
          
        case 'memory':
          const latestMemory = data[data.length - 1];
          report.metrics.memory = {
            used: Math.round(latestMemory.used / 1024 / 1024), // MB
            total: Math.round(latestMemory.total / 1024 / 1024), // MB
            usage: Math.round((latestMemory.used / latestMemory.total) * 100) // %
          };
          break;
      }
    });
    
    console.log('Performance Report:', report);
    return report;
  }
  
  stop() {
    this.isMonitoring = false;
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new RenderingPerformanceMonitor({
  enableFPS: true,
  enableMemory: true,
  reportInterval: 10000
});

// å¯åŠ¨ç›‘æ§
monitor.start();

// åœ¨åº”ç”¨å¸è½½æ—¶åœæ­¢ç›‘æ§
window.addEventListener('beforeunload', () => {
  monitor.stop();
});
```

é€šè¿‡è¿™ä¸ªå®Œæ•´çš„æ¸²æŸ“ä¼˜åŒ–æŒ‡å—ï¼Œå¼€å‘è€…å¯ä»¥ç³»ç»Ÿæ€§åœ°ç†è§£å’Œåº”ç”¨å„ç§æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯ï¼Œä»DOMæ“ä½œä¼˜åŒ–åˆ°Reactç»„ä»¶ä¼˜åŒ–ï¼Œä»è™šæ‹Ÿæ»šåŠ¨åˆ°æ€§èƒ½ç›‘æ§ï¼Œå…¨é¢æå‡Webåº”ç”¨çš„æ¸²æŸ“æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚